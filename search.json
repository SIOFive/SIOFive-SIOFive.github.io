[{"title":"CMU15213：CSAPP 实验一：DataLab","url":"/2017/10/16/cmu15213-datalab/","content":"# 实验内容\t\n《深入理解计算机系统》的第一个实验，内容包括位操作，用二进制表示整数，浮点数，以及相应的操作。实验限定了可选用的操作符，并且有最大次数限制，总体来讲还是非常有趣的。\n\n## bitAnd\n只使用 ~ 和 | 实现 &\n\nDe Morgan定律\n\n```\n/* \n * bitAnd - x&y using only ~ and | \n *   Example: bitAnd(6, 5) = 4\n *   Legal ops: ~ |\n *   Max ops: 8\n *   Rating: 1\n */\nint bitAnd(int x, int y) {\n  return ~(~x | ~y);\n}\n\n```\n\n## getByte\n从一个整数（4字节）中提取第0，1，2，3个字节。每个字节8bits，所以通过右移8*n位，然后取最后8位bits\n\n```\n/* \n * getByte - Extract byte n from word x\n *   Bytes numbered from 0 (LSB) to 3 (MSB)\n *   Examples: getByte(0x12345678,1) = 0x56\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 6\n *   Rating: 2\n */\nint getByte(int x, int n) {\n  return x>>(n<<3) & 0xFF;\n}\n```\n\n## logicalShift\n将一个数逻辑右移，当x为负数时，代码实际上进行的是算术右移，所以要将右移的1改为0\n\n最高位右移之后的位置为：32-n，所以将-1[1..1]左移动31-n位，得到[1..10..0]。取反之后再&算术右移的数即可。\n\n但由于不能使用-，使用-n=~n+1. 32-n= 32+~n+1。并且使得每次移位的范围在[0,31]之间，分成两次移位。\n\n```\n/* \n * logicalShift - shift x to the right by n, using a logical shift\n *   Can assume that 0 <= n <= 31\n *   Examples: logicalShift(0x87654321,4) = 0x08765432\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 20\n *   Rating: 3 \n */\nint logicalShift(int x, int n) {\n  int tmp = (~0)<<(32 + (~n));\n  tmp = tmp << 1;\n  return x>>n & (~tmp);\n}\n```\n\n## bitCount\n计算二进制中bit为1的个数，由于不能使用循环等操作，这道题难度很大。可以采用一种分治的思想解决。\n\n![](http://siofive.qiniudn.com/datalab-bitCount.jpg)\n\n为了能够将对应位上的数字相加，需要产生5个mask，分别是0x55555555, 0x33333333, 0x0f0f0f0f, 0x00ff00ff, 0x0000ffff。 分别代表了[1,2,4,8,16]个0和1间隔。\n\n```\n/*\n * bitCount - returns count of number of 1's in word\n *   Examples: bitCount(5) = 2, bitCount(7) = 3\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 40\n *   Rating: 4\n */\nint bitCount(int x) {\n  int _mask1 = 0x55 | (0x55 << 8);   //  0x5555\n  int _mask2 = 0x33 | (0x33 << 8);   //  0x3333\n  int _mask3 = 0x0f | (0x0f << 8);   //  0x0f0f\n\n  int mask1 = _mask1 | (_mask1 << 16);  //  0x55555555 = [0101...0101]\n  int mask2 = _mask2 | (_mask2 << 16);  //  0x33333333 = [0011...0011]\n  int mask3 = _mask3 | (_mask3 << 16);  //  0x0f0f0f0f = [00001111...00001111]\n  int mask4 = 0xff | (0xff << 16);      //  0x00ff00ff = [00000000111111110000000011111111]\n  int mask5 = 0xff | (0xff << 8);       //  0x0000ffff = [00000000000000001111111111111111]\n  \n  x = (x & mask1) + ((x >> 1) & mask1);\n  x = (x & mask2) + ((x >> 2) & mask2);\n  x = (x & mask3) + ((x >> 4) & mask3);\n  x = (x & mask4) + ((x >> 8) & mask4);\n  x = (x & mask5) + ((x >> 16) & mask5);\n  return x;\n}\n```\n\n## bang\n计算!x，但不能使用！\n\n只用当x为0时，!x=1, 观察得到只有0和-0的最高位都不为1，其它的都至少有一个1（tmin有两个，-tmin=tmin）。\n\n```\n/* \n * bang - Compute !x without using !\n *   Examples: bang(3) = 0, bang(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4 \n */\nint bang(int x) {\n  return ((~(x|(~x+1)))>>31) & 1;\n}\n```\n\n## tmin\n计算tmin，直接1<<31即可\n\n```\n/* \n * tmin - return minimum two's complement integer \n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n  return 1<<31;\n}\n```\n\n## fitsBits\n这题关键点是理解题意。如果x能够被表示成n-bit的补码，则返回1. 其实问的是，用一个长度为n-bit的二进制表示补码，对应范围为[n-tmin, n-tmax]，问x是否在该范围内。\n\n观察n-bit能够表示的范围，如果将这个数右移n-1位，如果x为正，此时x全为0，如果x为负，那么x全为1（为-1）。再将x+1之后再右移1位，此时x应该全为0.\n\n```\n/* \n * fitsBits - return 1 if x can be represented as an \n *  n-bit, two's complement integer.\n *   1 <= n <= 32\n *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint fitsBits(int x, int n) {\n  x = (x>>(n + ~0)) + 1;\n  return !(x>>1);\n}\n```\n\n## divpwr2\n计算x/(2^n), 并且向零取整\n\n- 当x为整数的时候，直接右移n为即可。\n- 当x为负数的时候，由于要向上取整，所以需要加上偏移量。ans = (x+(1<<k)-1)>>k\n\n所以这道题的关键是先判断是否为负数，若是，加上对应的偏移量。\n\n```\n/* \n * divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n *  Round toward zero\n *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint divpwr2(int x, int n) {\n    int s = (x >> 31) & 1;\n    return (x + (s<<n) + ~s + 1) >> n;\n}\n```\n\n## negate\n计算-x。-x=~x+1\n \n```\n/* \n * negate - return -x \n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n  return ~x + 1;\n}\n```\n\n## isPositive\n如果x>0, 返回1。否则返回0\n\n这道题咋一看很简单，只需要判断最高位。但是0并不是一个正数，所以需要特殊处理。\n\n- x为0，!x=1, ~x的最高位为1，相减得0\n- x为整数，!x=0, ~x的最高位为1，相减得1\n- x为负数，!x=0, ~x的最高位为0，相减得0\n\n```\n/* \n * isPositive - return 1 if x > 0, return 0 otherwise \n *   Example: isPositive(-1) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 8\n *   Rating: 3\n */\nint isPositive(int x) {\n  int z = !x;\n  return (((~x)>>31) & 1) + (~z + 1);\n}\n```\n\n## isLessOrEqual\n判断 x<=y\n如果直接用y-x，会溢出。所以这题需要先判断x和y的两者符号是否相同。不同的情况很好处理，如果相同，两者相减并不会发生溢出，再判断即可。\n\n如果两者相同，x-y<=0, x-y-1<=-1, 即x+~y+1-1<=-1。\n\n```\n/* \n * isLessOrEqual - if x <= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n  int sx = (x>>31) & 1;\n  int sy = (y>>31) & 1;\n  int sign_diff = sx & !sy;\n  int sign_same = !(sx^sy) & (((x+~y)>>31) & 1);\n  return sign_diff | sign_same;\n}\n```\n\n## ilog2\nilog2(16)=4\n\n本质上就是求x的最高位1的位置，可以使用上面bitCount中分治法的思想。ilog2(x)的最大值为31，可以表示为 $ilog2(x) = 16* a+8* b+4* c+2* d+1* e$。其中a,b,c,d,e为0或1。\n\n```\n/*\n * ilog2 - return floor(log base 2 of x), where x > 0\n *   Example: ilog2(16) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 90\n *   Rating: 4\n */\nint ilog2(int x) {\n  // max(x) = 31\n  // x can be replace by : x = 16*a+8*b+4*c+2*d+1*e\n  int ans = 0;\n  ans += (!!(x>>16)) << 4;\n  ans += (!!(x>>(8+ans))) << 3;\n  ans += (!!(x>>(4+ans))) << 2;\n  ans += (!!(x>>(2+ans))) << 1;\n  ans += (!!(x>>(1+ans))) << 0;\n  return ans;\n}\n```\n\n## float_neg\n用unsigned x表示float，并返回-x\n\n先判断uf是否为NaN，如果是，返回NaN，如果不是的话，返回-uf即可。当浮点数中阶数全为1，而尾数不为0时，表示该数为NaN。\n\n```\n/* \n * float_neg - Return bit-level equivalent of expression -f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representations of\n *   single-precision floating point values.\n *   When argument is NaN, return argument.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 10\n *   Rating: 2\n */\nunsigned float_neg(unsigned uf) {\n  unsigned t = uf & 0x7fffffff;\n  if (t > 0x7f800000) return uf;\n  return uf ^ 0x80000000;\n}\n```\n\n## float_i2f\n将一个int数转化为float\n\nx=(s<<31) | (exponent<<23) | fraction\n\n先得到符号位，然后如果x=0，或者x=-tmin，直接返回相应的float。如果x为负数，转化为整数考虑。再分别计算该数的exponent和fraction，在计算fraction的时候需要注意向偶数进位，并且进位之后exponent是否需要改变。具体的细节见代码注释\n\n```\n/* \n * float_i2f - Return bit-level equivalent of expression (float) x\n *   Result is returned as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point values.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_i2f(int x) {\n  // return (s<<31)|(exponent<<23)|fraction\n  int s = (x>>31) & 1;  //sign\n  int exponent;\n  int fraction = 0;\n  int fraction_mask;\n  int delta;\n  int i = 30;\n  if (x == 0) return x;   //x=0\n  else if (x == 0x80000000) { //x=-tmin, exponent = 31 + 127\n    exponent = 158;\n  } else {\n    if (s) x = -x;  //if x is negative, change to positive\n    while(!(x>>i)) i--; //right shift until x=0\n    exponent = i + 127;\n    x = x << (31 - i);  //clean zeros in higher bits\n    fraction_mask = 0x7fffff;\n    fraction = fraction_mask & (x >> 8); //get fraction\n    x = x & 0xff; //the lower 8 bits will be truncated\n    delta = (x > 128) || ((x == 128) && (fraction & 1)); //if x>=odd.5, delta = 1\n    fraction += delta;\n    if (fraction >> 23) { //if fraction is larger than 23 bits\n      exponent += 1;\n      fraction &= fraction_mask;\n    }\n  }\n  return (s<<31) | (exponent<<23) | fraction;\n}\n```\n\n## float_twice\n将给定的unsigned uf表示的float * 2\n\n如果uf是denormalized，uf的二进制左移1就是该数乘2。如果uf * 2还是denormalized，好理解。如果uf * 2变成了normalized，阶码变为1，尾数变为0.也成立。\n\n如果uf是normalized，直接将uf的阶码+1，但如果uf的阶码+1之后全为1，就变成了inf，需要将尾数全部置为0.\n\n如果uf是NaN或者inf，直接返回uf。\n\n```\n/* \n * float_twice - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_twice(unsigned uf) {\n  if ((uf & 0x7f800000) == 0) { //denormalized\n    return (uf & 0x80000000) | (uf << 1);\n  } else if ((uf & 0x7f800000) != 0x7f800000) {  //normalized\n    uf += (1 << 23);\n    if ((uf & 0x7f800000) == 0x7f800000) uf = uf >> 23 << 23;\n    return uf;\n  } else return uf;   // NaN or inf \n}\n```\n\n整个实验内容让我更深入的理解计算机如何用二进制表示整数和浮点数，收获很大。可以配套CMU的网上课程学习该书，效果会更好。\n","tags":["浮点数表示"],"categories":["深入理解计算机系统"]},{"title":"HDU5157 Harry and magic string（Manacher+差分前缀）","url":"/2015/11/04/HDU5157/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5157\n\n# 题意\n有一个字符串s，问有多少对子串对(suba, subb)，使得suba和subb均为回文子串，且两个子串不能有重叠部分。\n\n# 思路\n首先可以用Manacher算法预处理出以每个字符（包括两个字符之间的位置）为中心能有多少个回文串。然后用差分前缀处理处pre、suf、sum三个数组。\n其中pre数组表示到以某个字符结尾的回文串个数，suf表示以某个字符为开头的回文串个数，sum表示以某个字符之后的所有字符为开头的回文串个数。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 210000;\nchar s[N], str[N];\nint n, p[N];\nvoid KP(int len, char *str) {\n    for (int i = 0; i < len; i++) {\n        s[2 * i + 1] = '#';\n        s[2 * i + 2] = str[i];\n    }\n    int n = 2 * len;\n    s[0] = s[n + 1] = '#';\n    s[n + 2] = 0;\n    int mx = 0, id;\n    for (int i = 1; i <= n; i++) {\n        if (mx > i) p[i] = min(p[2 * id - i], mx - i);\n        else p[i] = 1;\n        while(s[i + p[i]] == s[i - p[i]]) p[i]++;\n        if (p[i] + i > mx) {\n            mx = p[i] + i;\n            id = i;\n        }\n    }\n}\nll pre[N / 2], suf[N / 2], sum[N / 2];\nint main () {\n    while(~scanf(\"%s\", str)) {\n        int len = strlen(str);\n        KP(len, str);\n        for (int i = 0; i <= len + 1; i++) pre[i] = suf[i] = sum[i] = 0;\n        for (int i = 2; i <= 2 * len; i++) {\n            int x = i / 2;\n            if (i % 2 == 0) pre[x]++, pre[x + (p[i] / 2)]--;\n            else pre[x + 1]++, pre[x + (p[i] / 2) + 1]--;\n        }\n        for (int i = 2 * len; i >= 2; i--) {\n            int x = i / 2;\n            if (i % 2 == 0) suf[x]++, suf[x - (p[i] / 2)]--;\n            else suf[x]++, suf[x - (p[i] / 2)]--;\n        }\n        for (int i = len; i >= 1; i--) {\n            suf[i] += suf[i + 1];\n            sum[i] += sum[i + 1] + suf[i];\n        }\n\n        ll ans = 0;\n        for (int i = 1; i <= len; i++) {\n            pre[i] += pre[i - 1];\n            ans += (ll)pre[i] * (sum[i + 1]);\n        }\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n\n```","tags":["差分前缀"],"categories":["ACM"]},{"title":"HDU5156 Harry and Christmas tree（dfs序+查询区间内有多少个数）","url":"/2015/10/29/HDU5156/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5156\n\n# 题意\n有一颗树，每个节点上有一些颜色的礼物，现在问以每个节点为根的子树有多少种不同的颜色。\n\n# 思路\n先把每个节点相同的颜色去除，然后按照dfs序得到一个关于颜色的序列。问题就转化为查询若干个区间内有多少种不同的颜色。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 50000 + 10;\nconst int M = 500000 + 10;\nvector<int> g[N], gift[N];\nint st[N], ed[N], pos[N], ans[N], mp[2 * N], seq[M], s[M], nxt[M];\nint tot, n, m;\nbool cmp1(int a, int b) { ///按左区间从小到大排\n    return st[a] < st[b];\n}\nbool cmp(int a, int b) { ///按有区间从小到大排\n    return ed[a] < ed[b];\n}\nint lowbit(int x) {\n    return x & -x;\n}\nvoid add(int p, int v) {\n    while(p <= tot) {\n        s[p] += v;\n        p += lowbit(p);\n    }\n}\nint sum(int p) {\n    int res = 0;\n    while(p > 0) {\n        res += s[p];\n        p -= lowbit(p);\n    }\n    return res;\n}\nvoid dfs(int u, int fa) {\n    st[u] = tot + 1;\n    for (int i = 0; i < gift[u].size(); i++) seq[++tot] = gift[u][i];\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (v != fa) dfs(v, u);\n    }\n    ed[u] = tot;\n}\nvoid init() {\n    tot = 0;\n    for (int i = 1; i <= n; i++) {\n        g[i].clear();\n        gift[i].clear();\n        pos[i] = i;\n    }\n}\nint main () {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        init();\n        int u, v;\n        for (int i = 1; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            g[u].pb(v);\n            g[v].pb(u);\n        }\n        int mx = 0;\n        while(m--) {\n            scanf(\"%d%d\", &u, &v);\n            if (find(gift[u].begin(), gift[u].end(), v) == gift[u].end()) gift[u].pb(v);\n            mx = max(mx, v);\n        }\n        dfs(1, -1);\n        memset(s, 0, sizeof(int) * (tot + 5));\n        memset(mp, 0, sizeof(int) * (mx + 5));\n        ///按右区间从小到大排\n        sort(pos + 1, pos + n + 1, cmp);\n        for(int i = 1; i <= tot; i++) {\n            if(!mp[seq[i]]) {\n                add(i, 1);\n                mp[seq[i]] = i; ///如果是第一次出现, mp[seq[i]]记录为当前位置\n            }\n        }\n        int right = 1;\n        for(int i = 1; i <= n; i++) {\n            int now = pos[i];\n            while(right <= ed[now]) {\n                if(mp[seq[right]] != right) { ///如果不是第一次出现\n                    add(mp[seq[right]], -1);  ///减去前一次出现的\n                    add(right, 1);\n                    mp[seq[right]] = right;   ///重新定义这个数最近一次出现位置\n                }\n                right++;\n            }\n            ans[now] = sum(ed[now]) - sum(st[now] - 1);\n        }\n/*\n        ///按左区间从小到大排\n        for (int i = 1; i <= tot; i++) {\n            if (!mp[seq[i]]) {\n                mp[seq[i]] = i;\n                add(i, 1);\n            }\n        }\n        memset(mp, 0, sizeof(int) * (mx + 5));\n        for (int i = tot; i >= 1; i--) {\n            if (!mp[seq[i]]) nxt[i] = tot + 1;\n            else nxt[i] = mp[seq[i]];\n            mp[seq[i]] = i;\n        }\n        sort(pos + 1, pos + n + 1, cmp1);\n        int t = 1;\n        for (int i = 1; i <= n; i++) {\n            int now = pos[i];\n            while(t <= tot && t < st[now]) {\n                add(nxt[t++], 1);\n            }\n            //cout<<now<<\" \"<<st[now]<<\" \"<<ed[now]<<endl;\n            ans[now] = sum(ed[now]) - sum(st[now] - 1);\n        }\n*/\n        for (int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n    }\n    return 0;\n}\n```","tags":["dfs序"],"categories":["ACM"]},{"title":"ZOJ2112 Dynamic Rankings（动态区间第K大 树状数组套主席树）","url":"/2015/10/28/ZOJ2112/","content":"# 题目\t\n源地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112\n\n# 题意\n动态查询区间第K大数，带修改\n\n# 思路\nhttp://www.cnblogs.com/Empress/p/4659824.html\n需要将询问离线处理，将一开始的数列用主席树维护。之后修改的部分用N个树状数组来维护，每次更新logn棵树。\n时间复杂度：nlog^2n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 60000 + 10;\n#define lson l, m\n#define rson m + 1, r\nint a[N], Hash[N];\nint root[N], ln[N << 5], rn[N << 5], sum[N << 5];\nint S[N];\nint n, m, tot;\nstruct node {\n    int l, r, k;\n    bool Q;\n}op[10005];\nint build(int l, int r) {\n    int rt = ++tot;\n    sum[rt] = 0;\n    if (l != r) {\n        int m = l + r >> 1;\n        ln[rt] = build(lson);\n        rn[rt] = build(rson);\n    }\n    return rt;\n}\nint update(int pre, int l, int r, int x, int val) {\n    int rt = ++tot;\n    ln[rt] = ln[pre], rn[rt] = rn[pre], sum[rt] = sum[pre] + val;\n    if (l < r) {\n        int m = l + r >> 1;\n        if (x <= m) ln[rt] = update(ln[pre], lson, x, val);\n        else rn[rt] = update(rn[pre], rson, x, val);\n    }\n    return rt;\n}\nint lowbit(int x) {\n    return x & -x;\n}\nint use[N];\nvoid add(int x, int pos, int val) {\n    while(x <= n) {\n        S[x] = update(S[x], 1, m, pos, val);\n        x += lowbit(x);\n    }\n}\nint get_sum(int x) {\n    int ret = 0;\n    while(x) {\n        ret += sum[ln[use[x]]];\n        x -= lowbit(x);\n    }\n    return ret;\n}\nint query(int u, int v, int lr, int rr, int l, int r, int k) {\n    if (l >= r) return l;\n    int m = l + r >> 1;\n    int tmp = get_sum(v) - get_sum(u) + sum[ln[rr]] - sum[ln[lr]];\n    if (tmp >= k) {\n        for (int i = u; i; i -= lowbit(i)) use[i] = ln[use[i]];\n        for (int i = v; i; i -= lowbit(i)) use[i] = ln[use[i]];\n        return query(u, v, ln[lr], ln[rr], lson, k);\n    } else {\n        for (int i = u; i; i -= lowbit(i)) use[i] = rn[use[i]];\n        for (int i = v; i; i -= lowbit(i)) use[i] = rn[use[i]];\n        return query(u, v, rn[lr], rn[rr], rson, k - tmp);\n    }\n}\nvoid modify(int x, int p, int d) {\n    while(x <= n) {\n        S[x] = update(S[x], 1, m, p, d);\n        x += lowbit(x);\n    }\n}\nint main () {\n    int t, q;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &q);\n        m = tot = 0;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", a + i);\n            Hash[++m] = a[i];\n        }\n        char s[10];\n        for (int i = 0; i < q; i++) {\n            scanf(\"%s\", s);\n            if (s[0] == 'Q') {\n                scanf(\"%d%d%d\", &op[i].l, &op[i].r, &op[i].k);\n                op[i].Q = 1;\n            } else {\n                scanf(\"%d%d\", &op[i].l, &op[i].r);\n                op[i].Q = 0;\n                Hash[++m] = op[i].r;\n            }\n        }\n        sort(Hash + 1, Hash + m + 1);\n        m = unique(Hash + 1, Hash + m + 1) - Hash - 1;\n        root[0] = build(1, m);\n        for (int i = 1; i <= n; i++) root[i] = update(root[i - 1], 1, m, lower_bound(Hash + 1, Hash + m + 1, a[i]) - Hash, 1);\n        for (int i = 1; i <= n; i++) S[i] = root[0];\n        for (int i = 0; i < q; i++) {\n            if (op[i].Q) {\n                for (int j = op[i].l - 1; j; j -= lowbit(j)) use[j] = S[j];\n                for (int j = op[i].r; j; j -= lowbit(j)) use[j] = S[j];\n                printf(\"%d\\n\", Hash[query(op[i].l - 1, op[i].r, root[op[i].l - 1], root[op[i].r], 1, m, op[i].k)]);\n            } else {\n                modify(op[i].l, lower_bound(Hash + 1, Hash + m + 1, a[op[i].l]) - Hash, -1);\n                modify(op[i].l, lower_bound(Hash + 1, Hash + m + 1, op[i].r) - Hash, 1);\n                a[op[i].l] = op[i].r;\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["主席树"],"categories":["ACM"]},{"title":"POJ2104 K-th Number（静态区间第K大 主席树）","url":"/2015/10/22/POJ2104/","content":"# 题目\t\n源地址：http://poj.org/problem?id=2104\n\n# 题意\n静态查询区间第K大数\n\n# 思路\nhttp://www.cnblogs.com/Empress/p/4652449.html\n主席数利用函数式线段树来维护数列，即每一个前缀维护一个线段树。再利用两个相邻的线段树只需要修改log级别，所以空间也能开下。一般用来解决区间第k大问题\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\n#define lson l, m\n#define rson m + 1, r\nconst int N = 1e5 + 5;\nint ln[N << 5], rn[N << 5], sum[N << 5];\nint tot;\nint a[N], root[N], b[N];\nint build(int l, int r) {\n    int rt = ++tot;\n    sum[rt] = 0;\n    if (l < r) {\n        int m = l + r >> 1;\n        ln[rt] = build(lson);\n        rn[rt] = build(rson);\n    }\n    return rt;\n}\nint update(int pre, int l, int r, int x) {\n    int rt = ++tot;\n    ln[rt] = ln[pre], rn[rt] = rn[pre], sum[rt] = sum[pre] + 1;\n    if (l < r) {\n        int m = l + r >> 1;\n        if (x <= m) ln[rt] = update(ln[pre], lson, x);\n        else rn[rt] = update(rn[pre], rson, x);\n    }\n    return rt;\n}\nint query(int u, int v, int l, int r, int k) {\n    if (l >= r) return l;\n    int m = l + r >> 1;\n    int num = sum[ln[v]] - sum[ln[u]];\n    if (num >= k) return query(ln[u], ln[v], lson, k);\n    else return query(rn[u], rn[v], rson, k - num);\n}\nint main () {\n    tot = 0;\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", a + i), b[i] = a[i];\n    sort(b + 1, b + n + 1);\n    int cnt = unique(b + 1, b + n + 1) - b - 1;\n    root[0] = build(1, cnt);\n    for (int i = 1; i <= n; i++) {\n        int x = lower_bound(b + 1, b + n + 1, a[i]) - b;\n        root[i] = update(root[i - 1], 1, cnt, x);\n    }\n    while(m--) {\n        int l, r, k;\n        scanf(\"%d%d%d\", &l, &r, &k);\n        int x = query(root[l - 1], root[r], 1, cnt, k);\n        printf(\"%d\\n\", b[x]);\n    }\n    return 0;\n}\n```","tags":["主席树"],"categories":["ACM"]},{"title":"SPOJ DQUERY - D-query（查询区间内有几个数 离线树状数组OR在线主席树）","url":"/2015/10/22/SPOJ-DQUERY/","content":"# 题目\t\n源地址：http://www.spoj.com/problems/DQUERY/en/\n\n# 题意\n查询区间内有几个不同的数\n\n# 思路\nhttp://blog.csdn.net/acm_cxlove/article/details/8562634\n\n1. 离线树状数组\n将查询区间按左端点排序\n对于相同的数，先更新最左边的位置\n然后根据查询区间，不断更新next，保证查询区间内只记录一个位置\n维护前缀和用树状数组，时空效率都高\n\n2. 在线主席树\nhttp://www.cnblogs.com/Empress/p/4675386.html\n将重复的元素建树。在query的时候把区间内重复的数加起来，用区间长度(r-l+1)去减就是答案\n(query的是[l, r]之间重复元素的个数)\n举个例子：1 1 2 1 3 2 3\n我们从左到右枚举，如果没有重复的，那么树的形态和之前一样，出现重复的则在重复的位置加1，建一颗新树\n这样我们需要建7颗数\n    1 2 3 4 5 6 7\nT0:\nT1:\nT2: 1\nT3: 1\nT4: 1 1\nT5: 1 1\nT6: 1 1 1\nT7: 1 1 1  1\n例如查询区间[2，5] 就需要用T5-T1，但是不能直接减，直接减重复的数为2个1。需要统计的是区间[2,5]内重复的个数，正好为1个1.\n\n<!--more-->\n\n# 代码\n离线树状数组\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<map>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 30000 + 100;\nconst int M = 200000 + 100;\nint a[N], s[N], n, nxt[N];\nstruct node {\n    int l, r, id;\n    bool operator < (const node & T) const {\n        return l < T.l;\n    }\n} Q[M];\nint ans[M];\nint lowbit(int x) {\n    return x & -x;\n}\nvoid add(int p, int v) {\n    while(p <= n) {\n        s[p] += v;\n        p += lowbit(p);\n    }\n}\nint sum(int p) {\n    int res = 0;\n    while(p > 0) {\n        res += s[p];\n        p -= lowbit(p);\n    }\n    return res;\n}\nmap<int, int> mp;\nint main () {\n    while(~scanf(\"%d\", &n)) {\n        mp.clear();\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", a + i);\n            if (!mp.count(a[i])) {\n                mp[a[i]] = i;\n                add(i, 1);\n            }\n        }\n        mp.clear();\n        for (int i = n; i >= 1; i--) {\n            if (!mp.count(a[i])) nxt[i] = n + 1;\n            else nxt[i] = mp[a[i]];\n            mp[a[i]] = i;\n        }\n        int q;\n        scanf(\"%d\", &q);\n        for (int i = 0; i < q; i++) {\n            scanf(\"%d%d\", &Q[i].l, &Q[i].r);\n            Q[i].id = i;\n        }\n        sort(Q, Q + q);\n        int t = 1;\n        for (int i = 0; i < q; i++) {\n            while(t <= n && t < Q[i].l) {\n                add(nxt[t++], 1);\n            }\n            ans[Q[i].id] = sum(Q[i].r) - sum(Q[i].l - 1);\n        }\n        for (int i = 0; i < q; i++) printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n```\n\n在线主席树\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<map>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\ntypedef long long LL;\n#define lson l, m\n#define rson m + 1, r\nconst int N = 30000 + 10;\nint ln[N << 5], rn[N << 5], sum[N << 5];\nint tot, root[N], a[N];\nmap<int, int> mp;\nint build(int l, int r) {\n    int rt = ++tot;\n    sum[rt] = 0;\n    if (l < r) {\n        int m = l + r >> 1;\n        ln[rt] = build(lson);\n        rn[rt] = build(rson);\n    }\n    return rt;\n}\nint update(int pre, int l, int r, int x) {\n    int rt = ++tot;\n    ln[rt] = ln[pre], rn[rt] = rn[pre], sum[rt] = sum[pre] + 1;\n    if (l < r) {\n        int m = l + r >> 1;\n        if (x <= m) ln[rt] = update(ln[pre], lson, x);\n        else rn[rt] = update(rn[pre], rson, x);\n    }\n    return rt;\n}\nint query(int u, int v, int l, int r, int k) {\n    if (l >= k) return sum[v] - sum[u];\n    int ans = 0;\n    int m = l + r >> 1;\n    if (k <= m) ans += query(ln[u], ln[v], lson, k);\n    ans += query(rn[u], rn[v], rson, k);\n    return ans;\n}\nint main () {\n    int n, m;\n    tot = 0;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n    root[0] = build(1, n);\n    for (int i = 1; i <= n; i++) {\n        if (mp.find(a[i]) != mp.end()) root[i] = update(root[i - 1], 1, n, mp[a[i]]);\n        else root[i] = root[i - 1];\n        mp[a[i]] = i;\n    }\n    scanf(\"%d\", &m);\n    int l, r;\n    while(m--) {\n        scanf(\"%d%d\", &l, &r);\n        printf(\"%d\\n\", r - l + 1 - query(root[l - 1], root[r], 1, n, l));\n    }\n    return 0;\n}\n\n```","tags":["主席树"],"categories":["ACM"]},{"title":"HDU 5152 A Strange Problem（线段树+数论）","url":"/2015/10/13/hdu5152/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5152\n\n# 题意\n某天你收到了一个信封，信封里是一个奇怪的题目。首先给你一个长度为N的序列，序列为A1,A2,...,AN.然后有M个操作，每个操作为以下三种操作的其中一个：\n1. 输出操作。给你l,r，输出区间和。\n2. 修改操作。给你x，把Ax修改为2^Ax\n3. 加法操作。给你l,r,x，区间加上​​x\n由于输出操作的结果可能很大，输出结果对2333333取模。\n\n# 思路\n这道题复杂就是操作2。需要补充一个知识\n指数循环节：当x >= Phi(C)时, A^x = A ^ (x%Phi(C) + Phi(C)) (mod C). Phi(C)是C的欧拉函数，\n对于2333333这个模数来说，求18次欧拉函数后就变成了1，所以只需要保存19层第三次操作的加数即可，然后就直接是线段树区间更新和询问操作了\n参考题解写的代码，主要是计算操作二的时候，用一个vector记录某一位置操作二的个数，其实只需要记录最后的19个操作即可。具体细节见代码\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define lson l, m, rt << 1\n#define rson m+1, r, rt << 1 | 1\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int mod = 2333333;\nconst int N = 50005;\nint mo[20] = {2333333, 2196720, 580608, 165888, 55296, 18432, 6144, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\nint pow2[33];\nvector<ll> vt[N];\nll mark[N << 2];\nint len[N << 2], sum[N << 2];\nint n, m;\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= mod) x -= mod;\n}\nvoid up(int rt) {\n    sum[rt]  = sum[rt << 1] + sum[rt << 1 | 1];\n    add(sum[rt], 0);\n}\nvoid down(int rt) {\n    if (mark[rt]) {\n        mark[rt << 1] += mark[rt];\n        mark[rt << 1 | 1] += mark[rt];\n        add(sum[rt << 1], 1LL * len[rt << 1] * mark[rt] % mod);\n        add(sum[rt << 1 | 1], 1LL * len[rt << 1 | 1] * mark[rt] % mod);\n        mark[rt] = 0;\n    }\n}\nvoid build(int l, int r, int rt) {\n    mark[rt] = 0;\n    len[rt] = r - l + 1;\n    if (l == r) {\n        int x;\n        scanf(\"%d\", &x);\n        vt[l].clear();\n        vt[l].pb(x);\n        sum[rt] = x % mod;\n        return ;\n    }\n    int m = l + r >> 1;\n    build(lson);\n    build(rson);\n    up(rt);\n}\nint query(int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) return sum[rt];\n    down(rt);\n    int m = l + r >> 1, ret = 0;\n    if (L <= m) add(ret, query(L, R, lson));\n    if (R > m) add(ret, query(L, R, rson));\n    up(rt);\n    return ret;\n}\nvoid update(int L, int R, int v, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        mark[rt] += v;\n        add(sum[rt], 1LL * len[rt] * v % mod);\n        return ;\n    }\n    down(rt);\n    int m = l + r >> 1;\n    if (L <= m) update(L, R, v, lson);\n    if (R > m) update(L, R, v, rson);\n    up(rt);\n}\nint pow_mod(int x, int n, int mod) {\n    int ret = 1;\n    while(n) {\n        if (n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint cal(vector<ll> &v) {\n    if (v.size() < 19) {\n        int pos = v.size() - 1;\n        ll ret = v[0];\n        bool flag = false;\n        if (v[0] >= mo[pos]) {\n            flag = true;\n            ret = ret % mo[pos] + mo[pos];\n        }\n        pos--;\n        for (int i = 1; i < v.size(); i++) {\n            if (flag) {\n                ret = (pow_mod(2, ret, mo[pos]) + v[i]) % mo[pos] + mo[pos];\n            } else {\n                if (ret >= 30 || pow2[ret] >= mo[pos]) {\n                    flag = true;\n                    ret = (pow_mod(2, ret, mo[pos]) + v[i]) % mo[pos] + mo[pos];\n                } else {\n                    ret = pow2[ret] + v[i];\n                    if (ret >= mo[pos]) {\n                        flag = true;\n                        ret = ret % mo[pos] + mo[pos];\n                    }\n                }\n            }\n            pos--;\n        }\n        return ret % mod;\n    } else {\n        ll ret = 1;\n        int pos = 17;\n        for (int i = v.size() - 18; i < v.size(); i++) {\n            ret = (pow_mod(2, ret, mo[pos]) + v[i]) % mo[pos] + mo[pos];\n            pos--;\n        }\n        return ret % mod;\n    }\n}\nvoid modify(int x, int l, int r, int rt) {\n    if (l == r) {\n        if (mark[rt]) {\n            vt[l][vt[l].size() - 1] += mark[rt];\n            mark[rt] = 0;\n        }\n        vt[l].pb(0);\n        sum[rt] = cal(vt[l]);\n        return ;\n    }\n    down(rt);\n    int m = l + r >> 1;\n    if (x <= m) modify(x, lson);\n    else modify(x, rson);\n    up(rt);\n}\nint main () {\n    pow2[0] = 1;\n    for (int i = 1; i <= 30; i++) pow2[i] = pow2[i - 1] << 1;\n    int op, l, r, x;\n    while(~scanf(\"%d%d\", &n, &m)) {\n        build(1, n, 1);\n        while(m--) {\n            scanf(\"%d\", &op);\n            if (op == 1) {\n                scanf(\"%d%d\", &l, &r);\n                printf(\"%d\\n\", query(l, r, 1, n, 1));\n            }else if (op == 2) {\n                scanf(\"%d\", &x);\n                modify(x, 1, n, 1);\n            } else {\n                scanf(\"%d%d%d\", &l, &r, &x);\n                update(l, r, x, 1, n, 1);\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["数论"],"categories":["ACM"]},{"title":"HDU 5151 Sit sit sit（区间dp）","url":"/2015/10/13/hdu5151/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5151\n\n# 题意\n有n个人陆续坐到n个椅子上，每张椅子为两种颜色中的一种。每个人每次可以选择一个空位置，如果该空位置两边都有人，且两边的椅子颜色不同，那么他便不能坐下，需要离开。现在问n个人全部坐下的方案数\n\n# 思路\ndp[i][j]表示编号i-j的位置上都有人坐下的方案数。dp[i][i] = 1, dp[i][i+1] = 2 \ndp[i][j] =sum(dp[i][k-1] * dp[k+1][j] * C(j-i, k-i-1)) 当i-k-1有人坐下，k+1-j有人坐下，此时来的人坐在k的方案数累积\nC(j-i, k-i-1)表示前面的j-i个人有k-i-1个人选择坐在了左边的方案数\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int CN = 111;\nconst int mod = 1000000007;\nll c[CN][CN]= {};\nvoid cinit() {\n    for(int i = 0; i <= 100; i++) {\n        c[i][0] = c[i][i] = 1;\n        for(int j = 1; j < i; j++) {\n            c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n            if (c[i][j] > mod) c[i][j] -= mod;\n        }\n    }\n}\nll dp[CN][CN];\nint n, a[CN];\nint main () {\n    cinit();\n    while(~scanf(\"%d\", &n)) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", a + i);\n            dp[i][i] = 1;\n            dp[i][i + 1] = 2;\n        }\n        for (int l = 3; l <= n; l++) {\n            for (int i = 0; i + l <= n; i++) {\n                int j = i + l - 1;\n                dp[i][j] = 0;\n                //head\n                dp[i][j] += dp[i + 1][j];\n                //mid\n                for (int k = i + 1; k <= j - 1; k++) if (a[k - 1] == a[k + 1]) {\n                    dp[i][j] += c[l - 1][k - i] * dp[i][k - 1] % mod * dp[k + 1][j] % mod;\n                    dp[i][j] %= mod;\n                }\n                //tail\n                dp[i][j] += dp[i][j - 1];\n                dp[i][j] %= mod;\n            }\n        }\n        printf(\"%I64d\\n\", dp[0][n - 1]);\n    }\n    return 0;\n}\n```\n","tags":["区间dp"],"categories":["ACM"]},{"title":"HDU 5085 Counting problem（暴力+HashTable）","url":"/2015/10/11/hdu5085/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5085\n\n# 题意\n定义f(n,k) = 各位数字的k次方和。例如f(305, 2) = 5^2 + 0^2 + 3^2 = 34\n给定a,b,k,s。求[a,b]区间内满足f(n,k)=s的数字个数\n1≤a≤b≤999999999;\t1≤k≤15;\t1≤S≤10^16\n\n# 思路\n把n分为按照长度分为两半部分，前半部分暴力枚举，后半部分加入hash表中，这样将复杂度降到sqrt(n)hash表中记录每种和的情况数。要注意一些细节：\n1. 不妨设一个B=10000，如果a,b都小于B。直接枚举即可\n2. 当b大于B时，ahead = (a-1) / B, atail = a % B   bhead = b / B, btail = b % B\n将0~B-1的数字加入hash表时，记录一下以ahead开头符合条件的个数resa，再记录一下以bhead开头的符合条件的resb\n之后枚举[ahead, bhead), 符合条件的累加到resb中，最后答案即为resb-resa\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\n//Hash Table\n#define pii pair<ll, ll>\n#define fi first\n#define se second\n#define MAXN 10010\n#define mod  40007\nstruct HashKey {\n    ll key;\n    int nxt, cnt;\n} e[MAXN];\nint link1[MAXN * 4], p, k;\nll s;\nvoid init() {\n    memset(link1, -1, sizeof(link1));\n    p = 0;\n}\nvoid add(ll key) {\n    e[p].key = key;\n    e[p].cnt = 1;\n    int modKey = key % mod;\n    if (modKey < 0) modKey += mod;\n    e[p].nxt = link1[modKey];\n    link1[modKey] = p++;\n}\nint Find(ll key) {\n    int modKey = key % mod;\n    if (modKey < 0) modKey += mod;\n    for (int i = link1[modKey]; i != -1; i = e[i].nxt) {\n        if (e[i].key == key) {\n            return i;\n        }\n    }\n    return -1;\n}\nll calc(int x) {\n    ll ans = 0, tmp = 1;\n    while(x) {\n        int t = x % 10;\n        x /= 10;\n        tmp = 1;\n        for (int i = 0; i < k; i++) tmp *= t;\n        ans += tmp;\n    }\n    if (ans > s) return -1;\n    return ans;\n}\nvoid solve(int x)  {\n    ll ans = calc(x);\n    if (ans > s || ans == -1) return ;\n    int k = Find(ans);\n    if (k == -1) add(ans);\n    else e[k].cnt++;\n}\nint work(int ahead) {\n    ll ans = calc(ahead);\n    if (ans == -1) return 0;\n    if (ans <= s) {\n        int x = Find(s - ans);\n        if (x != -1) return e[x].cnt;\n    }\n    return 0;\n}\nint main () {\n    ll a, b;\n    int B = 10000;\n    while(~scanf(\"%I64d%I64d%d%I64d\", &a, &b, &k, &s)) {\n        if (b < B) {\n            int res = 0;\n            for (int i = a; i <= b; i++) {\n                if (calc(i) == s) res++;\n            }\n            printf(\"%d\\n\", res);\n            continue;\n        }\n\n        init();\n        int bhead = b / B, btail = b % B;\n        int ahead = (a - 1) / B, atail = (a - 1) % B;\n        ll resa = 0, resb = 0;\n        if (atail < btail) {\n            for (int i = 0; i <= atail; i++) solve(i);\n            resa = work(ahead);\n            for (int i = atail + 1; i <= btail; i++) solve(i);\n            resb = work(bhead);\n            for (int i = btail + 1; i < B; i++) solve(i);\n        } else {\n            for (int i = 0; i <= btail; i++) solve(i);\n            resb = work(bhead);\n            for (int i = btail + 1; i <= atail; i++) solve(i);\n            resa = work(ahead);\n            for (int i = atail + 1; i < B; i++) solve(i);\n        }\n        for (int i = ahead; i < bhead; i++) resb += work(i);\n        printf(\"%I64d\\n\", resb - resa);\n    }\n    return 0;\n}\n```\n","tags":["HashTable"],"categories":["ACM"]},{"title":"HDU 5148 Cities（树dp）","url":"/2015/10/10/hdu5148/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5148\n\n# 题意\n给定一棵树，数的节点数为n。问从中选出K个点，使得这些点之间的距离和最小\n\n# 思路\n考虑每条边的贡献，一条边会把树分成两部分，若在其中一部分里选择了x个点，则这条边被统计的次数为x*(K-x)*2. 那么考虑dp[u][i]表示在u的子树中选择了i个点的最小代价，有转移dp[u][i] = min(dp[u][i-j]+ dp[v][j] + j*(K-j)*2*c)​​ \n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\n#define pii pair<int, int>\nusing namespace std;\ntypedef long long ll;\nconst int N = 2100;\nint K, n;\nvector< pii > g[N];\nll dp[N][55];\nvoid change(ll &x, ll v) {\n    if (x == -1 || x > v) x = v;\n}\nvoid dfs(int u, int fa) {\n    dp[u][1] = 0;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i].fi, c = g[u][i].se;\n        if (v == fa) continue;\n        dfs(v, u);\n        for (int j = K - 1; j >= 1; j--) {\n            if (dp[u][j] == -1) continue;\n            for (int k = 1; j + k <= K; k++) {\n                if (dp[v][k] == -1) continue;\n                change(dp[u][j + k], dp[u][j] + dp[v][k] + (ll)2 * k * (K - k) * c);\n            }\n        }\n    }\n}\nint main () {\n    int t, u, v, c;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &K);\n        for (int i = 1; i <= n; i++) {\n            g[i].clear();\n            for (int j = 0; j <= K; j++) dp[i][j] = -1;\n        }\n        for (int i = 1; i < n; i++) {\n            scanf(\"%d%d%d\", &u, &v, &c);\n            g[u].pb({v, c});\n            g[v].pb({u, c});\n        }\n        dfs(1, -1);\n        ll ans = dp[1][K];\n        for (int i = 2; i <= n; i++) if (dp[i][K] != -1) ans = min(ans, dp[i][K]);\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n\n```\n","tags":["树dp"],"categories":["ACM"]},{"title":"HDU 5183 Negative and Positive (NP)（HashTable）","url":"/2015/10/09/hdu5183/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5183\n\n# 题意\n给定n个数的序列（A0,A1,A2...,An-1) 规定NP-sum(i,j) = Ai - Ai+1 + Ai+2 + (-1)^(j-i)Aj\n现在给定一个K，问是否有一个NP-sum(i,j)=K\n1≤n≤1000000,−1000000000≤ai≤1000000000,−1000000000≤K≤1000000000\n\n# 思路\nsum[i]=a1−a2+a3...。手写一个哈希表来保存所有出现过的sum值,然后根据奇偶性分类判断在哈系表中是否存在对应的子序列满足题意\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\n//Hash Table\n#define MAXN 1001000\n#define mod  4000007\nstruct HashKey {\n    ll key;\n    int nxt, pos;\n}e[MAXN];\nint link1[MAXN * 4], p;\nvoid init() {\n    memset(link1, -1, sizeof(link1));\n    p = 0;\n}\nvoid add(ll key, int pos) {\n    e[p].key = key;\n    e[p].pos = pos & 1;\n    int modKey = key % mod;\n    if (modKey < 0) modKey += mod;\n    e[p].nxt = link1[modKey];\n    link1[modKey] = p++;\n}\nbool Find(ll key, int odd) {\n    int modKey = key % mod;\n    if (modKey < 0) modKey += mod;\n    for (int i = link1[modKey]; i != -1; i = e[i].nxt) {\n        if (e[i].key == key && e[i].pos == odd) return true;\n    }\n    return false;\n}\nint main () {\n    int T, n, k, x;\n    scanf(\"%d\", &T);\n    for (int cas = 1; cas <= T; cas++) {\n        scanf(\"%d%d\", &n, &k);\n        ll s = 0;\n        init();\n        add(s, 0);\n        bool ok = false;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &x);\n            if (i & 1) s += x;\n            else s -= x;\n            if (!ok) {\n                if (Find(s - k, 0)) ok = true;\n                if (Find(s + k, 1)) ok = true;\n                add(s, i);\n            }\n        }\n        printf(\"Case #%d: %s.\\n\", cas, ok ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n","tags":["HashTable"],"categories":["ACM"]},{"title":"HDU 5084 HeHe（矩阵+强行找规律）","url":"/2015/10/09/hdu5084/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5084\n\n# 题意\n给定一个矩阵，矩阵的形式如下：\nM = |tn,   tn+1, ..., t2*n-1|\n    |tn-1, tn,   ..., t2*n-2|\n    |.                      |\n    |t1,   t2,   ..., tn    |\n有Q组询问，每次询问A(x,y) 其中A = M * M\n\n# 思路\n由于n是1000级别的，所以常规的矩阵乘无法满足条件。\n观察发现ans[x][y]就是 a[y]*a[2*n-x] + .... + a[y+n-1]*a[n-x+1] 乘的这部分 a[i]*a[j] i+j是定值 所以 对于i+j等于某个数的，求个前缀和 最后每个值就O(1)得到了\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\ntypedef long long ll;\nusing namespace std;\nconst int N = 1010;\nll t[2 * N], f[3 * N][2 * N];\nint n;\nvoid init() {\n    for (int i = n + 1; i <= 3 * n - 1; i++) {\n        f[i][0] = 0;\n        for (int j = 1; j < 2 * n; j++) {\n            if (i > j && (i - j) <= 2 * n - 1) f[i][j] = t[j] * t[i - j] + f[i][j - 1];\n        }\n    }\n}\nint main () {\n    while(~scanf(\"%d\", &n)) {\n        for (int i = 1; i < 2 * n; i++) scanf(\"%d\", t + i);\n        init();\n        ll ans = 0, ret = 0;\n        int r, c, m;\n        scanf(\"%d\", &m);\n        while(m--) {\n            scanf(\"%d%d\", &r, &c);\n            r = (r + ret) % n + 1;\n            c = (c + ret) % n + 1;\n            ret = f[2 * n - r + c][2 * n - r] - f[2 * n - r + c][n - r];\n            ans += ret;\n        }\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n```\n","tags":["想法"],"categories":["ACM"]},{"title":"HDU 5021 Revenge of kNN II（二分+树状数组）","url":"/2015/10/09/hdu5021/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5021\n\n# 题意\n给定n个点，每个点有一个值。现在有一些询问，每次用离某点距离最小的K个点的平均值来更新该点的值，如果有两个点距离相同，去index小的点。\n\n# 思路\n1. 可以用二分来求每次离该点最近的K个点，二分离该点的距离值即可。注意一些细节问题\n2. 用树状数组来维护距离和\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 100;\nint n, q;\nint x[N], v[N], rk[N], p[N];\npair<int, int> d[N];\ndouble c[N], b[N];\nint main () {\n    int T;\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d%d\", &n, &q);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d%d\", x + i, v + i);\n            d[i] = make_pair(x[i], i);\n            c[i] = 0;\n        }\n        sort(d + 1, d + n + 1);\n        for (int i = 1; i <= n; i++) {\n            rk[d[i].second] = i;\n            b[i] = v[d[i].second];\n            p[i] = d[i].first;\n            for (int j = i; j <= n; j += j & -j) c[j] += b[i];\n        }\n        double ans = 0;\n        while(q--) {\n            int i, k, dis;\n            scanf(\"%d%d\", &i, &k);\n            dis = x[i];\n            i = rk[i];\n            int l = 1, r = 1e9, mid;\n            while(l < r) {\n                mid = (l + r) >> 1;\n                int sum = upper_bound(p + 1, p + n + 1, dis + mid) - lower_bound(p + 1, p + n + 1, dis - mid);\n                if (sum >= k + 1) r = mid;\n                else l = mid + 1;\n            }\n            int L = lower_bound(p + 1, p + n + 1, dis - r) - p;\n            int R = upper_bound(p + 1, p + n + 1, dis + r) - p - 1;\n            if (L + k != R) {\n                if (d[L].second < d[R].second) --R;\n                else ++L;\n            }\n            double sum = 0;\n            for (int j = R; j > 0; j -= j & -j) sum += c[j];\n            for (int j = L - 1; j > 0; j -= j & -j) sum -= c[j];\n            sum -= b[i];\n            sum /= k;\n            ans += sum;\n            for (int j = i; j <= n; j += j & -j) c[j] += sum - b[i];\n            b[i] = sum;\n        }\n        printf(\"%.3lf\\n\", ans);\n    }\n    return 0;\n}\n```\n","tags":["二分"],"categories":["ACM"]},{"title":"HDU 5064 Find Sequence（LIS+dp）","url":"/2015/10/07/hdu5064/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5064\n\n# 题意\n给定n个正整数，这n个数相加为M（0<M≤2^22）。问从这n个数选出一些数，从小到大排序，使得b2-b1≤b3-b2……≤bt-bt-1。求t的最大值\n\n# 思路\n首先考虑解的结构一定是C1,C1……C2,C3……Cm。其中C1<C2<……<Cm。所以可以对ai去重后排序。可以知道此时的ai的个数为sqrt(M)级别的。\n然后用dp[i][j]表示以aj结尾，ai为倒数第二个数的最优解。dp[i][j] = max(dp[k][i]) + 1, 其中ai-ak≤aj-ai\n这样的复杂度是O(n^3),其中n为1000级别的，会TLE。\n发现有一个优化：dp[i][j+1] = max(dp[k][i]) + 1, 其中ai-ak≤aj-ai<aj+1-ai。所以重复的部分只需要计算一次即可。这样复杂度降到O(n^2)\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 3000;\nint n, m;\nint a[N * N], cnt[N], dp[N][N];\nvoid change(int &a, int b) {\n    if (a < b) a = b;\n}\nint main () {\n    int T;\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n        sort(a + 1, a + n + 1);\n        int cur;\n        cnt[cur = 1] = 1;\n        for (int i = 2; i <= n; i++) {\n            if (a[i] == a[cur]) cnt[cur]++;\n            else {\n                a[++cur] = a[i];\n                cnt[cur] = 1;\n            }\n        }\n        n = cur;\n        for (int i = 1; i <= n; i++) dp[i][i] = cnt[i];\n        int k, res, ans = 0;\n        for (int i = 1; i <= n; i++) {\n            k = i;\n            res = dp[i][i];\n            change(ans, res);\n            for (int j = i + 1; j <= n; j++) {\n                for (; k > 0 && a[i] - a[k] <= a[j] - a[i]; k--) change(res, dp[k][i] + 1);\n                dp[i][j] = res;\n                change(ans, res);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n","tags":["LIS"],"categories":["ACM"]},{"title":"HDU 5020 Revenge of Collinearity（n个点三点共线）","url":"/2015/09/29/hdu5020/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5020\n\n# 题意\n给定n个点，问有多少个三点共线的三元组。\n\n# 思路\n以每个点为基点进行极角排序，统计三点共线的个数。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 1111;\nint x[N], y[N];\npair<int, int> v[N];\nint main () {\n    int t, n, tot;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) scanf(\"%d%d\", x + i, y + i);\n        ll ans = 0;\n        for (int i = 0; i < n; i++) {\n            tot = 0;\n            for (int j = 0; j < n; j++) if (i != j) {\n                int dx = x[i] - x[j], dy = y[i] - y[j];\n                int d = __gcd(dx, dy);\n                dx /= d, dy /= d;\n                if (dx != 0 && dy != 0) {\n                    if (dx < 0) dx *= -1, dy *= -1;\n                } else dx = max(dx, -dx), dy = max(dy, -dy);\n                v[tot++] = make_pair(dx, dy);\n            }\n            sort(v, v + tot);\n            int now = 0;\n            for (int j = 0; j < tot; j++) {\n                if (j == 0 || v[j] != v[j - 1]) now = j;\n                ans += j - now;\n            }\n        }\n        printf(\"%I64d\\n\", ans / 3);\n    }\n    return 0;\n}\n```\n","tags":["三点共线"],"categories":["ACM"]},{"title":"HDU 4992 Primitive Roots（求一个数的所有原根）","url":"/2015/09/25/hdu4992/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4992\n\n# 题意\n给定一个数n，求n的所有原根，按照从小到大输出，如果没有原根输出-1\n\n# 思路\n原根的定义：g^d % p = 1 其中d最小为phi(p)，则g便为一个原根\n1. 一个数是否有原根\n    判断数是否有原根：模n有原根的充要条件是n = 1,2,4,p,2p,p^q，其中p是奇质数，q是任意正整数。\n\n2. 若有，找其最小原根 \n 然后用欧拉公式求出n的m=φ(n)，从2~n-1遍历找出n的最小原根a：判断a^m % n==1 是否成立\n计算出所有m的因子（1和m除外）y，若a^y % n==1，则a不可能是n的原根。因为存在性质：如果正整数gcd(a,m) = 1，正整数 d 满足a^d≡1(mod m)，则 d 整除 φ(m)。\n\n3. 已知一个原根，得到所有原根\n    得到所有a^x % n {2<=x<m，gcd(x,m)==1}的值为n的原根\n    证明：http://blog.csdn.net/solotzg/article/details/39205337\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\n#define maxn 1000000\nint ans[maxn + 10], valid[maxn + 10], tot = 0;\nvoid getPrime(int n, int &tot, int ans[]) {\n    for (int i = 2; i <= n; i++) {\n        if (!valid[i]) ans[tot++] = i;\n        for (int j = 0; j < tot && i * ans[j] <= n; j++) {\n            valid[i * ans[j]] = 1;\n            if (i % ans[j] == 0) break;\n        }\n    }\n}\n///判断是否有原根\n///判断数是否有原根：模n有原根的充要条件是n = 1,2,4,p,2p,p^q，其中p是奇质数，q是任意正整数。\nbool has_primitive_root(int n) {\n    if (n % 2 == 0) n /= 2;\n    if (n % 2 == 0) return false;\n    for (int i = 1; ans[i] * ans[i] <= n; i++) if (n % ans[i] == 0){\n        while(n % ans[i] == 0) n /= ans[i];\n        if (n != 1) return false;\n        return true;\n    }\n    return true;\n}\n///得到最小的原根\nll pow_mod(ll a, ll x, ll p) {\n    ll res = 1;\n    while(x) {\n        if (x & 1) res = res * a % p;\n        x >>= 1;\n        a = a * a % p;\n    }\n    return res;\n}\nll euler(ll x) {\n    ll res = x;\n    for (ll i = 0; ans[i] * ans[i] <= x; i++) if (x % ans[i] == 0) {\n        res = res / ans[i] * (ans[i] - 1);\n        while(x % ans[i] == 0) x /= ans[i];\n    }\n    if (x > 1) res = res / x * (x - 1);\n    return res;\n}\nvector<ll> a;\nbool g_test(ll g, ll p, ll fhi_n) {\n    for (ll i = 0; i < a.size(); i++)\n        if (pow_mod(g, fhi_n / a[i], p) == 1) return 0;\n    return 1;\n}\nll primitive_root(ll p, ll fhi_n) {\n    a.clear();\n    ll tmp = fhi_n;\n    for (ll i = 0; ans[i] * ans[i] <= tmp; i++) if (tmp % ans[i] == 0) { //这里还可以用筛素数优化\n        a.push_back(ans[i]);\n        while(tmp % ans[i] == 0) tmp /= ans[i];\n    }\n    if (tmp != 1) a.push_back(tmp);\n    ll g = 1;\n    while(true) {\n        if (pow_mod(g, fhi_n, p) != 1) { ///要先判断g^fhi_n % p == 1\n            g++;\n            continue;\n        }\n        if (g_test(g, p, fhi_n)) return g;\n        g++;\n    }\n}\n///根据最小原根得到所有原根\nvector<int> Getall_primitive_root(int g, int n, int fhi_n) {\n    vector<int> res;\n    res.pb(g);\n    for (int i = 2; i < fhi_n; i++) {\n        if (__gcd(i, fhi_n) != 1) continue;\n        res.pb(pow_mod(g, i, n));\n    }\n    return res;\n}\nint main () {\n    getPrime(maxn, tot, ans);\n    int n;\n    while(~scanf(\"%d\", &n)) {\n        if (n == 2) {\n            puts(\"1\");\n            continue;\n        }\n        if (n == 4) {\n            puts(\"3\");\n            continue;\n        }\n        if (!has_primitive_root(n)) {\n            puts(\"-1\");\n            continue;\n        }\n        ll fhi_n = euler(n);\n        ll g = primitive_root(n, fhi_n);\n        vector<int> res = Getall_primitive_root(g, n, fhi_n);\n        sort(res.begin(), res.end());\n        for (int i = 0; i < res.size(); i++) {\n            printf(\"%d%c\", res[i], i == res.size() - 1 ? '\\n' : ' ');\n        }\n    }\n    return 0;\n}\n```\n","tags":["原根"],"categories":["ACM"]},{"title":"HDU 4990 Reading comprehension（分奇偶讨论+矩阵快速幂）","url":"/2015/09/25/hdu4990/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4990\n\n# 题意\n给定n，按照以下程序算出ans。（n为int）\n    ans=0;\n    for(i=1;i<=n;i++)\n    {\n      if(i&1)ans=(ans*2+1)%m;\n      else ans=ans*2%m;\n    }\n    printf(\"%d\\n\",ans);\n\n# 思路\n分奇偶讨论\n当n为奇数时：fn=4*fn-1 + 1，首项为1\n当n为偶数时：fn=4*fn-1 + 2，首项为2\n之后就矩阵快速幂加速运算即可。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<set>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2;\nconst int maxm = 2;\nll mod;\nstruct Matrix {\n    int n, m;\n    ll a[maxn][maxm];\n    void clear() {\n        n = m = 0;\n        memset(a, 0, sizeof(a));\n    }\n    Matrix operator * (const Matrix &b) const { //实现矩阵乘法\n        Matrix tmp;\n        tmp.n = n;\n        tmp.m = b.m;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < b.m; j++) tmp.a[i][j] = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (!a[i][j]) continue;\n                for (int k = 0; k < b.m; k++)\n                    tmp.a[i][k] += a[i][j] * b.a[j][k], tmp.a[i][k] %= mod;\n            }\n\n        return tmp;\n    }\n    void Copy(const Matrix &b) {\n        n = b.n, m = b.m;\n        for (int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++) a[i][j] = b.a[i][j];\n    }\n    void unit(int sz) {\n        n = m = sz;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) a[i][j] = 0;\n            a[i][i] = 1;\n        }\n    }\n};\nMatrix A, B;\nvoid init() {\n    A.n = A.m = 2;\n    A.a[0][0] = 4;\n    A.a[0][1] = 1;\n    A.a[1][0] = 0;\n    A.a[1][1] = 1;\n}\nMatrix Matrix_pow(Matrix A, ll k, ll mod) { //矩阵快速幂\n    Matrix res;\n    res.clear();\n    res.n = res.m = 2;\n    for (int i = 0; i < 2; i++) res.a[i][i] = 1;\n    while(k) {\n        if (k & 1) res.Copy(A * res);\n        k >>= 1;\n        A.Copy(A * A);\n    }\n    return res;\n}\nint main () {\n    init();\n    int n, m;\n    while(~scanf(\"%d%d\", &n, &m)) {\n        mod = m;\n        Matrix ans = Matrix_pow(A, n / 2, mod);\n        ll res;\n        if (n & 1) res = ans.a[0][0] * 1 + ans.a[0][1] * 1;\n        else res = ans.a[0][1] * 2;\n        res = (res + mod) % mod;\n        printf(\"%I64d\\n\", res);\n    }\n    return 0;\n}\n```\n","tags":["矩阵"],"categories":["ACM"]},{"title":"HDU 4991 Ordered Subsequence（LIS+树状数组）","url":"/2015/09/25/hdu4991/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4991\n\n# 题意\n给定一个长度为N的序列，问所有长度为M的上升子序列的个数\n\n# 思路\n另dp[i][j]表示以a[i]为结尾，长度为j的上升子序列的个数，有如下转移方程\ndp[i][j] = sum(dp[k][j - 1]) 其中k小于i，且a[k]<a[i]\n朴素的转移是n2*m，可以通过树状数组来维护和，复杂度降到n*m*log(n)\n\n取模真心慢。。2s左右的代码，把取模改成减直接300+ms就过了\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 10005;\nint n, m, a[N], b[N];\nint s[105][N];\nint mod = 123456789;\nint lowbit(int x) {\n    return x & (-x);\n}\nvoid add(int x, int v, int id) {\n    while(x <= n) {\n        s[id][x] += v;\n        if (s[id][x] >= mod) s[id][x] -= mod;\n        x += lowbit(x);\n    }\n}\nll sum(int x, int id) {\n    ll res = 0;\n    while(x) {\n        res += s[id][x];\n        if (res >= mod) res -= mod;\n        x -= lowbit(x);\n    }\n    return res;\n}\nint main () {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        for (int i = 0; i < n; i++) scanf(\"%d\", a + i), b[i] = a[i];\n        sort(b, b + n);\n        int t = unique(b, b + n) - b;\n        for (int i = 1; i <= n; i++)\n            for (int j = 0; j <= m; j++) s[j][i] = 0;\n        ll ans = 0;\n        for (int i = 0; i < n; i++) {\n            int pos = lower_bound(b, b + t, a[i]) - b + 1;\n            add(pos, 1, 1);\n            for (int j = 2; j <= m; j++) {\n                ll tmp = sum(pos - 1, j - 1);\n                if (!tmp) break;\n                add(pos, tmp, j);\n            }\n        }\n        ans = sum(t, m);\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n\n```\n","tags":["LIS"],"categories":["ACM"]},{"title":"HDU 4988 Little Pony and Boast Busters（动态逆序对 树状数组+treap）","url":"/2015/09/24/hdu4988/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4988\n\n# 题意\n给定上下两个排列 A[], B[]，要求询问相同项之间两两连线的交叉数，并支持交换操作\n\n# 思路\n题解： http://www.shuizilong.com/house/archives/bestcoder-round-7-solution/\n静态问题就是求排列 P[] 的逆序对\n其中 P[i] = pA[B[i]]（这里 pA[] 是 A[] 中某个元素的位置 类似的 pB[] 是 B[] 中某个元素的位置）\n考察交换操作，无论是交换下排还是上排，都可以看成交换 P[] 中的两项      \n于是转化成动态逆序对问题，支持修改排列中的任意一项。\n动态逆序对问题等价于区间 kth 大值（区间 Rank）问题。。可以用经典的树套树方法\n复杂度 O(nlog2n)。\n\nhttp://blog.csdn.net/u013654696/article/details/38964519\nhttp://blog.csdn.net/cq_phqg/article/details/39070857\n\n这里其实就是每一个树状数组的结点都是一颗SBT。\n<!--more-->\n\n# 代码\n```\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 100005;\nstruct SBT{\n    //左子树指针，右子树指针，大小，键值\n    int left,right,size,key;\n    inline void Init(){\n        left=right=key=0;\n        size=1;\n    }\n}T[N * 50];\nint tot; //根的位置以及节点个数\n//左旋转处理\ninline void Left_rot(int &x){\n    int k=T[x].right;\n    T[x].right=T[k].left;\n    T[k].left=x;\n    T[k].size=T[x].size;\n    T[x].size=T[T[x].left].size+T[T[x].right].size+1;\n    x=k;\n}\n//右旋转处理\ninline void Right_rot(int &x){\n    int k=T[x].left;\n    T[x].left=T[k].right;\n    T[k].right=x;\n    T[k].size=T[x].size;\n    T[x].size=T[T[x].left].size+T[T[x].right].size+1;\n    x=k;\n}\n//调整处理\nvoid Maintain(int &r,bool flag){\n    if(flag){  //更新右子树\n        if(T[T[T[r].right].right].size>T[T[r].left].size)\n            Left_rot(r);\n        else if(T[T[T[r].right].left].size>T[T[r].left].size){\n            Right_rot(T[r].right);\n            Left_rot(r);\n        }\n        else\n            return;\n    }\n    else{   //更新在左子树\n        if(T[T[T[r].left].left].size>T[T[r].right].size)\n            Right_rot(r);\n        else if(T[T[T[r].left].right].size>T[T[r].right].size){\n            Left_rot(T[r].left);\n            Right_rot(r);\n        }\n        else\n            return;\n    }\n    //更新子树，然后再更新根，直到平衡为止\n    Maintain(T[r].left,false);\n    Maintain(T[r].right,true);\n    Maintain(r,false);\n    Maintain(r,true);\n}\n//插入新节点\nvoid Insert(int &r,int k){\n    if(r==0){\n        r=++tot;\n        T[r].Init();\n        T[r].key=k;\n    }\n    else{\n        T[r].size++;\n        if(k<=T[r].key)\n            Insert(T[r].left,k);\n        else\n            Insert(T[r].right,k);\n        //插入后要调整，保证平衡\n        Maintain(r,k>=T[r].key);\n    }\n}\n//删除结点，利用的是前驱替换\nint d_key;\nvoid Remove(int &r,int k){\n    if(!r)\n        return ;\n    T[r].size--;\n    //前者说明就是要删的节点，后两者说明不存在此节点\n    if(T[r].key==k||(T[r].left==0&&k<T[r].key)||(T[r].right==0&&k>T[r].key)){\n        if(T[r].left&&T[r].right) {\n            Remove(T[r].left,k+1);\n            T[r].key = d_key;\n        }\n        else {\n            d_key = T[r].key;\n            r=T[r].left+T[r].right;\n        }\n    }\n    else Remove(k<=T[r].key?T[r].left:T[r].right,k);\n}\n\n//取得最大值，即一直遍历到最右的结点\nint Get_Max(int r){\n    while(T[r].right)\n        r=T[r].right;\n    return r;\n}\n//取得最小值，即一直遍历到最左的结点\nint Get_Min(int r){\n    while(T[r].left)\n        r=T[r].left;\n    return r;\n}\n//获得前驱\nint Get_Pre(int &r,int y,int k){\n    if(r==0) return y;\n    if(k>T[r].key)\n        Get_Pre(T[r].right,r,k);\n    else\n        Get_Pre(T[r].left,y,k);\n}\n//获得后继\nint Get_Next(int &r,int y,int k){\n    if(r==0) return y;\n    if(k<T[r].key)\n        Get_Next(T[r].left,r,k);\n    else\n        Get_Next(T[r].right,y,k);\n}\n//取得第K小的数，注：暂不能解决有重复数的\nint Get_Kth(int &r,int k){\n    int t=T[T[r].left].size+1;\n    if(t==k) return T[r].key;\n    if(t<k)  return Get_Kth(T[r].right,k-r);\n    else return Get_Kth(T[r].left,k);\n}\n//获得结点的名次\nint Get_Rank(int r,int k){\n    int ans = 0;\n    while (r) {\n        if (T[r].key < k) {\n            ans += T[T[r].left].size + 1;\n            r = T[r].right;\n        }\n        else r = T[r].left;\n    }\n    return ans;\n}\n//排序\nvoid Inorder(int &r){\n    if(r==0) return;\n    Inorder(T[r].left);\n    printf(\"%d\\n\",T[r].key);\n    Inorder(T[r].right);\n}\n\nint n, pa[N], pb[N], root[N], a[N], b[N], p[N];\nLL ans;\ninline int lowbit(int x) {\n    return x & (-x);\n}\ninline int Rank(int x, int v) {\n    int ret = 0;\n    for (int i = x; i; i -= lowbit(i))\n        ret += Get_Rank(root[i], v);\n    return ret;\n}\ninline void Add(int x, int v) {\n    for (int i = x; i <= n; i += lowbit(i))\n        Insert(root[i], v);\n}\ninline void Del(int x, int v) {\n    for (int i = x; i <= n; i += lowbit(i))\n        Remove(root[i], v);\n}\ninline void init() {\n    tot = 0; ans = 0;\n    for (int i = 1; i <= n; i++) {\n        root[i] = 0;\n        pa[a[i]] = i;\n        pb[b[i]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        int num = pa[b[i]];\n        ans += Rank(i, num);\n        Add(i, num); p[i] = num;\n    }\n}\ninline void update (int x , int v) {\n    // postion x , from p[x] to v\n    int pre = p[x];\n    Del (x , pre);\n    ans = ans - (Rank (x - 1 , pre) + (n - x - (Rank (n , pre + 1) - Rank (x , pre + 1))));\n    p[x] = v;\n    ans = ans + (Rank (x - 1 , v) + (n - x - (Rank (n , v + 1) - Rank (x , v + 1))));\n    Add (x , v);\n}\ninline void update (int k , int A , int B) {\n    if (k == 0) {\n        swap (a[A] , a[B]);\n        pa[a[A]] = A;pa[a[B]] = B;\n        update (pb[a[A]] , A);\n        update (pb[a[B]] , B);\n    }\n    else {\n        swap (b[A] , b[B]);\n        pb[b[A]] = A;pb[b[B]] = B;\n        update (A , pa[b[A]]);\n        update (B , pa[b[B]]);\n    }\n}\nint main () {\n    while(~scanf(\"%d\", &n)) {\n        for (int i = 1; i <= n; i++) scanf(\"%d\", a + i), a[i]++;\n        for (int i = 1; i <= n; i++) scanf(\"%d\", b + i), b[i]++;\n        init();\n        int q, k, A, B;\n        char op[10];\n        scanf(\"%d\", &q);\n        LL ret = (LL)n * (n - 1) / 2;\n        while(q--) {\n            scanf(\"%s\", op);\n            if (op[0] == 'Q') printf(\"%I64d\\n\", ret - ans);\n            else {\n                scanf(\"%d%d%d\", &k, &A, &B);\n                A++, B++;\n                update(k, A, B);\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["树状数组+treap"],"categories":["ACM"]},{"title":"POJ 3481 Double Queue（SBT平衡二叉树）","url":"/2015/09/24/poj3481/","content":"# 题目\t\n源地址：http://poj.org/problem?id=3481\n\n# 题意\n有一个队伍，一开始为空，有四种操作\n0表示结束\n1 K P 有一个编号为K的，优先级为P的人加入队伍（队伍中没有相同的K与P）\n2 优先级最高的人出队\n3 优先级最低的人出队\n\n# 思路\nhttp://blog.csdn.net/acm_cxlove/article/details/7790305\n\n平衡二叉树，能够得到第K大的数，也能够求出一个数的rank。\n这里是找最大值与最小值\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define N 1000005\nusing namespace std;\nstruct SBT {\n    //左子树指针，右子树指针，大小，键值\n    int left, right, size, key, value;\n    void Init() {\n        left = right = key = value = 0;\n        size = 1;\n    }\n} T[N];\nint root, tot; //根的位置以及节点个数\n//左旋转处理\nvoid Left_rot(int &x) {\n    int k = T[x].right;\n    T[x].right = T[k].left;\n    T[k].left = x;\n    T[k].size = T[x].size;\n    T[x].size = T[T[x].left].size + T[T[x].right].size + 1;\n    x = k;\n}\n//右旋转处理\nvoid Right_rot(int &x) {\n    int k = T[x].left;\n    T[x].left = T[k].right;\n    T[k].right = x;\n    T[k].size = T[x].size;\n    T[x].size = T[T[x].left].size + T[T[x].right].size + 1;\n    x = k;\n}\n//调整处理\nvoid Maintain(int &r, bool flag) {\n    if(flag) { //更新右子树\n        if(T[T[T[r].right].right].size > T[T[r].left].size)\n            Left_rot(r);\n        else if(T[T[T[r].right].left].size > T[T[r].left].size) {\n            Right_rot(T[r].right);\n            Left_rot(r);\n        } else\n            return;\n    } else { //更新在左子树\n        if(T[T[T[r].left].left].size > T[T[r].right].size)\n            Right_rot(r);\n        else if(T[T[T[r].left].right].size > T[T[r].right].size) {\n            Left_rot(T[r].left);\n            Right_rot(r);\n        } else\n            return;\n    }\n    //更新子树，然后再更新根，直到平衡为止\n    Maintain(T[r].left, false);\n    Maintain(T[r].right, true);\n    Maintain(r, false);\n    Maintain(r, true);\n}\n//插入新节点\nvoid Insert(int &r, int k, int v) {\n    if(r == 0) {\n        r = ++tot;\n        T[r].Init();\n        T[r].key = k;\n        T[r].value = v;\n    } else {\n        T[r].size++;\n        if(k < T[r].key)\n            Insert(T[r].left, k, v);\n        else\n            Insert(T[r].right, k, v);\n        //插入后要调整，保证平衡\n        Maintain(r, k >= T[r].key);\n    }\n}\n//删除结点，利用的是前驱替换\nint Remove(int &r, int k) {\n    int d_key;\n    if(!r)\n        return 0;\n    T[r].size--;\n    //前者说明就是要删的节点，后两者说明不存在此节点\n    if(T[r].key == k || (T[r].left == 0 && k < T[r].key) || (T[r].right == 0 && k > T[r].key)) {\n        d_key = T[r].key;\n        if(T[r].left && T[r].right)\n            T[r].key = Remove(T[r].left, k + 1);\n        else\n            r = T[r].left + T[r].right;\n    } else Remove(k < T[r].key ? T[r].left : T[r].right, k);\n}\n//取得最大值，即一直遍历到最右的结点\nint Get_Max(int r) {\n    while(T[r].right)\n        r = T[r].right;\n    return r;\n}\n//取得最小值，即一直遍历到最左的结点\nint Get_Min(int r) {\n    while(T[r].left)\n        r = T[r].left;\n    return r;\n}\n//获得前驱\nint Get_Pre(int &r, int y, int k) {\n    if(r == 0) return y;\n    if(k > T[r].key)\n        Get_Pre(T[r].right, r, k);\n    else\n        Get_Pre(T[r].left, y, k);\n}\n//获得后继\nint Get_Next(int &r, int y, int k) {\n    if(r == 0) return y;\n    if(k < T[r].key)\n        Get_Next(T[r].left, r, k);\n    else\n        Get_Next(T[r].right, y, k);\n}\n//取得第K小的数，注：暂不能解决有重复数的\nint Get_Kth(int &r, int k) {\n    int t = T[T[r].left].size + 1;\n    if(t == k) return T[r].key;\n    if(t < k)  return Get_Kth(T[r].right, k - r);\n    else return Get_Kth(T[r].left, k);\n}\n//获得结点的名次\nint Get_Rank(int &r, int k) {\n    if(k < T[r].key)\n        return Get_Rank(T[r].left, k);\n    else if(k > T[r].key)\n        return Get_Rank(T[r].right, k) + T[T[r].left].size + 1;\n    else\n        return T[T[r].left].size + 1;\n}\n//排序\nvoid Inorder(int &r) {\n    if(r == 0) return;\n    Inorder(T[r].left);\n    printf(\"%d\\n\", T[r].key);\n    Inorder(T[r].right);\n}\nint main () {\n    root = tot = 0;\n    int x, k, p;\n    while(~scanf(\"%d\", &x)) {\n        if (!x) break;\n        if (x == 1) {\n            scanf(\"%d%d\", &k, &p);\n            Insert(root, p, k);\n        }\n        if (x == 2) {\n            int tmp = Get_Max(root);\n            printf(\"%d\\n\", T[tmp].value);\n            if (T[tmp].value) Remove(root, T[tmp].key);\n        }\n        if (x == 3) {\n            int tmp = Get_Min(root);\n            printf(\"%d\\n\", T[tmp].value);\n            if (T[tmp].value) Remove(root, T[tmp].key);\n        }\n    }\n    return 0;\n}\n```\n","tags":["SBT"],"categories":["ACM"]},{"title":"HDU 5451 Best Solver（数学+广义Fibonacci循环节+矩阵快速幂）","url":"/2015/09/21/hdu5451/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5451\n\n# 题意\n计算（5+2sqrt(6))^(1+2^x) 向下取整 mod m 其中x为int范围，m为质数\n\n# 思路\nhttp://blog.csdn.net/crazy______/article/details/9021169\nhttp://blog.csdn.net/ACdreamers/article/details/25616461\n\n另 fn = (a+sqrt(b))^n + (a-sqrt(b))^n\n化简得到fn+1 = 2a*fn - fn-1\n其中0<(a-sqrt(b))^n<1 所以可以用矩阵快速幂来求。\n但是x很大, 所以要用到循环节。即求广义Fibonacci数列循环节。这里直接用(p+1)(p-1)来做循环节\n\n官方题解里提到(p^2-p)(p^2-1)是一个通用循环节\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2;\nconst int maxm = 2;\nll mod;\nstruct Matrix {\n    int n, m;\n    ll a[maxn][maxm];\n    void clear() {\n        n = m = 0;\n        memset(a, 0, sizeof(a));\n    }\n    Matrix operator * (const Matrix &b) const { //实现矩阵乘法\n        Matrix tmp;\n        tmp.n = n;\n        tmp.m = b.m;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < b.m; j++) tmp.a[i][j] = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (!a[i][j]) continue;\n                for (int k = 0; k < b.m; k++)\n                    tmp.a[i][k] += a[i][j] * b.a[j][k], tmp.a[i][k] %= mod;\n            }\n\n        return tmp;\n    }\n    void Copy(const Matrix &b) {\n        n = b.n, m = b.m;\n        for (int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++) a[i][j] = b.a[i][j];\n    }\n    void unit(int sz) {\n        n = m = sz;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) a[i][j] = 0;\n            a[i][i] = 1;\n        }\n    }\n};\nMatrix A, B;\nMatrix Matrix_pow(Matrix A, ll k, ll mod) { //矩阵快速幂\n    Matrix res;\n    res.clear();\n    res.n = res.m = 2;\n    for (int i = 0; i < 2; i++) res.a[i][i] = 1;\n    while(k) {\n        if (k & 1) res.Copy(A * res);\n        k >>= 1;\n        A.Copy(A * A);\n    }\n    return res;\n}\nll pow_mod(ll a, ll n, ll p) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) res = res * a % p;\n        n >>= 1;\n        a = a * a % p;\n    }\n    return res;\n}\nint x, m;\nvoid init() {\n    A.a[0][0] = 10;\n    A.a[0][1] = -1;\n    A.a[1][0] = 1;\n    A.a[1][1] = 0;\n    A.n = A.m = 2;\n}\nint work() {\n    mod = m * m - 1;\n    ll k = pow_mod(2, x, mod);\n    mod = m;\n    Matrix ans = Matrix_pow(A, k, mod);\n    ll res = (ans.a[0][0] * 10 + ans.a[0][1] * 2) % mod;\n    res = (res - 1 + mod) % mod;\n    return res;\n}\nint main () {\n    init();\n    int t, cas = 1;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &x, &m);\n        printf(\"Case #%d: %d\\n\", cas++, work());\n    }\n    return 0;\n}\n```\n","tags":["数学"],"categories":["ACM"]},{"title":"Acdream 1075 神奇的%系列三（广义Fibonacci数列找循环节）","url":"/2015/09/21/ACdream1075/","content":"# 题目\t\n源地址：http://acdream.info/problem?pid=1075\n\n# 题意\n我们定义一个f(n)函数，f(n) = a * f(n - 1) + b * f(n - 2), f(1) = c, f(2) = d.\n问f(n)在模1000000007情况下的最小循环节。即求最小的m，使对任意的n有f(n) % 1000000007 = f(n + m) % 1000000007.\n\n# 思路\nhttp://blog.csdn.net/ACdreamers/article/details/25616461\n\nc=a*a+4*b\nc是模p的二次剩余时，枚举n=p-1的因子\nc是模的二次非剩余时，枚举的n=(p+1)(p-1)因子\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2;\nconst int maxm = 2;\nconst ll mod = 1000000007;\nstruct Matrix {\n    int n, m;\n    ll a[maxn][maxm];\n    void clear() {\n        n = m = 0;\n        memset(a, 0, sizeof(a));\n    }\n    Matrix operator * (const Matrix &b) const { //实现矩阵乘法\n        Matrix tmp;\n        tmp.n = n;\n        tmp.m = b.m;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < b.m; j++) tmp.a[i][j] = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (!a[i][j]) continue;\n                for (int k = 0; k < b.m; k++)\n                    tmp.a[i][k] += a[i][j] * b.a[j][k], tmp.a[i][k] %= mod;\n            }\n\n        return tmp;\n    }\n    void Copy(const Matrix &b) {\n        n = b.n, m = b.m;\n        for (int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++) a[i][j] = b.a[i][j];\n    }\n    void unit(int sz) {\n        n = m = sz;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) a[i][j] = 0;\n            a[i][i] = 1;\n        }\n    }\n};\nMatrix A, B;\nMatrix Matrix_pow(Matrix A, ll k, ll mod) { //矩阵快速幂\n    Matrix res;\n    res.clear();\n    res.n = res.m = 2;\n    for (int i = 0; i < 2; i++) res.a[i][i] = 1;\n    while(k) {\n        if (k & 1) res.Copy(A * res);\n        k >>= 1;\n        A.Copy(A * A);\n    }\n    return res;\n}\n\nll pow_mod(ll a, ll n, ll p) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) res = res * a % p;\n        n >>= 1;\n        a = a * a % p;\n    }\n    return res;\n}\nll legendre(ll a, ll p) {\n    return pow_mod(a, (p - 1) >> 1, p);\n}\n\nll fac[2][500];\nint cnt, ct;\nll pri[6] = {2, 3, 7, 109, 167, 500000003};\nll num[6] = {4, 2, 1, 2, 1, 1};\nvoid dfs(int dep, ll pro) {\n    if (dep == cnt) {\n        fac[1][ct++] = pro;\n        return ;\n    }\n    for (int i = 0; i <= num[dep]; i++) {\n        dfs(dep + 1, pro);\n        pro *= pri[dep];\n    }\n}\nvoid init() {\n    cnt = 6;\n    ct = 0;\n    dfs(0, 1);\n    sort(fac[1], fac[1] + ct);\n    fac[0][0] = 1;\n    fac[0][1] = 2;\n    fac[0][2] = 500000003;\n    fac[0][3] = 1000000006;\n}\nbool check(Matrix A, ll n) {\n    Matrix ans = Matrix_pow(A, n, mod);\n    return (ans.a[0][0] == 1 && ans.a[0][1] == 0 && ans.a[1][0] == 0 && ans.a[1][1] == 1);\n}\nll a, b, c, d;\nint main () {\n    init();\n    while(~scanf(\"%lld%lld%lld%lld\", &a, &b, &c, &d)) {\n        ll t = a * a + 4 * b;\n        A.n = A.m = 2;\n        A.a[0][0] = a;\n        A.a[0][1] = b;\n        A.a[1][0] = 1;\n        A.a[1][1] = 0;\n        if (legendre(t, mod) == 1) {\n            for (int i = 0; i < 4; i++) {\n                if (check(A, fac[0][i])) {\n                    printf(\"%lld\\n\", fac[0][i]);\n                    break;\n                }\n            }\n        } else {\n            for (int i = 0; i < ct; i++) {\n                if (check(A, fac[1][i])) {\n                    printf(\"%lld\\n\", fac[1][i]);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["数学"],"categories":["ACM"]},{"title":"HDU 4565 So Easy!（矩阵, 数学）","url":"/2015/09/20/hdu4565/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4565\n\n# 题意\ns=ceil( (a+sqrt(b))^n ) % m\n\n# 思路\nhttp://blog.csdn.net/crazy______/article/details/9021169\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2;\nconst int maxm = 2;\nint mod;\nstruct Matrix {\n    int n, m;\n    int a[maxn][maxm];\n    void clear() {\n        n = m = 0;\n        memset(a, 0, sizeof(a));\n    }\n    Matrix operator * (const Matrix &b) const { //实现矩阵乘法\n        Matrix tmp;\n        tmp.n = n;\n        tmp.m = b.m;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < b.m; j++) tmp.a[i][j] = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (!a[i][j]) continue;\n                for (int k = 0; k < b.m; k++)\n                    tmp.a[i][k] += a[i][j] * b.a[j][k], tmp.a[i][k] %= mod;\n            }\n\n        return tmp;\n    }\n    void Copy(const Matrix &b) {\n        n = b.n, m = b.m;\n        for (int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++) a[i][j] = b.a[i][j];\n    }\n    void unit(int sz) {\n        n = m = sz;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) a[i][j] = 0;\n            a[i][i] = 1;\n        }\n    }\n};\nMatrix A, B;\nint a, b, n;\nvoid init() {\n    A.clear(); //矩阵A是构造的矩阵\n    A.n = A.m = 2;\n    A.a[0][0] = 2 * a % mod;\n    A.a[0][1] = (-(a * a - b) % mod + mod) % mod;\n    A.a[1][0] = 1;\n    A.a[1][1] = 0;\n    B.clear();\n    B.n = 2;\n    B.m = 1;\n    B.a[0][0] = 2 * a % mod;\n    B.a[1][0] = 2;\n}\nMatrix Matrix_pow(Matrix A, int k, int mod) { //矩阵快速幂\n    Matrix res;\n    res.clear();\n    res.n = res.m = 2;\n    for (int i = 0; i < 2; i++) res.a[i][i] = 1;\n    while(k) {\n        if (k & 1) res.Copy(A * res);\n        k >>= 1;\n        A.Copy(A * A);\n    }\n    return res;\n}\nint main () {\n    while(~scanf(\"%d%d%d%d\", &a, &b, &n, &mod)) {\n        init();\n        A = Matrix_pow(A, n - 1, mod);\n        A = A * B;\n        printf(\"%d\\n\", A.a[0][0]);\n    }\n    return 0;\n}\n```\n","tags":["矩阵"],"categories":["ACM"]},{"title":"HDU 4987 Little Pony and Dice（概率dp）","url":"/2015/09/20/hdu4987/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4987\n\n# 题意\n有一个 m 面的均匀骰子（[1, m]），然后从 0 出发，根据扔的数字，决定向前走的步数，走到 ≥n 时就停止。\n求刚好在 n 停止的概率。要求误差 10−5 以内。（1≤m,n≤1e9）\n\n# 思路\n1. 当 m 很大时，概率会接近 0，由于误差 10−5，当 m≥600000 时，直接返回 0\n\n2. 当n<=m时，到n的概率为 ((1+(1/m))^(n-1))/m\n计算过程如下：\nC(n-1,0)/m + C(n-1,1)/m^2 + .... + C(n-1,n-1)/m^n 即一步走到，两步走到，n步走到\n提出一个1/m, C(n-1,0)+C(n-1,1)/m+...+C(n-1,n-1)/m^(n-1) = (1+1/m)^(n-1)\n\n3. 当n>m,且m比较小\n设dp[i]为走到i的概率，s[i]为前i个概率和\nif (i <= m) dp[i] = s[i - 1] / m;   //i之前的走一步到达i\nelse dp[i] = (s[i - 1] - s[i - 1 - m]) / m;     //前m个走一步到达i\n多测试几个数字，会发现当n比较大的时候，答案会收敛于 2/(m+1) \n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nint m, n;\nconst int N = 1000000;\ndouble dp[N + 100], s[N + 100];\nint main () {\n    while(~scanf(\"%d%d\", &m, &n)) {\n        if (m >= 600000) puts(\"0.00000\");\n        else {\n            if (n <= m) printf(\"%.5lf\\n\", pow(1 + 1.0 / m, n - 1) / m);\n            else {\n                dp[0] = 1, s[0] = 1;\n                for (int i = 1; i <= n; i++) {\n                    if (i <= m) dp[i] = s[i - 1] / m;\n                    else dp[i] = (s[i - 1] - s[i - 1 - m]) / m;\n                    s[i] = s[i - 1] + dp[i];\n                    if (i >= m && abs(dp[i] - 2. / (m + 1)) <= 1e-9) {\n                        n = i;\n                        break;\n                    }\n                }\n                printf(\"%.5lf\\n\", dp[n]);\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["概率dp"],"categories":["ACM"]},{"title":"HDU 5072 Coprime（同色三角形模型+容斥）","url":"/2015/09/20/hdu5072/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5072\n\n# 题意\n给定n个数，求有多少对(a,b,c)满足两两互质或两两不互质。\n\n# 思路\n把三个数当做三角形的三个点，两个数之间的关系为边。互质为0，不互质为1.\n则关系有(0,0,0),(1,1,1)是满足条件的。\n如果a，b，c不符合条件，必然有一对互质，一对不互质，不妨设a，b互质，b，c不互质，于是我们可以枚举b来统计所有的三元组：如果a，c互质那么这样的三元组中b，c可以互换位置；如果a，c不互质，那么a，b可以互换位置。每个答案被算了两遍。\n所以只要枚举每个b，统计出k个和它不互质的，那么剩下n-1-k个就是和它互质的，那么三元组就有k*(n-1-k)/2种。\n\n如何计算所有数中与某一个数字不互质的个数。由于数字小于等于1e5（2*3*5*7*11*13*17>10^5）所以质因子的个数不会超过6个。所以可以用二进制枚举每个数的质因子组合，如果某个数是其倍数，则一定不互质。用容斥原理来计算。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\ntypedef long long ll;\nusing namespace std;\n#define maxn 100000\nint ans[maxn + 10], valid[maxn + 10], tot = 0;\nvoid getPrime(int n, int &tot, int ans[]) {\n    for (int i = 2; i <= n; i++) {\n        if (!valid[i]) ans[tot++] = i;\n        for (int j = 0; j < tot && i * ans[j] <= n; j++) {\n            valid[i * ans[j]] = 1;\n            if (i % ans[j] == 0) break;\n        }\n    }\n}\nint a[maxn + 10][6], b[maxn + 10][6], cnt[maxn + 10];\nvoid factor(int n, int a[][6], int b[][6], int cnt[]) {\n    int tmp, now;\n    int &tot = cnt[n];\n    tot = 0;\n    now = n;\n    for (int i = 0; (ll)ans[i] * ans[i] <= now; i++) if (now % ans[i] == 0) {\n        a[n][tot] = ans[i], b[n][tot] = 0;\n        while(now % ans[i] == 0) {\n            b[n][tot]++;\n            now /= ans[i];\n        }\n        tot++;\n    }\n    if (now != 1) a[n][tot] = now, b[n][tot++] = 1;\n}\nvoid init() {\n    getPrime(maxn, tot, ans);\n    for (int i = 2; i <= maxn; i++) factor(i, a, b, cnt);\n}\nint s[maxn + 10], num[maxn + 10], n;\nint main () {\n    init();\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d\", &n);\n        memset(s, 0, sizeof(s));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", num + i);\n            int tot = 1 << cnt[num[i]];\n            for (int j = 0; j < tot; j++) {\n                int tmp = 1;\n                for (int k = 0; k < cnt[num[i]]; k++) if (j >> k & 1) {\n                    tmp *= a[num[i]][k];\n                }\n                s[tmp]++;\n            }\n        }\n        ll ans = 0;\n        for (int i = 0; i < n; i++) {\n            int tot = 1 << cnt[num[i]];\n            ll res = n;\n            for (int j = 0; j < tot; j++) {\n                int tmp = 1, x = 0;\n                for (int k = 0; k < cnt[num[i]]; k++) if (j >> k & 1) {\n                    tmp *= a[num[i]][k];\n                    x++;\n                }\n                if (x % 2) res += s[tmp];\n                else res -= s[tmp];\n            }\n            if (res) ans += (res - 1) * (n - res);\n        }\n        ans = (ll)n * (n - 1) * (n - 2) / 6 - ans / 2;\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n```\n","tags":["容斥"],"categories":["ACM"]},{"title":"ZOJ 3774 Power of Fibonacci（斐波那契数列的幂和）","url":"/2015/09/10/zoj3774/","content":"# 题目\t\n源地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=5237\n\n# 题意\n求前n项斐波那契数的k次幂和\n\n# 思路\nhttp://blog.csdn.net/acdreamers/article/details/23039571\n由于5是1000000009的二次剩余，所以可以用一个整数来代替sqrt(5) mod 1000000009\n要注意在求等比数列时q=1的情况\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 100005;\nconst ll mod = 1e9 + 9;\nconst ll a = 691504013; ///a = (1+sqrt(5))/2\nconst ll b = 308495997; ///a = (1-sqrt(5))/2\n#define M 100001\nll inv[N], ba[N], rba[N], A[N], B[N], m;\nll pow_mod(ll a, ll x, ll p) {\n    ll res = 1;\n    while(x) {\n        if (x & 1) res = res * a % p;\n        x >>= 1;\n        a = a * a % p;\n    }\n    return res;\n}\nvoid init() {\n    inv[0] = inv[1] = 1;\n    ba[0] = ba[1] = 1;\n    rba[0] = rba[1] = 1;\n    A[0] = B[0] = 1;\n    A[1] = a, B[1] = b;\n    for (int i = 2; i < M; i++) {\n        inv[i] = ((mod - mod / i) * inv[mod % i]) % mod;\n        ba[i] = (ba[i - 1] * i) % mod;\n        rba[i] = (rba[i - 1] * inv[i]) % mod;\n        A[i] = (A[i - 1] * a) % mod;\n        B[i] = (B[i - 1] * b) % mod;\n    }\n    m = pow_mod(383008016, mod - 2, mod); ///383008016 = sqrt(5), m = 1/sqrt(5)\n}\n\nll C(int n, int k) {\n    return (ba[n] * rba[k] % mod ) * rba[n - k] % mod;\n}\nll solve(ll n, ll k) {\n    ll ans = 0;\n    for (int r = 0; r <= k; r++) {\n        ll t = A[k - r] * B[r] % mod;\n        ll c = C(k, r);\n        ll tmp = n % mod;\n        if (t != 1) tmp = t * (pow_mod(t, n, mod) - 1) % mod * pow_mod(t - 1, mod - 2, mod) % mod;\n        tmp = tmp * c % mod;\n        if (r & 1) ans -= tmp;\n        else ans += tmp;\n        ans %= mod;\n    }\n    ans = ans * pow_mod(m, k, mod) % mod;\n    ans = (ans + mod) % mod;\n    return ans;\n}\nint main () {\n    int t;\n    ll n, k;\n    init();\n    cin>>t;\n    while(t--) {\n        scanf(\"%lld%lld\", &n, &k);\n        printf(\"%lld\\n\", solve(n, k));\n    }\n    return 0;\n}\n```\n","tags":["斐波那契数"],"categories":["ACM"]},{"title":"HDU 4959 Poor Akagi（卢卡斯数+二次域运算+等比数列求和）","url":"/2015/09/10/hdu4959/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4959\n\n# 题意\n求前n项卢卡斯数的k次幂和\n\n# 思路\nhttp://blog.csdn.net/ahm001/article/details/38724607\n其实知道了卢卡斯数的通项公式，就比较容易计算了。这道题目因为sqrt(5)不是1000000007的二次剩余，所以就不能够用之前把sqrt(5)当做一个整数的方式来处理。\n但是可以用定义二次域运算的方式来处理此题，重定义二次域上的运算\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 100005;\nconst ll mod = 1e9 + 7;\n#define pll pair<ll, ll>\npll operator + (pll a, pll b) {\n    a.fi = (a.fi + b.fi) % mod;\n    a.se = (a.se + b.se) % mod;\n    return a;\n}\npll operator * (pll a, pll b) {\n    pll c;\n    c.fi = (a.fi * b.fi + 5 * a.se * b.se) % mod;\n    c.se = (a.fi * b.se + a.se * b.fi) % mod;\n    return c;\n}\nll pow_mod(ll a, ll x, ll p) {\n    ll res = 1;\n    while(x) {\n        if (x & 1) res = res * a % p;\n        x >>= 1;\n        a = a * a % p;\n    }\n    return res;\n}\npll operator / (pll a, pll b) {\n    pll c = a * pll(b.fi, (mod - b.se) % mod);\n    ll multi = ((b.fi * b.fi - 5 * b.se * b.se) % mod + mod) % mod;\n    return c * pll(pow_mod(multi, mod - 2, mod), 0);\n}\npll pow_mod(pll a, ll x) {\n    pll res(1, 0);\n    while(x) {\n        if (x & 1) res = res * a;\n        x >>= 1;\n        a = a * a;\n    }\n    return res;\n}\nll inv[N], ba[N], rba[N];\n#define M 100001\nvoid init() {\n    inv[0] = inv[1] = 1;\n    ba[0] = ba[1] = 1;\n    rba[0] = rba[1] = 1;\n    for (int i = 2; i < M; i++) {\n        inv[i] = ((mod - mod / i) * inv[mod % i]) % mod;\n        ba[i] = (ba[i - 1] * i) % mod;\n        rba[i] = (rba[i - 1] * inv[i]) % mod;\n    }\n}\nll C(int n, int k) {\n    return (ba[n] * rba[k] % mod) * rba[n - k] % mod;\n}\nint main () {\n    ll rev2 = pow_mod(2, mod - 2, mod);\n    pll a(rev2, (mod - 1) * rev2 % mod);\n    pll b(rev2, rev2);\n    init();\n    int t;\n    ll n, k;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%I64d%I64d\", &n, &k);\n        pll ans(0, 0);\n        for (int i = 0; i <= k; i++) {\n            ll c = C(k, i);\n            pll q = pow_mod(a, i) * pow_mod(b, k - i);\n            pll qn = pow_mod(q, n + 1);\n            pll e(mod - 1, 0);\n            pll s;\n            if (q.first == 1 && q.second == 0) s = q * pll((n + 1) % mod * c % mod, 0);\n            else s = (qn + e) / (q + e) * pll(c, 0);\n            ans = ans + s;\n        }\n        printf(\"%d\\n\", (ans.first + mod) % mod);\n    }\n    return 0;\n}\n\n```\n","tags":["二次域运算"],"categories":["ACM"]},{"title":"HDU 4958 Poor Rukaw（dp + 期望）","url":"/2015/09/03/hdu4958/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4958\n\n# 题意\n有一个游戏，桌上有n个数字，A，B轮流轮流操作，每次操作从中选择两个数字x，y，并将其改为abs(x-y)。这样轮流操作，最后剩下为偶数则A得分，否则B得分，得的分数为一开始的数字个数。一轮游戏之后，所有所有数字复原，输的人可以选择干掉一个数字。然后游戏继续，此时输的人先操作。一开始A先操作，且A每次选择对自己最优的方案（他想要获得更高的分数），而B的每一次操作都是随机的。\n\n# 思路\n观察发现：奇 - 奇 = 偶；奇 - 偶 = 奇； 偶 - 偶 = 偶\n所以奇数每次都是成对消失的。对于每一轮游戏，谁获胜都是确定的。\n所以就可以用记忆化搜索来解决此题。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N = 1010;\ndouble dp[N][N][2];\nint n;\ndouble dfs(int x, int y, int w) {\n    if (dp[x][y][w] != -1) return dp[x][y][w];\n    if (x + y == 0) return 0;\n    double ans = 0;\n    int s = 1;\n    if (x % 2 == 0) ans = x + y, s = 0;\n    if (!s) {\n        double t1 = 0, t2 = 0, p = 0;\n        if (x > 0) ans += dfs(x - 1, y, 0) * x / (x + y);\n        if (y > 0) ans += dfs(x, y - 1, 0) * y / (x + y);\n    } else {\n        ans += dfs(x - 1, y, 1);\n    }\n    //cout<<x<<\" \"<<y<<\" \"<<ans<<endl;\n    dp[x][y][w] = ans;\n    return ans;\n}\nint main () {\n    int t;\n    cin>>t;\n    for (int i = 0; i <= 1000; i++)\n        for (int j = 0; j <= 1000; j++)\n            dp[i][j][0] = dp[i][j][1] = -1;\n    while(t--) {\n        scanf(\"%d\", &n);\n        int x = 0, y = 0, u;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &u);\n            if (u % 2 == 1) x++;\n            else y++;\n        }\n        printf(\"%d\\n\", (int)(3 * dfs(x, y, 1) + 0.5));\n    }\n    return 0;\n}\n\n```\n","tags":["期望"],"categories":["ACM"]},{"title":"hihiCoder 1033 交错和（数位dp）","url":"/2015/09/03/hihiCoder1033/","content":"# 题目\t\n源地址：http://hihocoder.com/problemset/problem/1033\n\n# 题意\n规定f(x)为x的各位交错和，现在给定一个区间[l,r]，求区间内满足f(x)=k的所有x的和\n\n# 思路\n很明显是数位dp的思想，但是状态比较多。\ndp[fh][one][pos][psum]来表示符号为fh，前缀零的状态one，当前位pos，以及该位以后的交错和为psum的个数\nsum[fh][one][pos][psum]则表示所有这些数的和\n之后的转移dp比较容易，个数累加即可，sum则相对复杂，详见代码\n这里one这个状态很关键，因为当前面全为前缀零时，fh其实是没有意义的，所以如果不单独开一维维护one，会导致结果错误\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\n#define pll pair<ll, ll>\nll l, r, k;\nll dp[2][2][20][400];\nll sum[2][2][20][400];\nll base[20];\nint bit[20];\nconst int mod = 1e9 + 7;\npll dfs(int pos, int psum, bool fh, bool one, bool flag) {\n    if (pos == -1) {\n        if (psum == 0) return {1, 0};\n        else return {0, 0};\n    }\n    int ss;\n    if (!flag) {\n        ss = psum + 200;\n        if (dp[fh][one][pos][ss] != -1) return {dp[fh][one][pos][ss], sum[fh][one][pos][ss]};\n    }\n    int u = flag ? bit[pos] : 9;\n    ll ans = 0, res = 0;\n    pll tmp;\n    for (int i = 0; i <= u; i++) {\n        int nxt = flag && i == u;\n        if (!i && one) {\n            tmp = dfs(pos - 1, psum, 1, 1, nxt);\n        } else {\n            if (fh) tmp = dfs(pos - 1, psum + i, 0, 0, nxt);\n            else tmp = dfs(pos - 1, psum - i, 1, 0, nxt);\n        }\n        ans = (ans + tmp.fi) % mod;\n        res = (res + (i * base[pos] % mod * tmp.fi % mod) + tmp.se) % mod;\n    }\n    if (ss < 0) debug;\n    if (!flag) dp[fh][one][pos][ss] = ans, sum[fh][one][pos][ss] = res;\n    return {ans, res};\n}\nll calc(ll x) {\n    if (x < 0) return 0;\n    int pos = 0;\n    while(x) {\n        bit[pos++] = x % 10;\n        x /= 10;\n    }\n    pll tmp = dfs(pos - 1, -k, 1, 1, 1);\n    return tmp.se;\n}\nint main () {\n    base[0] = 1;\n    for (int i = 1; i <= 19; i++) base[i] = base[i - 1] * 10 % mod;\n    memset(dp, -1, sizeof(dp));\n    while(~scanf(\"%lld%lld%lld\", &l, &r, &k)) {\n        printf(\"%lld\\n\", (calc(r) - calc(l - 1) + mod) % mod);\n    }\n    return 0;\n}\n```\n","tags":["数位dp"],"categories":["ACM"]},{"title":"HDU 4933 Miaomiao's Function（数位dp+大数）","url":"/2015/09/02/hdu4933/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4933\n\n# 题意\n一道数学题，题意不好描述，见题面吧。\n\n# 思路\n题目中的f(x)比较好求，主要是求g(x)。\ng(x)定义为x的各个位数交错和，现在要求一个区间[l, r]的g(x)和。显然是用数位dp做。\n不过数据比较大，需要用到大数。\ndp[pos][one]表示到pos位，前面是否全为零的交错和\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nstruct bigint { //flag表示正负，a数组从低位到高位, 从1开始\n    int flag;\n    int a[210];\n    bigint() {\n        flag=1;\n        memset(a,0,sizeof a);\n    }\n    void clear() {\n        for (int i = 200; i >= 0; i--) a[i] = 0;\n    }\n    void out() {\n        for (int i = 10; i >= 1; i--) printf(\"%d\", a[i]);\n        cout<<endl;\n    }\n};\nbigint operator +(bigint a, bigint b);\nbigint operator -(bigint a, bigint b);\nbigint operator +(bigint a, bigint b) {\n    if (a.flag==b.flag) {\n        bigint c;\n        int g=0;\n        for(int i=1; i<=200; i++) {\n            c.a[i]=a.a[i]+b.a[i]+g;\n            g=c.a[i]/10;\n            c.a[i]%=10;\n        }\n        c.flag=a.flag;\n        return c;\n    } else {\n        if (a.flag==1) {\n            b.flag=1;\n            return a-b;\n        } else {\n            a.flag=1;\n            return b-a;\n        }\n    }\n}\nint cmp(const bigint &a, const bigint &b) {\n    for(int i=200; i>=1; i--) if (a.a[i]!=b.a[i]) if (a.a[i]<b.a[i]) return -1;\n            else return 1;\n    return 0;\n}\nbigint operator -(bigint a, bigint b) {\n    if (a.flag==-1 || b.flag==-1) {\n        if (a.flag==-1 && b.flag==-1) {\n            a.flag=1;\n            b.flag=1;\n            return b-a;\n        }\n        if (a.flag==-1) {\n            a.flag=1;\n            a=a+b;\n            a.flag=-1;\n            return a;\n        }\n        if (b.flag==-1) {\n            b.flag=1;\n            return a+b;\n        }\n    }\n    if (cmp(a,b)==-1) {\n        a=b-a;\n        a.flag=-1;\n        return a;\n    }\n    bigint c;\n    int g=0;\n    for(int i=1; i<=200; i++) {\n        c.a[i]=a.a[i]-b.a[i]-g;\n        if (c.a[i]<0) c.a[i]+=10, g=1;\n        else g=0;\n    }\n    return c;\n}\nbigint operator *(bigint a, int t) {\n    if (t==0) {\n        bigint c;\n        return c;\n    }\n    if (t<0) {\n        a.flag*=-1;\n        t*=-1;\n    }\n    int g=0;\n    bigint c;\n    c.flag=a.flag;\n    for(int i=1; i<=200; i++) {\n        c.a[i]=a.a[i]*t+g;\n        g=c.a[i]/10;\n        c.a[i]%=10;\n    }\n    return c;\n}\nint iszero(bigint z) {\n    for(int i=1; i<=200; i++) if (z.a[i]!=0) return 0;\n    return 1;\n}\nbigint toBigint(char *s) {\n    int len=strlen(s+1);\n    bigint c;\n    for(int i=len;i>=1;i--) c.a[len-i+1]=s[i]-'0';\n    return c;\n}\nbigint toBigint(int a) {\n    bool flag=true;\n    if(a<0) {\n        a=-a;\n        flag=false;\n    }\n    char s[10];\n    int cnt=1;\n    while(a) {\n        s[cnt++]=(a%10+'0');\n        a/=10;\n    }\n    for(int i=1,j=cnt-1; i<j; i++,j--)\n        swap(s[i],s[j]);\n    s[cnt]='\\0';\n    bigint q=toBigint(s);\n    if(!flag)\n        q.flag=-1;\n    return q;\n}\nint modd(bigint c, int z) {\n    int g=0;\n    for(int i=200; i>=1; i--) g=(g*10+c.a[i])%z;\n    if (c.flag==-1) g*=-1;\n    return g;\n}\nchar l[105], r[105];\nbigint base[105], g[105], dp[105][2];\nbool vis[105][2] = {0};\nint bit[105];\nbigint dfs(int pos, bool one, bool flag) {\n    if (pos == 0) {\n        if (!flag) return toBigint(45);\n        else return toBigint(bit[0] * (bit[0] + 1) / 2);\n    }\n    if (!flag && vis[pos][one]) return dp[pos][one];\n    int u = flag ? bit[pos] : 9;\n    bigint ans;\n    for (int i = 0; i <= u; i++) {\n        int nxt;\n        if (flag && i == u) nxt = 1, ans = ans + g[pos - 1] * i;\n        else nxt = 0, ans = ans + base[pos] * i;\n        if (!i && one) ans = ans + dfs(pos - 1, 1, nxt);\n        else ans = ans - dfs(pos - 1, 0, nxt);\n    }\n    if (!flag) {\n        vis[pos][one] = 1;\n        dp[pos][one] = ans;\n    }\n    return ans;\n}\nbigint calc(char *s) {\n    int pos = strlen(s);\n    for (int i = 0; i < pos; i++) bit[pos - i - 1] = s[i] - '0';\n    bigint tmp;\n    tmp.a[1] = 1;\n    g[0].clear();\n    g[0].a[1] = bit[0];\n    g[0] = g[0] + tmp;\n    for (int i = 1; i < pos; i++) g[i] = g[i - 1] + base[i] * bit[i];\n    return dfs(pos - 1, 1, 1);\n}\nvoid solve() {\n    bigint R = calc(r);\n    bigint L = calc(l);\n    int pos = strlen(l);\n    int res = 0, k = 0;\n    for (int i = pos - 1; i >= 0; i--) {\n        if (!k) res += bit[i];\n        else res -= bit[i];\n        k ^= 1;\n    }\n    bigint tmp = toBigint(res);\n    tmp = R - L + tmp;\n    if (iszero(tmp)) {\n        puts(\"Error!\");\n        return ;\n    }\n    res = modd(tmp, 9);\n    if (res <= 0) res += 9;\n    int s = modd(tmp, res);\n    if (s < 0) s += res;\n    printf(\"%d\\n\", s);\n}\nint main () {\n    base[0].a[1] = 1;\n    for (int i = 1; i <= 100; i++) base[i] = base[i - 1] * 10;\n    int _;\n    cin>>_;\n    while(_--) {\n        scanf(\"%s%s\", l, r);\n        solve();\n    }\n    return 0;\n}\n```\n","tags":["大数"],"categories":["ACM"]},{"title":"HDU 5145 NPY and girls（区间查询+莫队算法）","url":"/2015/08/27/hdu5145/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5145\n\n# 题意\n有n个数，m个询问，每次询问区间[l,r]中数字全排列的个数\n\n# 思路\n首先区间全排列为：(r-l+1)! / (a1! * a2! ……) 其中ai为每种数的个数。\n假设已经知道当前区间[l,r]的值f, 那么[l,r+1]就是f * (r-l+2) / ai (其中ai为新加进来数的个数)。这里用莫队算法来进行维护\n\n莫队算法可以用nsqrt(n)的复杂度解决一切离线不修改的区间查询问题 [从(l,r)->(l+1,r)的递推复杂度必须为O(1)]\n算法参考：http://blog.csdn.net/huzecong/article/details/8576908\n          http://blog.csdn.net/bossup/article/details/39236275\n莫队算法可以把区间当做二维的点，然后求出曼哈顿最小生成树，之后从起点dfs出答案。\n但是上述代码比较复杂，另一种方式是把n分块，分成sqrt(n)块。然后把所有查询离线，然后先按照l属于的块号从小到大排序，如果两者在同一块，则按照r从小到大排序。之后遍历一遍得到答案\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e4 + 100;\nconst int mod = 1000000007;\nint n, m, B;\nint c[N], cnt[N], res[N];\nstruct node {\n    int l, r, id;\n}a[N];\nbool cmp(node s, node v) {\n    if (s.l / B == v.l / B) return s.r < v.r;\n    return s.l < v.l;\n}\nll inv[N];\nvoid init(int n) {\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n}\nint main () {\n    int t;\n    init(30000);\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", c + i);\n            cnt[c[i]] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &a[i].l, &a[i].r);\n            a[i].l--, a[i].r--;\n            a[i].id = i;\n        }\n        B = sqrt(n + 0.5);\n        sort(a, a + m, cmp);\n        int L = a[0].l, R = a[0].l - 1;\n        ll ans = 1;\n        for (int i = 0; i < m; i++) {\n            while(R < a[i].r) {\n                R++;\n                cnt[c[R]]++;\n                ans = ans * (R - L + 1) % mod;\n                ans = ans * inv[cnt[c[R]]] % mod;\n            }\n            while(R > a[i].r) {\n                ans = ans * inv[R - L + 1] % mod;\n                ans = ans * cnt[c[R]] % mod;\n                cnt[c[R]]--;\n                R--;\n            }\n            while(L > a[i].l) {\n                L--;\n                cnt[c[L]]++;\n                ans = ans * (R - L + 1) % mod;\n                ans = ans * inv[cnt[c[L]]] % mod;\n            }\n            while(L < a[i].l) {\n                ans = ans * inv[R - L + 1] % mod;\n                ans = ans * cnt[c[L]] % mod;\n                cnt[c[L]]--;\n                L++;\n            }\n            res[a[i].id] = ans;\n        }\n        for (int i = 0; i < m; i++) printf(\"%d\\n\", res[i]);\n    }\n    return 0;\n}\n```\n","tags":["莫队算法"],"categories":["ACM"]},{"title":"HDU 5144 NPY and shot（物理题 OR 三分）","url":"/2015/08/27/hdu5144/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5144\n\n# 题意\n给定一个高度H, 从H处抛出一个初速度为v的小球，问小球最远能到哪里。\n\n# 思路\n可以直接推公式\nvtcos(0) = s\nvtsin(0) = 0.5*g*t^2 - h\n把角度消去，得到一个关于t^2的二次方程，要是这个方程有解，判别式必须≥0。所以s = v * sqrt(2.0 * g * h + v * v) / g;\n\n也可以直接三分s（比三分角度精确）\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\ndouble g = 9.8;\nint main () {\n    int t;\n    cin>>t;\n    int h, v;\n    while(t--) {\n        scanf(\"%d%d\", &h, &v);\n        double s = v * sqrt(2.0 * g * h + v * v) / g;\n        printf(\"%.2f\\n\", s);\n    }\n    return 0;\n}\n```\n","tags":["枚举"],"categories":["ACM"]},{"title":"HYSBZ 1588 营业额统计（Splay树）","url":"/2015/08/27/HYSBZ1588/","content":"# 题目\t\n源地址：http://www.lydsy.com/JudgeOnline/problem.php?id=1588\n\n# 题意\n在n天里，每天读入一个数，规定这个数的贡献值为与之前所有数字之差的绝对值的最小值，第一个数的贡献值为它本身。求总的值\n\n# 思路\n这道题算是伸展树的入门题。题目数据有个bug（即可能数字个数小于n，如果小于n就把少的数字全部当做0）\n\n算法的参考资料：\nhttp://blog.csdn.net/acm_cxlove/article/details/7815019\nhttp://wenku.baidu.com/view/7f0ff024ccbff121dd3683ac.html\nhttp://www.cnblogs.com/kuangbin/archive/2012/10/07/2714068.html\nhttp://wenku.baidu.com/link?url=amATxXzsEjjYrr4xw7OnIht8Iv8J7tx-brB6cwpVKfvujPO4p0iOMI46TECbQ4catynY5nOrlRkf2ZGRroXfU2wpSHCnehQCBDq0TYp_ddy&qq-pf-to=pcqq.c2c\n\nsplay树的关键在于splay操作，每次插入一个节点后，都将该节点旋到根节点。均摊复杂度为O(logn)，可以避免普通二叉查找树在某些情况下退化成一条链\n这道题相当于每次插入一个数字后，找到其前驱和后继，比较两者与其的差即可。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nconst int N = 100005;\nconst int inf = 1e9;\nstruct SplayTree {\n    int pre[N], key[N], ch[N][2], root, cnt;  ///分别表示父结点，键值，左右孩子(0为左孩子，1为右孩子),根结点，结点数量\n\tvoid init() {\n\t\troot = cnt = 0;\n\t}\n\t///新建一个结点\n    void NewNode(int &r, int father, int k) {\n        r = ++cnt;\n        pre[r] = father;\n        key[r] = k;\n        ch[r][0] = ch[r][1] = 0;  ///左右孩子为空\n    }\n    ///旋转，kind为1为右旋，kind为0为左旋\n    void Rotate(int x, int kind) {\n        int y = pre[x];\n        ///类似SBT，要把其中一个分支先给父节点\n        ch[y][!kind] = ch[x][kind];\n        pre[ch[x][kind]] = y;\n        ///如果父节点不是根结点，则要和父节点的父节点连接起来\n        if(pre[y])\n            ch[pre[y]][ch[pre[y]][1] == y] = x;\n        pre[x] = pre[y];\n        ch[x][kind] = y;\n        pre[y] = x;\n    }\n\t///Splay调整，将根为r的子树调整为goal\n    void Splay(int r, int goal) {\n        while(pre[r]!=goal) {\n            ///父节点即是目标位置，goal为0表示，父节点就是根结点\n            if(pre[pre[r]] == goal)\n                Rotate(r, ch[pre[r]][0] == r);\n            else {\n                int y = pre[r];\n                int kind = ch[pre[y]][0] == y;\n                ///两个方向不同，则先左旋再右旋\n                if(ch[y][kind] == r) {\n                    Rotate(r, !kind);\n                    Rotate(r, kind);\n                }\n                ///两个方向相同，相同方向连续两次\n                else {\n                    Rotate(y, kind);\n                    Rotate(r, kind);\n                }\n            }\n        }\n        ///更新根结点\n        if(goal == 0) root = r;\n    }\n    int Insert(int k) {\n        int r = root;\n        while(ch[r][key[r] < k]) {\n            ///不重复插入\n            if(key[r] == k) {\n                Splay(r,0);\n                return 0;\n            }\n            r = ch[r][key[r] < k];\n        }\n        NewNode(ch[r][k > key[r]], r, k);\n        ///将新插入的结点更新至根结点\n        Splay(ch[r][k > key[r]], 0);\n        return 1;\n    }\n\t///找前驱，即左子树的最右结点\n    int get_pre(int x) {\n        int tmp = ch[x][0];\n        if(tmp == 0)  return inf;\n        while(ch[tmp][1])\n            tmp = ch[tmp][1];\n        return key[x] - key[tmp];\n    }\n    ///找后继，即右子树的最左结点\n    int get_next(int x) {\n        int tmp = ch[x][1];\n        if(tmp == 0)  return inf;\n        while(ch[tmp][0])\n            tmp = ch[tmp][0];\n        return key[tmp] - key[x];\n    }\n}sp;\nint n;\nint main() {\n    while(~scanf(\"%d\",&n)) {\n        sp.init();\n        int ans = 0;\n        for(int i = 0; i < n; i++) {\n            int num;\n            if(scanf(\"%d\",&num) == EOF) num = 0;\n            if(!i) {\n                ans += num;\n                sp.NewNode(sp.root, 0, num);\n                continue;\n            }\n            if (sp.Insert(num) == 0) continue;\n            int a = sp.get_next(sp.root);\n            int b = sp.get_pre(sp.root);\n            ans += min(a, b);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n","tags":["Splay"],"categories":["ACM"]},{"title":"HDU 5143 NPY and arithmetic progression（枚举+想法）","url":"/2015/08/27/hdu5143/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5143\n\n# 题意\n有1,2,3,4四种数字，个数分别为a1,a2,a3,a4。现在要把这些数分成很多组，其中每组都是等差数列，且每组的个数必须大于等于3。问有没有解\n\n# 思路\n观察可以发现等差数列只可能是(1,2,3)(1,2,3,4)(2,3,4)以及3个以上相同的数字。然后三个以上的(1,2,3)可以化为多个(1,1,1)(2,2,2)(3,3,3)和j个(1,2,3)。其中j≤2，其他的相同。所以可以枚举这三种特殊的等差数列的个数，剩下的1,2,3,4的个数≥3或者等于0一定可以。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nint x;\nint main () {\n    int t;\n    cin>>t;\n    while(t--) {\n        scanf(\"%d\", &x);\n        int m = 0;\n        while(x) {\n            m = m * 2 + x % 2;\n            x /= 2;\n        }\n        printf(\"%d\\n\", m);\n    }\n    return 0;\n}\n```\n","tags":["枚举"],"categories":["ACM"]},{"title":"HDU 5141 LIS again（LIS+dp+线段树）","url":"/2015/08/26/hdu5141/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5141\n\n# 题意\n有n个数的序列，另该序列的最长上升子序列的长度为k。求该序列中子串满足最长上升子序列长度也为k的个数。1≤n≤100000\n\n# 思路\n首先我们用线段树可以求出以第i位为结尾的最大长度。假如当前dp[i]=k, 如果可以求得以i结尾，符合条件的最短子串，那么用左边的长度 * 右边的长度就是符合条件的个数。当然，如果后面还有一个符合dp[i']=k, 那么右边只能到i'-1, 之后的在i'时在计算，可以避免重复\n可以用线段树维护以i结尾符合条件的lis最靠右的起始位置。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\n#define pii pair<int, int>\n#define mkp make_pair\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 100;\nint a[N], b[N], n, cnt;\nint f[N][2];\nint mx[N << 2], id[N << 2];\nint ans;\nvoid pushup(int rt) {\n    if (mx[rt << 1] < mx[rt << 1 | 1]) mx[rt] = mx[rt << 1 | 1], id[rt] = id[rt << 1 | 1];\n    else mx[rt] = mx[rt << 1], id[rt] = id[rt << 1];\n}\nvoid build(int l, int r, int rt) {\n    if (l == r) {\n        mx[rt] = id[rt] = 0;\n        return ;\n    }\n    int m = (l + r) >> 1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\npii query(int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        return mkp(mx[rt], id[rt]);\n    }\n    int m = (l + r) >> 1;\n    pii t1, t2;\n    t1.first = 0, t2.first = 0;\n    if (L <= m) t1 = query(L, R, lson);\n    if (R > m) t2 = query(L, R, rson);\n    if (t1.first < t2.first) return t2;\n    else return t1;\n}\nvoid update(int L, int R, int x, int y, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        mx[rt] = x, id[rt] = y;\n        return ;\n    }\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, x, y, lson);\n    if (R > m) update(L, R, x, y, rson);\n    pushup(rt);\n}\nint main () {\n    while(~scanf(\"%d\", &n)) {\n        for (int i = 0; i < n; i++) scanf(\"%d\", a + i), b[i] = a[i];\n        sort(b, b + n);\n        cnt = unique(b, b + n) - b;\n        ans = 0;\n        for (int i = 0; i < n; i++) a[i] = lower_bound(b, b + cnt, a[i]) - b + 1; //, cout<<a[i]<<endl;\n        build(1, cnt, 1);\n        //debug;\n        pii tmp;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == 1) tmp.first = 0;\n            else tmp = query(1, a[i] - 1, 1, cnt, 1);\n            if (tmp.first == 0) tmp.second = i + 1;\n            tmp.first++;\n            f[i][0] = tmp.first, f[i][1] = tmp.second;\n            ans = max(ans, tmp.first);\n            //cout<<f[i][0]<<\" \"<<f[i][1]<<endl;\n            update(a[i], a[i], tmp.first, tmp.second, 1, cnt, 1);\n        }\n        ll res = 0;\n        vector< pii > g;\n        for (int i = 0; i < n; i++) if (f[i][0] == ans) {\n            g.push_back(mkp(i + 1, f[i][1]));\n        }\n        g.push_back(mkp(n + 1, 0));\n        for (int i = 0; i < g.size() - 1; i++) {\n            res += (ll)(g[i + 1].first - g[i].first) * g[i].second;\n        }\n        printf(\"%I64d\\n\", res);\n    }\n    return 0;\n}\n```\n","tags":["LIS"],"categories":["ACM"]},{"title":"HDU 5110 Alexandra and COS（dp+分块）","url":"/2015/08/26/hdu5110/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5110\n\n# 题意\n有一张n*m的地图，其中一些格点上有宝藏。现在有一种探测器，只能够探测到其前方西北到东北距离为d的倍数的格点，定义该距离max(|x1-x|,|y1-y|)。现在给q个探测器，分别求出其能够探测到的宝石数量。1≤n,m,d≤1000,1≤q≤500000\n\n# 思路\n直接暴力的做时间复杂度为q*n*case, 会超时。\n需要用分块的方式来做。g[d][n][m]表示在(n,m)点，距离为d的数量。\n那么可以用右三角形-左三角形， 即g[d][x][y] = gr[d][x][y] - gl[d][x -1][y]\n当d比sqrt(n)小时，可以预处理出来复杂度为n*m*sqrt(n)，反之可以直接暴力算\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nint n, m, q, x, y, d, B;\nint a[1010][1010], sa[1010][33], gl[1010][1010], gr[1010][1010], g[33][1010][1010];\n//a[i][j]表示第i行的前j个和 sa[i][j]表示从i行其前i行间距为j的和\n//gl[i][j]表示以(i,j)为边界的左三角形和 gr表示右三角形和 两者相减为g\nchar ch;\nvoid work() {\n    int ans = 0;\n    for (int i = x; i > 0; i -= d) {\n        int L = max(1, y - x + i), R = min(m, y + x - i);\n        ans += a[i][R] - a[i][L - 1];\n    }\n    printf(\"%d\\n\", ans);\n}\nvoid solve() {\n    B = sqrt(0.5 + n);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= B; ++j) {\n            if (i < j) sa[i][j] = a[i][m];\n            else sa[i][j] = sa[i - j][j] + a[i][m];\n        }\n    for (int k = 1; k <= B; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                //gl\n                if (i <= k || j <= k) gl[i][j] = a[i][j];\n                else gl[i][j] = gl[i - k][j - k] + a[i][j];\n                //gr\n                if (i <= k) gr[i][j] = a[i][j];\n                else if (j + k > m) gr[i][j] = sa[i - k][k] + a[i][j];\n                else gr[i][j] = gr[i - k][j + k] + a[i][j];\n                //g\n                g[k][i][j] = gr[i][j] - gl[i][j - 1];\n            }\n        }\n    }\n}\nchar str[1111];\nint main() {\n    while(~scanf(\"%d%d%d\", &n, &m, &q)) {\n        for (int i = 1; i <= n; ++i) {\n            scanf(\"%s\", str + 1);\n            a[i][0] = 0;\n            for (int j = 1; j <= m; ++j) {\n                a[i][j] = a[i][j - 1];\n                if (str[j] == 'X') ++a[i][j];\n            }\n        }\n        solve();\n        while(q--) {\n            scanf(\"%d%d%d\", &x, &y, &d);\n            if (d > B) work();\n            else printf(\"%d\\n\", g[d][x][y]);\n        }\n    }\n    return 0;\n}\n```\n","tags":["dp"],"categories":["ACM"]},{"title":"HDU 5106 Bits Problem（数位dp）","url":"/2015/08/26/hdu5106/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5106\n\n# 题意\n给定一个二进制r，一个整数n，求[0, r)这个区间内满足其二进制中1的个数为n的数字和，答案对1e9+7取模\nn≤1000， 0≤R<2^1000\n\n# 思路\n如果只需要求满足的数的个数，只需要开dp[1000][1000]的数组，dp[pos][one]表示到pos位，1的个数为one的个数\n因为要记录总和，只需要再开一维sum[1000][1000]，sum[pos][one]表示这些所有数的和\n在状态转移的时候，sum就是 当前枚举的位所代表的数 * 之后的种类数 + 之后的和 的累加\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\n#define pii pair<ll, ll>\nll dp[1001][1001];\nll sum[1001][1001];\nll base[1001];\nint bit[1011], n;\nchar s[1011];\nconst int mod = 1000000007;\npii dfs(int pos, int one, bool flag) {\n    if (one > n) return {0, 0};\n    if (pos == -1) {\n        if (one == n) return {1, 0};\n        return {0, 0};\n    }\n    if (!flag && dp[pos][one] != -1) {\n        return {dp[pos][one], sum[pos][one]};\n    }\n    int u = flag ? bit[pos] : 1;\n    ll ans = 0, res = 0;\n    pii tmp;\n    for (int i = 0; i <= u; i++) {\n        tmp = dfs(pos - 1, one + i, i == u && flag);\n        ans = (ans + tmp.first) % mod;\n        res = (res + i * base[pos] * tmp.first + tmp.second) % mod;\n    }\n    if (!flag) dp[pos][one] = ans, sum[pos][one] = res;\n    return {ans, res};\n}\nint len;\nll calc() {\n    int pos = len;\n    int one = 0;\n    ll tmp = 0;\n    for (int i = 0; i < pos; i++) {\n        bit[i] = s[pos - i - 1] - '0';\n        if (bit[i]) one++;\n        tmp = (tmp * 2 + s[i] - '0') % mod;\n    }\n    if (one != n) tmp = 0;\n    return (dfs(pos - 1, 0, 1).se - tmp + mod) % mod;\n}\nvoid init() {\n    for (int i = 0; i <= len; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = -1;\n            sum[i][j] = 0;\n        }\n    }\n}\nint main () {\n    base[0] = 1;\n    for (int i = 1; i <= 1000; i++) base[i] = 2 * base[i - 1] % mod;\n    while(~scanf(\"%d%s\", &n, s)) {\n        len = strlen(s);\n        if (len < n) {\n            puts(\"0\");\n            continue;\n        }\n        init();\n        printf(\"%I64d\\n\", calc());\n    }\n    return 0;\n}\n```\n","tags":["数位dp"],"categories":["ACM"]},{"title":"HDU 5125 magic balls（LIS+dp+树状数组）","url":"/2015/08/26/hdu5125/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5125\n\n# 题意\n有两排球，每排有n个。每个球有一个体积vi。现在要从第一排中选一些球，使得这些球的体积为最长上升序列。你可以使用m次魔法，每次可以把第一排的一个球换成第二排对应位置的球。求最长的子序列长度。\n\n# 思路\n最长上升子序列可以用树状数组或者线段树维护。dp[i]表示以第i个数结尾的最长上升子序列长度。每加入一个新数，查询比该数小的数的dp最大值mx，用mx+1更新该数的dp值\n回到这道题，我们先对球的体积进行离散化。用dp[i][j]表示到i个位置，使用了j次交换的最值，那么有如下转移方程：\ndp[i][j] = max(dp[k][j] + 1) 其中k<i,且s[j][k]<a[i]\ndp[i][j] = max(dp[k][j - 1] + 1) 其中k<i,且s[j-1][k]<b[i]\n其中s[j]表示交换了j次时，需要维护的树状数组的情况\n这道题用线段树维护常数太大，容易T。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 1010;\nint a[N], b[N], c[N * 2], n, m, cnt;\nint bit[N][N * 2];\ninline int lowbit(int x) {\n    return x & (-x);\n}\nvoid add(int i, int p, int v) {\n    while(p <= cnt) {\n        bit[i][p] = max(bit[i][p], v);\n        p += lowbit(p);\n    }\n}\nint sum(int i, int p) {\n    int res = 0;\n    while(p > 0) {\n        res = max(res, bit[i][p]);\n        p -= lowbit(p);\n    }\n    return res;\n}\nint main () {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &m);\n        c[0] = 0;\n        cnt = 1;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d\", a + i, b + i);\n            c[cnt++] = a[i];\n            c[cnt++] = b[i];\n        }\n        sort(c, c + cnt); cnt = unique(c, c + cnt) - c;\n        for (int i = 0; i < n; i++) a[i] = lower_bound(c, c + cnt, a[i]) - c;\n        for (int i = 0; i < n; i++) b[i] = lower_bound(c, c + cnt, b[i]) - c;\n        for (int i = 0; i <= m; i++)\n            for (int j = 0; j <= cnt; j++) bit[i][j] = 0;\n        int mx = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = min(i + 1, m); j >= 0; j--) {\n                int k = sum(j, a[i] - 1) + 1;\n                mx = max(mx, k);\n                add(j, a[i], k);\n                if (j) {\n                    k = sum(j - 1, b[i] - 1) + 1;\n                    mx = max(mx, k);\n                    add(j, b[i], k);\n                }\n            }\n        printf(\"%d\\n\", mx);\n    }\n    return 0;\n}\n```\n","tags":["LIS"],"categories":["ACM"]},{"title":"ZOJ 3816 Generalized Palindromic Number（dp）","url":"/2015/08/25/zoj3816/","content":"# 题目\t\n源地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3816\n\n# 题意\n规定广义回文为：将字符串中相同的字符压缩为一个之后为回文串。例如：11233221->12321\n现在给定一个n，求小于n的最大一个数，使其为广义回文串。（1≤n≤1e18）\n\n# 思路\n从最后一位（最右位）开始改动，一直改动到第一位（第一位最小到1，不能到0）。如果改动某一位可以得到一个回文串，答案就是这个数字。\n现在假设改动到第k位：另dp[l][r]表示从第l位到第r位的符合回文的最大串\ndp[l][r] = max(前缀和 * base[r - L + 1] + dp[L][j] * base[r - j] + 后缀和) \n上述公式中：L为从l+1开始第一个与l不同的位，因为11121...的下一个状态直接转到21...(相同的1可以压缩)\nj从r-1一直到k, 即把(j+1, r)的位全部变为l位\n\n需要注意当r<=k时，此时dp[l][r]是已经确定的，我一开始直接判断该串是否为回文，但是这样不对。需要把右边和l-1相同的位全部压缩之后再判断。\n例如：3443，当k为3，第三位为3时，dp[2][3] = 43，即3433，此时3433是广义回文，但43不是。所以应该判断4是不是为回文。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<set>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nll n;\nint bit[22], len;\nll dp[22][22];\nvoid work(ll n) {\n    vector<int> g;\n    len = 0;\n    while(n) {\n        g.pb(n % 10);\n        n /= 10;\n    }\n    len = g.size();\n    reverse(g.begin(), g.end());\n    for (int i = 1; i <= len; i++) bit[i] = g[i - 1];\n}\nint k;\nll base[22];\nbool check(vector<int> g) {\n    int len = g.size();\n    for (int i = 0, j = len - 1; i < j; i++, j--) if (g[i] != g[j]) return false;\n    return true;\n}\nll dfs(int l, int r) {\n    if (dp[l][r] != -1) return dp[l][r];\n    if (l > k) { //l>k,此时(l,r)为9...9最大\n        dp[l][r] = base[r - l + 1] - 1;\n        return dp[l][r];\n    }\n    if (r <= k) { //r <= k，此时(l,r)串为已知串\n        vector<int> g;\n        ll ss = 0;\n        ss = ss * 10 + bit[l];\n        g.pb(bit[l]);\n        for (int i = l + 1; i <= r; i++) {\n            ss = ss * 10 + bit[i];\n        }\n        int R = r;\n        while(bit[R] == bit[l - 1] && l > 1) R--; //需要把右边的压缩\n        for (int i = l + 1; i <= R; i++) {\n            if (bit[i] != bit[i - 1]) g.pb(bit[i]);\n        }\n        if (check(g)) return dp[l][r] = ss; //如果压缩后为回文串，修改值\n        return -1;\n    }\n    int L;\n    for (L = l + 1; L <= k; L++) { //把L变为第一个不与l位相同的\n        if (bit[L] != bit[L - 1]) break;\n    }\n    if (L == k + 1) ;\n    else if (L == k) {\n        if (bit[L] == bit[L - 1]) L = k + 1;\n        else L = k;\n    }\n    ll mx = -1;\n    ll ans = 0;\n    for (int i = l; i < L; i++) ans = ans * 10 + bit[i]; //前缀和\n    ll tmp = 0;\n    for (int j = r - 1; j >= k; j--) {\n        tmp = tmp * 10 + bit[l]; //后缀和\n        ll res = dfs(L, j);\n        if (res != -1) mx = max(ans * base[r - L + 1] + res * base[r - j] + tmp, mx);\n    }\n    if (mx >= 0) dp[l][r] = mx;\n    return mx;\n}\nint main () {\n    int t;\n    scanf(\"%d\", &t);\n    base[0] = 1;\n    for (int i = 1; i <= 18; i++) base[i] = base[i - 1] * 10;\n    while(t--) {\n        scanf(\"%lld\", &n);\n        work(n);\n        bool flag = false;\n        for (int i = len; i >= 1; i--) {\n            int x = bit[i];\n            for (int j = x - 1; j >= (i == 1) ? 1 : 0; j--) {\n                k = i;\n                memset(dp, -1, sizeof(dp));\n                bit[i] = j;\n                dfs(1, len);\n                if (dp[1][len] != -1) {\n                    printf(\"%lld\\n\", dp[1][len]);\n                    flag = true;\n                    break;\n                }\n            }\n            bit[i] = x;\n            if (flag) break;\n        }\n        if (!flag) { //像100之类的数，上面的dp跑不出来，这里特别输出即可\n            printf(\"%lld\\n\", base[len - 1] - 1);\n        }\n    }\n    return 0;\n}\n```\n","tags":["dp"],"categories":["ACM"]},{"title":"ZOJ 3810 A Volcanic Island（构造 + 四色定理）","url":"/2015/08/25/zoj3810/","content":"# 题目\t\n源地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3810\n\n# 题意\n用 n 块面积为 n 的图块拼满一个 n*n 的矩阵图，并且 n 块图只有四种颜色，相邻的图块不能有相同的颜色，任意的两块不能有相同的形状，包括旋转，对称；\n\n# 思路\n当n≤4时，只有n=1可以构造\n当n≥5时一定有解。\n当n为5时：\n1 1 1 3 4\n1 3 3 3 4\n1 3 2 2 4\n2 2 2 1 4\n1 1 1 1 4\n当n为6时：\n1 1 1 1 3 4\n1 3 3 3 3 4\n1 3 1 1 1 4\n1 1 1 2 2 4\n2 2 2 2 1 4\n1 1 1 1 1 4\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nint a[105][105];\nvoid print(int n) {\n    for(int i=1; i<=n; i++) {\n        for(int j=1; j<=n; j++) {\n            switch(a[i][j]) {\n                case 1:\n                    putchar('R');\n                    break;\n                case 2:\n                    putchar('Y');\n                    break;\n                case 3:\n                    putchar('G');\n                    break;\n                case 4:\n                    putchar('B');\n                    break;\n            }\n        }\n        puts(\"\");\n    }\n}\nint go(int n) {\n    memset(a,0,sizeof(a));\n    for(int i=1; i<=n; i++) a[i][n]=4;\n    int color=2;\n    for(int k=1; k<=n/2; k++) {\n        int j;\n        if(color==1) color=2;\n        else color=1;\n        for(j=1;; j++) {\n            if(a[k][j])break;\n            a[k][j]=color;\n        }\n        for(j--; j<=n-1; j++)\n            a[k+1][j]=color;\n    }\n\n    for(int i=n/2+2; i<=n; i++)\n        a[i][n-1]=3;\n    for(int j=n-1; j>=0; j--) {\n        a[n/2+2][j]=3;\n        if(a[n/2+1][j]==0) {\n            a[n/2+1][j]=3;\n            break;\n        }\n    }\n    for(int i=n/2+1; i<=n; i++) {\n        if(a[i][1])break;\n        if(color==1)color=2;\n        else color=1;\n        int j=1;\n        for(; j<=n-2; j++) {\n            if(a[i][j])break;\n            a[i][j]=color;\n        }\n        j--;\n        int k=i;\n        for(; k<=n; k++) {\n            if(a[k][j+1]==0)break;\n            a[k][j]=color;\n        }\n        for(; j<=n-2; j++)\n            a[k][j]=color;\n\n    }\n}\nint main() {\n    int T_T;\n    scanf(\"%d\",&T_T);\n    while(T_T--) {\n        int n;\n        scanf(\"%d\",&n);\n        if(n<=4) {\n            if(n==1) puts(\"Y\");\n            else puts(\"No solution!\");\n            continue;\n        }\n        go(n);\n        print(n);\n    }\n    return 0;\n}\n```\n","tags":["四色定理"],"categories":["ACM"]},{"title":"ZOJ 3811 Untrusted Patrol（想法）","url":"/2015/08/25/zoj3811/","content":"# 题目\t\n源地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3811\n\n# 题意\n有n个点，m条无向边。给出k个能够记录的点，会记录第一次经过该点的时间。现在有L个点，保证这些点都是能够记录的点，且是按照时间从小到大排序的。问根据这些记录能否判断一个人有没有可能已经访问过所有的点。\n\n# 思路\n首先可以知道当L != K 时一定为no。\n1. 先把第一个访问到的记录点、以及它能够走到的所有非记录的点标记为已访问过。\n2. 接下来每碰到一个新的访问点，只需要看与它相连的点是否有被访问过，如果有则该点一定可以到达。然后再1的方式往访问过的集合里添加新点。\n3. 最后需要判断是否所有的点都被访问过。\n\n<!--more-->\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<set>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 100;\nvector<int> g[N];\nint t, n, m, k, l, has[N], is[N];\nvoid dfs(int u) {\n    has[u] = 1;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (!has[v] && !is[v]) dfs(v);\n    }\n}\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d%d\", &n, &m, &k);\n        for (int i = 1; i <= n; i++) g[i].clear(), has[i] = is[i] = 0;\n        int u, v;\n        for (int i = 0; i < k; i++) scanf(\"%d\", &u), is[u] = 1;\n        while(m--) {\n            scanf(\"%d%d\", &u, &v);\n            g[u].pb(v); g[v].pb(u);\n        }\n        scanf(\"%d\", &l);\n        bool flag = true;\n        if (l != k) {\n            flag = false;\n        }\n        scanf(\"%d\", &u);\n        dfs(u);\n        l--;\n        while(l--) {\n            scanf(\"%d\", &u);\n            if (!flag) continue;\n            int s = 0;\n            for (int i = 0; i < g[u].size(); i++) {\n                v = g[u][i];\n                if (has[v]) {\n                    s = 1;\n                    break;\n                }\n            }\n            if (!s) flag = false;\n            else dfs(u);\n        }\n        if (flag) {\n            int s = 0;\n            for (int i = 1; i <= n; i++) if (has[i]) s++;\n            if (s == n) puts(\"Yes\");\n            else puts(\"No\");\n        }\n        else puts(\"No\");\n    }\n    return 0;\n}\n```\n","tags":["想法"],"categories":["ACM"]},{"title":"HDU 5103 RootedTree（状压dp, 树dp）","url":"/2015/08/19/hdu5103/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5103\n\n# 题意\n有一棵树，给定n个节点，问有多少颗有根树，使得每个子树都满足以下条件：子树的根为i，子树上的点数为ti，li<=ti<=ri\n\n# 思路\ndp[i][S] 表示以i为根节点，拥有孩子S（二进制数状态的方案数 \nsub[S] 表示S状态下森林的方案数\nsum[S] 表示S状态的有根树的方案数\n\n可以知道\ndp[i][S] = sub[ S^(1<<i) ] {L[i]<=|S|<=R[i]}\nsum[S] = dp[i][S] { i=0,1,2,3,,,n-1 | S&1<<i!=0  }\nsub[S] = sub[S] +  sum[H]*sub[S^H]{ H为s的子集 ，这里有可能会计算重复，所以先固定S中的某一个点一定在H中，这样可以避免重复计算}\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nll dp[15][1 << 15], sum[1 << 15], sub[1 << 15];\nint l[15], r[15], n;\nint cal(int s) {\n    int res = 0;\n    for (int i = 0; i < n; i++) if (s >> i & 1) res++;\n    return res;\n}\nint main () {\n    int _;\n    scanf(\"%d\", &_);\n    while(_--) {\n        scanf(\"%d\", &n);\n        sub[0] = sum[0] = 1;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d\", l + i, r + i);\n            dp[i][0] = 1;\n        }\n        int tot = (1 << n);\n        for (int s = 1; s < tot; s++) {\n            sum[s] = sub[s] = 0;\n            int cnt = cal(s);\n            for (int i = 0; i < n; i++) {\n                dp[i][s] = 0;\n                if ((s >> i & 1) && l[i] <= cnt && cnt <= r[i]) {\n                    dp[i][s] = sub[s ^ (1 << i)];\n                    sum[s] = (sum[s] + dp[i][s]) % mod;\n                }\n            }\n            int j = 0;\n            for (j = 0; j < n; j++) if (s >> j & 1) break;\n            for (int left = s; left; left = (left - 1) & s) {\n                if (!(left >> j & 1)) continue;\n                sub[s] = (sub[s] + (sum[left] * sub[s ^ left]) % mod) % mod;\n            }\n        }\n        printf(\"%I64d\\n\", sum[tot - 1]);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14564193  2015-08-19 00:21:01 Accepted    5103    327MS   3680K   1526 B  G++ SIO__Five","tags":["状压dp"],"categories":["ACM"]},{"title":"HDU 5067 Harry And Dig Machine（状压dp）","url":"/2015/08/18/hdu5067/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5067\n\n# 题意\n有n*m的格点，其中有一些点有东西（不超过10个点）。现在需要从左上角出发，每次只能朝相邻的方向走，问把所有的东西都拿到，然后回到起点的最小时间。\n\n# 思路\n状压dp：dp[i][j]为走过i中所有点（i为二进制），且当前在j这个点的最小值。dp[i | 1 << k][k] = (dp[i][j] + dist[j][k]) 其中k为之前没有走过的点\n这道题由于数据比较小，用next_permutation也能过。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nint n, m, cnt;\npair<int, int> s[12];\nint dp[2000][12];\nint get(pair<int, int> x, pair<int, int> y) {\n    return abs(x.fi - y.fi) + abs(x.se - y.se);\n}\nint main () {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        cnt = 0;\n        int u;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                scanf(\"%d\", &u);\n                if (u) s[cnt++] = make_pair(i, j);\n            }\n        memset(dp, -1, sizeof(dp));\n        dp[0][0] = 0;\n        int tot = 1 << cnt;\n        for (int i = 0; i < tot; i++) {\n            for (int j = 0; j < cnt; j++) {\n                if (!i) dp[i | (1 << j)][j] = get(s[j], {0, 0});\n                else {\n                    if (!(i >> j & 1)) continue;\n                    if (dp[i][j] != -1) {\n                        for (int k = 0; k < cnt; k++) if (!(i >> k & 1)) {\n                            int st = i | (1 << k);\n                            if (dp[st][k] == -1) dp[st][k] = dp[i][j] + get(s[j], s[k]);\n                            else dp[st][k] = min(dp[st][k], dp[i][j] + get(s[j], s[k]));\n                        }\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i < cnt; i++) {\n            ans = min(ans, dp[tot - 1][i] + get(s[i], {0, 0}));\n        }\n        if (cnt == 0) ans = 0;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14562788\t2015-08-18 21:47:01\tAccepted\t5067\t0MS\t1656K\t1379 B\tG++\tSIO__Five","tags":["状压dp"],"categories":["ACM"]},{"title":"HDU 5058 Harry And Math Teacher（dp+矩阵+线段树）","url":"/2015/08/18/hdu5058/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5058\n\n# 题意\n有n层楼，每一层有两扇门。从第i层楼到第i+1层楼有4条路，即从i层的每扇门到i+1层的每扇门都有一条路。现在有两种操作，一种是将第i层到第i+1层的某条路给干掉（或者重新修好）。另一种是询问从第i层到第j层有多少不同的路。\n\n# 思路\n假设到第i层的第一扇门为dp[i][1]种，第二扇们有dp[i][2]中。那么\ndp[i + 1][1] = a1 * dp[i][1] + a2 * dp[i][2]\ndp[i + 1][2] = b1 * dp[i][2] + b2 * dp[i][2]\n所以就相当于从第i层到第i+1层只需要乘以一个转换矩阵即可。而一开始转换矩阵中元素都为1。当有一条路被干掉则变为0\n于是这道题就变成线段树维护矩阵乘积，单点更新，区间求乘积\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nusing namespace std;\ntypedef long long ll;\nint n, m;\nconst int N = 50000 + 100;\nconst ll mod = 1000000007;\nstruct node {\n    ll a[2][2];\n    void clr() {\n        memset(a, 0, sizeof(a));\n    }\n    void uni() {\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < 2; j++) a[i][j] = 1;\n    }\n    void one() {\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) a[i][j] = 0;\n            a[i][i] = 1;\n        }\n    }\n    void out() {\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) cout<<a[i][j]<<\" \";\n            cout<<endl;\n        }\n    }\n    ll get() {\n        ll ans = 0;\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < 2; j++) ans += a[i][j], ans %= mod;\n        return ans;\n    }\n    node operator * (const node & T) {\n        node tmp;\n        memset(tmp.a, 0, sizeof(tmp.a));\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < 2; j++)\n                for (int k = 0; k < 2; k++)\n                    tmp.a[i][j] += a[i][k] * T.a[k][j], tmp.a[i][j] %= mod;\n        return tmp;\n    }\n}mul[N << 2], tmp;\nvoid pushup(int rt) {\n    mul[rt].clr();\n    mul[rt] = mul[rt << 1] * mul[rt << 1 | 1];\n}\nvoid build(int l, int r, int rt) {\n    if (l == r) {\n        mul[rt].uni();\n        return ;\n    }\n    int m = (l + r) >> 1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\nvoid update(int L, int R, int y, int z, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        mul[rt].a[y][z] ^= 1;\n        //mul[rt].out();\n        return ;\n    }\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, y, z, lson);\n    if (R > m) update(L, R, y, z, rson);\n    pushup(rt);\n}\nnode query(int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        return mul[rt];\n    }\n    int m = (l + r) >> 1;\n    node ret;\n    ret.one();\n    if (L <= m) ret = ret * query(L, R, lson);\n    if (R > m) ret = ret * query(L, R, rson);\n    return ret;\n}\nint main () {\n    int op, a, b, x, y, z;\n    while(~scanf(\"%d%d\", &n, &m)) {\n        n--;\n        build(1, n, 1);\n        while(m--) {\n            scanf(\"%d\", &op);\n            if (op == 0) {\n                scanf(\"%d%d\", &a, &b);\n                tmp = query(a, b - 1, 1, n, 1);\n                printf(\"%I64d\\n\", tmp.get());\n            } else {\n                scanf(\"%d%d%d\", &x, &y, &z);\n                if (y == 1 && z == 1) y = 0, z = 0;\n                else if (y == 1 && z == 2) y = 0, z = 1;\n                else if (y == 2 && z == 1) y = 1, z = 0;\n                else y = 1, z = 1;\n                update(x, x, y, z, 1, n, 1);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14562794  2015-08-18 21:47:28 Accepted    5068    795MS   5688K   2508 B  G++ SIO__Five","tags":["矩阵"],"categories":["ACM"]},{"title":"HDU 5060 War（计算几何）","url":"/2015/08/18/hdu5060/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5060\n\n# 题意\n有一个球A：x^2+y^2+z^2 <= r^2 以及一个圆柱体B：x^2+y^2 <= hr^2 且 |z|<=hz\n定义VC为两者相交的体积，VU为两者的体积并。求VC/VU\n\n# 思路\n球冠体积：一个球被一个截面所截，其中截面距离球心的距离l。则球冠体积为：π*h*h*(r-h/3) 其中h=r-l\n\n这道题先求出VC，然后VU=A+B-VC。VC的求法有5种情况\n1. hr >= r && hz >= r （球在圆柱体内）\n2. hr >= r && hz < r （球被圆柱体的两个底面分别截去一个球冠）\n3. hr < r && hr * hr + hz * hz <= r * r （圆柱体在球内）\n4. hr < r && hz >= r （圆柱体的圆半径小于球半径，但是圆柱体的长度大于球的长度）\n5. （圆柱体的圆半径小于球半径，但是圆柱体的长度小于球的长度）\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define PI cos(-1.0)\n#define debug puts(\"=====================\");\nusing namespace std;\ndouble r, hr, hz;\ndouble vc, vu;\n\ndouble s(double l) {\n    double h = r - l;\n    return PI * h * h * (r - h / 3);\n}\nint main () {\n    while(~scanf(\"%lf%lf%lf\", &r, &hr, &hz)) {\n        double sq = 4.0 / 3 * PI * r * r * r;\n        double sz = PI * hr * hr * 2 * hz;\n        if (hr >= r && hz >= r) {\n            vc = sq;\n            vu = sz;\n        }\n        else if (hr >= r && hz < r) {\n            vc = sq - 2 * s(hz);\n            vu = sz + sq - vc;\n        }\n        else if (hr < r && hr * hr + hz * hz <= r * r) {\n            vc = sz;\n            vu = sq;\n        }\n        else if (hr < r && hz >= r) {\n            double hz1 = sqrt(r * r - hr * hr);\n            vc = PI * hr * hr * 2 * hz1 + 2 * s(hz1);\n            vu = sz + sq - vc;\n        } else {\n            double hz1 = sqrt(r * r - hr * hr);\n            vc = PI * hr * hr * 2 * hz1 + 2 * s(hz1) - 2 * s(hz);\n            vu = sz + sq - vc;\n        }\n        printf(\"%.6lf\\n\", vc / vu);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14562534  2015-08-18 21:30:17 Accepted    5060    2340MS  1596K   1056 B  G++ SIO__Five","tags":["球冠体积"],"categories":["ACM"]},{"title":"HDU 5102 The K-th Distance（想法）","url":"/2015/08/17/hdu5102/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5067\n\n# 题意\n有一棵树n个节点，每条边都为1。现在把每两个点之间的距离放在一起，按照从大到小排列。问前k个的和为多少？保证k小于等于min(1e6, n*(n-1)/2)\n\n# 思路\n把所有边(u,v)以及(v,u)放入队列，队列每弹出一个元素(u,v)，对于所有与v相邻的点w，如果w≠u，就把(v,w)入队，这样就能一个一个生成前K小的距离。 注意到每条边实际上会入队两次，只要把K翻倍且把ans除以2即可，时间复杂度为O(n+K)\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define pb push_back\n#define INF 1 << 30\n#define fi first\n#define se second\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 100;\nconst int M = 1e6 + 100;\nint n, k, m;\nvector<int> g[N];\nstruct node {\n    int u, v, l;\n}tmp;\nnode q[M * 2];\nint main () {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &k);\n        for (int i = 1; i <= n; i++) g[i].clear();\n        int u, v, l;\n        k *= 2;\n        int st = 0, ed = 0;\n        ll ans = 0;\n        for (int i = 1; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            g[u].pb(v);\n            g[v].pb(u);\n            if (ed < k) q[ed++] = {u, v, 1}, ans++;\n            if (ed < k) q[ed++] = {v, u, 1}, ans++;\n        }\n        while(ed < k) {\n            tmp = q[st++];\n            u = tmp.u, v = tmp.v, l = tmp.l;\n            for (int i = 0; i < g[v].size(); i++) if (g[v][i] != u && ed < k){\n                q[ed++] = {v, g[v][i], l + 1};\n                ans += l + 1;\n            }\n        }\n        printf(\"%I64d\\n\", ans / 2);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14550969  2015-08-17 22:24:35 Accepted    5102    920MS   31204K  1099 B  G++ SIO__Five","tags":["想法"],"categories":["ACM"]},{"title":"HDU 4986 Little Pony and Alohomora Part I（递推+调和级数）","url":"/2015/08/16/hdu4986/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4986\n\n# 题意\n有n个盒子，每个盒子都有唯一一把钥匙可以打开它。现在将钥匙随机放在盒子里，问最少需要撬开几个盒子才能打开所有的盒子，求期望。其实就是求随机排列的期望循环个数。\n\n# 思路\n递推：假设f[n]为打开n个盒子的期望，当多了一个盒子时，如果该盒子装的是自己的钥匙，则需要多撬一次。如果装的是其他盒子的钥匙，相当于之前有一个循环多了一个数，但是次数不变。所以f[n+1] = (f[n]+1 + f[n]*n)/(n+1) = 1/(n+1) + f[n]。而f[1] = 1\n这是数列为调和级数：当n很大的时候为log2(n+1) + 0.57721566490153286060651209(欧拉常数)\n\n一个数位于循环长度为k的概率为1/n(与k无关) 证明如下：\n![](http://siofive.qiniudn.com/hdu4986.png)\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\ndouble a[200000 + 100];\n#define euler 0.57721566490153286060651209\nint main () {\n\tdouble ans = 0;\n\tfor (int i = 1; i <= 200000; i++) {\n\t\tans += 1.0 / i;\n\t\ta[i] = ans;\n\t}\n\tint n;\n\twhile(~scanf(\"%d\", &n)) {\n\t\tif (n <= 200000) printf(\"%.4f\\n\", a[n]);\n\t\telse printf(\"%.4f\\n\", log(n) + euler);\n\t}\n    return 0;\n}\n```\n\n# 更新日志\n- 14534921\t2015-08-16 17:59:18\tAccepted\t4986\t0MS\t3140K\t565 B\tG++\tSIO__Five","tags":["置换"],"categories":["ACM"]},{"title":"Codeforces 55D Beautiful numbers（数位DP）","url":"/2015/08/16/CF55D/","content":"# 题目\t\n源地址：http://codeforces.com/problemset/problem/55/D\n\n# 题意\n给定一个数字n，如果n能被它数位上的每一个非零数字整除，这个数就被称为Beautiful number。为给定区间[l, r]内有多少个Beautiful numbers。其中1≤l≤r≤9*1e18\n\n# 思路\n一个数能被其所有数位上的非零数字整除，即被他们的最小公倍数整除，而1~9的lcm为2520。所以数位dp时只需要保存前面那些位的最小公倍数即可，到边界就把所有位的lcm求出了，为了判断这个数能不能被lcm整除，还需要保存这个数的值，显然记录是不行的。其实只要记录这个数模2520即可。这样可以设计如下dp：dfs(pos,mod,lcm,f)。pos为当前位，mod为模2520的值，lcm为最小公倍数，f表示前面是否达到上限。但其实1~9的所有最小公倍数只有48个。这样开dp[20][2520][48]的数组即可。\n\n<!--more-->\n\n# 代码\n标称\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nconst int mod = 2520;\nll dp[20][mod][48];\nll l, r;\nint num[mod + 10], cnt, t, bit[20];\nvoid init() {\n\tfor (int i = 1; i <= mod; i++) if (mod % i == 0) {\n\t\tnum[i] = cnt++;\n\t}\n}\nint gcd(int x, int y) {\n\tif (!y) return x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y) * y;\n}\nll dfs(int pos, int pre, int prelcm, bool flag) {\n\tif (pos == -1) return (pre % prelcm == 0);\n\tll ret = dp[pos][pre][num[prelcm]];\n\tif (!flag && ret != -1) return ret;\n\tint u = flag ? bit[pos] : 9;\n\tret = 0;\n\tfor (int i = 0; i <= u; i++) {\n\t\tint now = (pre * 10 + i) % mod;\n\t\tint nowlcm = prelcm;\n\t\tif (i) nowlcm = lcm(prelcm, i);\n\t\tret += dfs(pos - 1, now, nowlcm, (i == u ? 1 : 0) && flag);\n\t}\n\tif (!flag) dp[pos][pre][num[prelcm]] = ret;\n\treturn ret;\n}\nll calc(ll x) {\n\tint pos = 0;\n\twhile(x) {\n\t\tbit[pos++] = x % 10;\n\t\tx /= 10;\n\t}\n\treturn dfs(pos - 1, 0, 1, 1);\n}\nint main () {\n\tinit();\n\tmemset(dp, -1, sizeof(dp));\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%I64d%I64d\", &l, &r);\n\t\tprintf(\"%I64d\\n\", calc(r) - calc(l - 1));\n\t}\n\treturn 0;\n}\n```\n\n","tags":["数位dp"],"categories":["ACM"]},{"title":"HDU 5057 Argestes and Sequence（树状数组+离线 OR 分块）","url":"/2015/08/08/hdu5057/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5057\n\n# 题意\n有n个数，m个询问。每个询问有两种操作，一个改变某一个数，即a[x]=y。还有一个是询问[l,r]区间内从右往左第d位为p的数字个数。\n1≤n,m≤1e5, 0≤a[i]≤2^31 - 1, 1<=D<=10, 0<=P<=9\n\n# 思路\n第一眼想法是给每一位每一个数字种一棵树状数组。这样需要开dp[10][10][100000]，然而这道题比较变态，会爆内存。（可以用char + unsigned short 来表示。刚好可以卡过。。）\n\n比较好的方式是分块：\n分成400块，每块256个数。block[i][j][x]表示x块内第i为为p的数字总数。\n当修改一个数的时候，O(1)的修改块内统计信息即可。\n当查询一个区间时，如果在区间在同一个块，直接找一遍。如果不在同一个块内，则单独跑左右两块，然后中间整块的直接相加。复杂度为O(sqrt(n))\n\n还有一个用时间换空间的方式：\n由于开不了3维的数组，那么我们开2维的数组，然后对每一位都算一遍所有的操作。\n即把所有的操作离线下来，然后对每一位进行一次操作。不过在每次操作之前需要把数变为一开始的数。\n\n<!--more-->\n\n# 代码\n分块\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nint block[400][11][10]; //400 blocks, each 256\nint dig[100100][11];\nint t, n, m, l, r, d, p;\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &m);\n        memset(block, 0, sizeof(block));\n        int u;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", &u);\n            int x = i >> 8;\n            for (int j = 1; j <= 10; j++) {\n                ++block[x][j][dig[i][j] = u % 10];\n                u /= 10;\n            }\n        }\n        char ch;\n        while(m--) {\n            ch = getchar();\n            while(ch != 'S' && ch != 'Q') ch = getchar();\n            if (ch == 'S') {\n                scanf(\"%d%d\", &l, &r);\n                int x = l >> 8;\n                for (int j = 1; j <= 10; j++) {\n                    --block[x][j][dig[l][j]];\n                    ++block[x][j][dig[l][j] = r % 10];\n                    r /= 10;\n                }\n            } else {\n                scanf(\"%d%d%d%d\", &l, &r, &d, &p);\n                int bl = ((l - 1) >> 8) + 1, br = r >> 8, ans = 0;\n                if (bl <= br) {\n                    int bls = bl << 8, brs = br << 8;\n                    for (int i = l; i < bls; i++) ans += (dig[i][d] == p);\n                    for (int i = brs; i <= r; i++) ans += (dig[i][d] == p);\n                    for (int i = bl; i < br; i++) ans += block[i][d][p];\n                } else {\n                    for (int i = l; i <= r; i++) ans += (dig[i][d] == p);\n                }\n                printf(\"%d\\n\", ans);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n树状数组+离线\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nconst int N = 1e5 + 10;\nint t, n, m;\nint a[10][N];\nint b[N], c[N], ans[N];\nstruct node {\n\tint op;\n\tint l, r, d, p;\n}p[N];\nint lowbit(int x) {\n    return x & -x;\n}\nvoid add(int p, int dig, int v) {\n\twhile(p <= n) {\n\t\ta[dig][p] += v;\n\t\tp += lowbit(p);\n\t}\n}\nint get(int p, int dig) {\n\tint res = 0;\n\twhile(p) {\n\t\tres += a[dig][p];\n\t\tp -= lowbit(p);\n\t}\n\treturn res;\n}\nvoid clr() {\n\tfor (int i = 0; i < 10; i++)\n\t\tfor (int j = 0; j <= n; j++) a[i][j] = 0;\n}\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &m);\n        int u;\n        for (int i = 1; i <= n; i++) scanf(\"%d\", b + i), c[i] = b[i];\n        char ch;\n        for (int i = 0; i < m; i++) {\n\t\t\tch = getchar();\n\t\t\twhile(ch != 'S' && ch != 'Q') ch = getchar();\n            if (ch == 'Q') {\n\t\t\t\tp[i].op = 1;\n                scanf(\"%d%d%d%d\", &p[i].l, &p[i].r, &p[i].d, &p[i].p);\n                p[i].d--;\n            } else {\n            \tp[i].op = 0;\n                scanf(\"%d%d\", &p[i].l, &p[i].r);\n            }\n        }\n        int now = 1;\n        for (int i = 0; i < 10; i++) {\n\t\t\tclr();\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tb[j] = c[j];\n\t\t\t\tadd(j, (b[j] / now) % 10, 1);\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (p[j].op == 1) {\n\t\t\t\t\tif (p[j].d != i) continue;\n\t\t\t\t\tans[j] = get(p[j].r, p[j].p) - get(p[j].l - 1, p[j].p);\n\t\t\t\t} else {\n\t\t\t\t\tint x = (b[p[j].l] / now) % 10;\n\t\t\t\t\tadd(p[j].l, x, -1);\n\t\t\t\t\tx = (p[j].r / now) % 10;\n\t\t\t\t\tadd(p[j].l, x, 1);\n\t\t\t\t\tb[p[j].l] = p[j].r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow *= 10;\n        }\n        for (int i = 0; i < m; i++) if (p[i].op) printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14402325\t2015-08-07 23:47:34\tAccepted\t5057\t904MS\t6060K\t1808 B\tG++\tSIO__Five 分块\n- 14402693\t2015-08-08 01:01:00\tAccepted\t5057\t967MS\t8624K\t1894 B\tG++\tSIO__Five 树状数组+离线","tags":["离线"],"categories":["ACM"]},{"title":"HDU 4994 Revenge of Nim（博弈）","url":"/2015/08/04/hdu4994/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4994\n\n# 题意\n有n堆石头，从左往右排列，每堆石头有ai个石头（ai>0)。现在两个人轮流取石头，规定每次只能从最左边的一堆取若干个（可以取完，最少取一个）。问先手赢还是输？\n\n# 思路\n假设当前堆的石头个数大于1，那么这个人必赢。因为除了这堆、剩下的如果为必败态，那么可以将这堆取完，让对手面临必败态，反之，可以取到只剩下一个，然后让对手取一个石头，自己面临必胜态。注意有可能全是1的情况\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nint t, n, a[1111];\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d\", &n);\n        int x = 1111;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", a + i);\n            if (a[i] != 1) x = min(i, x);\n        }\n        if (x == 1111) {\n            if (n % 2) puts(\"Yes\");\n            else puts(\"No\");\n        }\n        else if (x % 2) puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14346124  2015-08-04 21:34:58 Accepted    4994    15MS    1576K   569 B   G++ SIO__Five","tags":["博弈"],"categories":["ACM"]},{"title":"HDU 5303 Delicious Apples（贪心+背包）","url":"/2015/07/31/hdu5303/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5303\n\n# 题意\n有一个长度为L的圆形场地，有n种苹果树，每种苹果树距离原点距离为xi，有ai个苹果。现在有人从原点开始摘苹果，篮子最多装k个苹果，且每次摘完之后必须回到原点才能清空篮子。问他最少需要走多少距离。\n保证总的苹果小于等于10^5\n\n# 思路\n如果从中点断开，把圆分成两半，则两边的贪心取，然后折道返回，可以得到解。但是这不是最优解，有可能最后剩下一些苹果，一次性绕一个圆形取完。可以发现，最多只能绕一圈。但是发现这个结论之后，还是不好处理。一个巧妙的想法是：\n把每一个苹果当做一个点，分成左右两部分，然后分别处理。举左边一半为例，以sum[i]表示把前i个苹果全部取回的最小代价，则有：\nsum[i] = d[i](i <= k)\nsum[i] = sum[i - k] + d[i](i > k)\n之后枚举需要走一圈摘的苹果（可以发现这些苹果一定是离原点最远的k个点）\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nint t, n, k, m, l;\nconst int N = 1e5 + 10;\nvector<int> a, b;\nll s1[N], s2[N];\nvoid work(vector<int> &a, ll * s) {\n    for (int i = 0; i < a.size(); i++) {\n        if (i < k) s[i + 1] = a[i];\n        else s[i + 1] = s[i + 1 - k] + a[i];\n    }\n}\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d%d\", &l, &n, &k);\n        int u, v;\n        a.clear();\n        b.clear();\n        m = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            m += v;\n            if (u > l / 2) {\n                u = l - u;\n                while(v--) b.pb(u);\n            } else while(v--) a.pb(u);\n        }\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n        work(a, s1);\n        work(b, s2);\n        ll ans = s1[a.size()] * 2 + s2[b.size()] * 2;\n        if (m <= k) ans = min(ans, (ll)l);\n        else {\n            for (int i = 0; i < a.size() && i <= k; i++) {\n                ll res = s1[a.size() - i] * 2 + s2[b.size() - (k - i)] * 2 + l;\n                ans = min(ans, res);\n            }\n        }\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14277804  2015-07-31 17:14:30 Accepted    5303    889MS   3308K   1345 B  G++ SIO__Five","tags":["背包"],"categories":["ACM"]},{"title":"HDU 5301 Buildings（数学, 想法）","url":"/2015/07/29/hdu5301/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5301\n\n# 题意\n有n*m的矩形，其中在(x,y)位置有一个坏的1*1的矩形不能用，现在问要将该矩阵用其他小矩阵填满，且这些小矩阵至少要和大矩阵的四条边中的一条边有一些公共部分。现在要是这些小矩形中最大的面积最小，求该面积。\n\n# 思路\n首先如果没有坏的矩形，假设最后分得的矩形为a*b，那么一定还可以继续分为1*b或者1*a的形式，答案一定为min(n + 1, m + 1)/2。\n现在加入了一个坏的矩形，如下图所示：\n![](http://siofive.qiniudn.com/hdu5301.png)\n其中up和down都不包括小矩形，而left和right都包括该小矩形。\n假设不考虑坏矩形，答案应该为ans=(n+1)/2\n考虑坏矩形，如果min(left, right) <= ans, 那么左半边或者右边边直接用n*min(left, right)划分，另一边则还按照原先的划分。\n如果min(left,right) > ans，那么就应该用min(max(up, down), min(left, right))中的来划分。（这里还要注意如果up==down的话，最小值还是ans）\n最后有一个trick：如果n==m && x == y && 2 * x + 1 == n 那么答案应该为 n/2\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nint n, m, x, y;\nint main () {\n    while(~scanf(\"%d%d%d%d\", &n, &m, &x, &y)) {\n        if (n > m) swap(n, m), swap(x, y);\n        int t = (n + 1) / 2;\n        int up = x - 1;\n        int dw = n - x;\n        int lf = y;\n        int rg = m - y + 1;\n        if (min(lf, rg) > t && up != dw) t = min(max(up, dw), min(lf, rg));\n        if ((n == m) && (n % 2 == 1) && (x == y) && (x * 2 - 1 == n)) t = n / 2;\n        printf(\"%d\\n\", t);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14246606  2015-07-29 21:59:37 Accepted    5301    15MS    1564K   625 B   G++ SIO__Five","tags":["想法"],"categories":["ACM"]},{"title":"HDU 5305 Friends（搜索）","url":"/2015/07/29/hdu5305/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5305\n\n# 题意\n有n个人，如果两两之间是朋友，这种友情有两种性质，一是离线朋友，二是在线朋友。现在有m个朋友关系，问每一个人的离线朋友和在线朋友数相等的情况数。\n其中1≤n≤8,0≤m≤n*(n-1)/2\n\n# 思路\n我的想法是：这个图会有很多个联通块，所以对于每一个联通块，进行搜索。搜索时，每找到一个人，便枚举其离线和在线的所有情况，然后找下一个人，最后所有人都分配好之后答案加1。不同联通块之间答案相乘。需要注意如果m为0答案为1。\n\n看了标程之后，不得不佩服，代码写的非常犀利。具体是；\n从第一个点开始，如果和其他点有边相连，则先把边赋值为+1，然后搜索与第一个点相连的下一个点，并对边继续赋值。如果最后全部赋值完之后，该点的边符合条件，则继续搜下一个点。在回溯的时候在把该边赋值为-1。这样从第一个点搜到最后一个点即可得到答案。（dfs的过程不好描述。。具体看代码）\n\n<!--more-->\n\n# 代码\n标称\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nint T, a[10][10], n, m, ans, du[10];\nvoid dfs(int x, int y) {\n    if (x > n) ans++; //找到一个答案\n    else if (y > n) { //x点的所有边已经赋值完\n        if (du[x]) return ; //du[x] != 0 表示赋值失败\n        dfs(x + 1, x + 2); //成功，搜索下一个点\n    } else {\n        if (a[x][y]) {\n            du[x]++;\n            du[y]++;\n            dfs(x, y + 1);\n            du[x] -= 2;\n            du[y] -= 2;\n            dfs(x, y + 1);\n            du[x]++;\n            du[y]++;\n        } else dfs(x, y + 1);\n    }\n}\nint main () {\n    cin>>T;\n    while(T--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                a[i][j] = 0;\n        int u, v;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            a[u][v] = a[v][u] = 1;\n        }\n        ans = 0;\n        dfs(1, 2);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n比赛写的搜索+二进制枚举\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nint a[8][8], n, m, T;\nint b[8];\nvector<int> g[8];\nint cnt;\nint l[8];\nvoid dfs(int u) {\n    l[cnt++] = u;\n    b[u] = 1;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (!b[v]) dfs(v);\n    }\n}\nint fk = 0;\nvoid work(int i) {\n    if (i == cnt) {\n        fk++;\n        return ;\n    }\n    if (i > cnt) return ;\n    int od = 0, ev = 0, u = l[i];\n    int out[8], cc = 0;\n    for (int ii = 0; ii < g[u].size(); ii++) {\n        int v = g[u][ii];\n        if (a[u][v] == 1) od++;\n        else if (a[u][v] == 2) ev++;\n        else if (a[u][v] == 0) out[cc++] = v;\n    }\n    if (cc == 0) {\n        if (od == ev) work(i + 1);\n        else return ;\n    } else {\n        int t = 1 << cc;\n        for (int j = 0; j < t; j++) {\n            int ck = 0;\n            for (int k = 0; k < cc; k++) if (j >> k & 1) ck++;\n            if (ck + od != g[u].size() / 2) continue;\n            int sb[8];\n            for (int ii = 0; ii < n; ii++)\n                sb[ii] = a[u][ii];\n            int k = 0;\n            for (k = 0; k < cc; k++) {\n                int v = out[k];\n                if (j >> k & 1) {\n                    a[u][v] = a[v][u] = 1;\n                } else {\n                    a[u][v] = a[v][u] = 2;\n                }\n            }\n            for (int k = 0; k < cc; k++) {\n                int v = out[k];\n            }\n            work(i + 1);\n            for (int ii = 0; ii < n; ii++)\n                a[u][ii] = a[ii][u] = sb[ii];\n        }\n    }\n}\nint main () {\n    cin>>T;\n    while(T--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 0; i < n; i++) g[i].clear();\n        int u, v;\n        for (int l = 0; l < m; l++) {\n            scanf(\"%d%d\", &u, &v);\n            u--, v--;\n            g[u].pb(v);\n            g[v].pb(u);\n        }\n        if (m == 0) {\n            puts(\"1\");\n            continue;\n        }\n        if (m % 2) {\n            puts(\"0\");\n            continue;\n        }\n        bool flag = false;\n        for (int i = 0; i < n; i++) if (g[i].size() % 2) {\n                puts(\"0\");\n                flag = true;\n                break;\n            }\n        if (flag) continue;\n        memset(b, 0, sizeof(b));\n        memset(a, 0, sizeof(a));\n        int ans = 1;\n        for (int i = 0; i < n; i++) if (!b[i] && g[i].size()) {\n                cnt = 0;\n                dfs(i);\n                fk = 0;\n                work(0);\n                ans *= fk;\n            }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14244955  2015-07-29 20:27:28 Accepted    5305    31MS    1408K   672 B   G++ SIO__Five 标称\n- 14244711  2015-07-29 20:16:34 Accepted    5305    93MS    1616K   2849 B  G++ SIO__Five 二进制枚举","tags":["搜索"],"categories":["ACM"]},{"title":"HDU 5297 Y sequence（数论，容斥，迭代）","url":"/2015/07/29/hdu5297/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5297\n\n# 题意\n定义一个序列，其中每一个数都不能表示为a^b(其中2≤b≤r)。现在给定n和r。问排在第n位的数字是多少？\n其中n≤2*1e18,2≤r≤62\n\n# 思路\n乍一看这道题完全没有想法。\n其实可以先考虑任意给定一个数字n，求n排在第几位。这就需要把2, 3, …… r次方的数都删去。可以发现删去2次方时，4次方，8次方，以此类推的都被删过了。所以我们只需要考虑质数即可。\n当然，这样还是有问题，比如6次方在删2次方、3次方时被多干掉一次，所以需要用容斥定理。我之前一直以为容斥要用dfs来搜。今天学到了一个新姿势。详细见代码\n需要注意的细节是1肯定不行，所以最后要删去。\n求出来数字n是多少位之后，就可以搞了。常见的想法是二分，但是这道题目的区间特别大，二分并不合适。\n这里采用了迭代的思想，假设当前now排在第m位，距离第n位还有n-m位，那么就再算now+m排在第几位，以此类推直到找到最后的答案。\n\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<set>\n#include<vector>\n#include<cmath>\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\nll n;\nint r;\nvector<ll> p;\nvector<ll> f;\nvoid getprime() {\n    for (int i = 2; i <= 61; i++) {\n        bool flag = true;\n        for (int j = 2; j <= sqrt(i + 0.5); j++) if (i % j == 0) {\n            flag = false;\n            break;\n        }\n        if (flag) p.push_back(-i);//, cout<<i<<endl;\n    }\n}\nvoid getfac() {\n    f.clear();\n    for (int i = 0; i < p.size() && abs(p[i]) <= r; i++) {\n        int num = f.size();\n        for (int j = 0; j < num; j++) {\n            if (abs(f[j] * p[i]) > 63) continue; //2的64次就已经超过了最大值\n            f.push_back(f[j] * p[i]);\n        }\n        f.push_back(p[i]);\n    }\n}\nll cal(ll n) {\n    ll res = n;\n    for (int i = 0; i < f.size(); i++) {\n        ll p = (ll)pow(n + 0.5, 1.0 / abs(f[i])) - 1;\n        if (f[i] > 0) res += p;\n        else res -= p;\n    }\n    return res - 1;\n}\nint main () {\n    getprime();\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%I64d%d\", &n, &r);\n        getfac();\n        ll now = n, ans;\n        while(1) {\n            ans = cal(now);\n            if (ans == n) break;\n            now += n - ans;\n        }\n        printf(\"%I64d\\n\", now);\n    }\n    return 0;\n}\n/*\n10\n20000000000000000 63\n*/\n\n```\n\n# 更新日志\n- 14238099  2015-07-29 15:31:11 Accepted    5297    358MS   1580K   1221 B  G++ SIO__Five\n","tags":["迭代"],"categories":["ACM"]},{"title":"HDU 4957 Poor Mitsui（贪心, 大数, 想法）","url":"/2015/07/27/hdu 4957/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4957\n\n# 题意\n有一个水龙头，单位时间出水为V。有n个破的水桶，每个水桶漏水的速度为ai，每个水桶要接到bi的水。现在问能否在某一时刻使得各个水桶符合条件，求最小的该时刻。\n其中1≤n,v,ai,bi≤40\n\n# 思路\n考虑两个水桶，第一个为ai,bi，第二个为aj,bj。\n把第一个排在前面的时间为： {% raw %}$\\frac{b_j}{v-a_j}+\\frac{\\frac{a_i*b_j}{v-a_j}+b_i}{v-a_i}${% endraw %}\n\n把第二个排在前面的时间为： {% raw %}$\\frac{b_i}{v-a_i}+\\frac{\\frac{a_j*b_i}{v-a_i}+b_j}{v-a_j}${% endraw %}\n\n所以可以发现只需要比较 ${b_i}\\times{a_j}$ 和 ${b_j}\\times{a_i}$\n\n的大小即可\n\n这道题有几个坑点：\n1. 如果水桶需要的水量不为零，且水桶漏水的速度大于v不行\n2. 如果水桶需要的水量为0时，所需要的时间应该是为0.\n3. 这道题的最后的答案可能非常大，超double了。我用了java中的BigDecimal\n\n```\nBigDecimal除一个数得到无限循环小数时会有问题，用：\n    BigDecimal.divide(BigDecimal, k, BigDecimal.ROUND_HALF_UP); 来保留k为小数\nBigDecimal四舍五入：\n    BigDecimal.setScale(0, BigDecimal.ROUND_HALF_UP);\n```\n<!--more-->\n\n# 代码\n```\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static final int N = 50;\n    public static void main(String args[]) {\n        int[] a = new int[N];\n         int[] b = new int[N];\n        Scanner in = new Scanner(System.in);\n        int test_count = in.nextInt();\n        int n, v;\n        while (test_count -- > 0) {\n            n = in.nextInt();\n            v = in.nextInt();\n            int flag = 1;\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = in.nextInt();\n                if (a[i] >= v && b[i] != 0) flag = 0;\n            }\n            if (flag == 0) {\n                System.out.println(-1);\n                continue;\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (b[i] * a[j] >= b[j] * a[i]) {\n                        int tmp;\n                        tmp = a[i]; a[i] = a[j]; a[j] = tmp;\n                        tmp = b[i]; b[i] = b[j]; b[j] = tmp;\n                        //swap(a[i], a[j]);\n                        //swap(b[i], b[j]);\n                    }\n                }\n            }\n            BigDecimal tot = BigDecimal.ZERO;\n            BigDecimal now;\n            for (int i = 0; i < n; i++) {\n                if (b[i] == 0) continue;\n                now = tot.multiply(BigDecimal.valueOf(a[i])).add(BigDecimal.valueOf(b[i]));\n                now = now.divide(BigDecimal.valueOf(v - a[i]), 200, BigDecimal.ROUND_HALF_UP);\n                tot = tot.add(now);\n            }\n            tot =  tot.setScale(0, BigDecimal.ROUND_HALF_UP);\n            System.out.println(tot);\n        }\n    }\n}\n```\n\n# 更新日志\n- 14209027  2015-07-27 23:02:04 Accepted    4957    436MS   13616K  1672 B  Java    SIO__Five\n","tags":["贪心"],"categories":["ACM"]},{"title":"HDU 4932 Miaomiao's Geometry（想法）","url":"/2015/07/27/hdu 4932/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4932\n\n# 题意\n给定一些点，要用一些等长的线段去覆盖这些点。问这些线段最长可以为多少？这些线段不能够相交，并且点只能够在线段的两个端点。\n\n# 思路\n我一上来就是二分。wa成狗。。\n其实二分是不对的，如0,1,4,5 答案为3，但是2不行\n仔细想想，其实会发现答案一定其中两个相邻点之间距离或者距离的一半。因为如果距离小于一半，那么可以扩大，扩到一半，这样两个线段相交。如果大于一半，小于该距离，同样可以扩大到该距离位置。对每个可行值进行判断即可。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define eps 1e-7\nint t, n;\ndouble a[100];\nusing namespace std;\nbool check(double x) {\n    double now = a[0];\n    for (int i = 1; i < n - 1; i++) {\n        if (now == a[i]) continue;\n        if (a[i] - now >= x) now = a[i];\n        else if (a[i] + x <= a[i + 1]) now = a[i] + x;\n        else return false;\n    }\n    return true;\n}\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) scanf(\"%lf\", a + i);\n        sort(a, a + n);\n        /*  二分有问题\n        double l = 1.0, r = a[n - 1] * 1.0 - a[0], mid;\n        while(fabs(l - r) > eps) {\n            mid = (l + r) / 2;\n            if (check(mid)) l = mid;\n            else r = mid;\n        }\n        */\n        double ans = 0;\n        for (int i = 1; i < n; i++) {\n            double tmp = a[i] - a[i - 1];\n            if (check(tmp)) ans = max(ans, tmp);\n            else if (check(tmp / 2)) ans = max(ans, tmp / 2);\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14208548  2015-07-27 22:17:31 Accepted    4932    15MS    1608K   1022B   G++ SIO__Five\n","tags":["想法"],"categories":["ACM"]},{"title":"HDU 5312 Sequence（想法, 三角形数）","url":"/2015/07/27/BC1st-3 hdu 5312/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5312\n\n# 题意\n有一个数列，第n(n≥1)项是3n*(n-1)+1. 现在他想知道对于一个给定的整数m, 是否可以表示成若干项上述数列的和. 如果可以, 那么需要的最小项数是多少?\n其中1≤m≤1e9\n\n# 思路\n![](http://siofive.qiniudn.com/hdu5312.png)\n神奇：一个自然数最多只需要3个三角形数即可表示。\n我一开始用mp处理，然后T了。。mp果然速度慢。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<map>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nconst int N = 200000;\nint t, m, cnt;\nint a[N];\nint main () {\n    scanf(\"%d\", &t);\n    for (int i = 1; ; i++) {\n        a[cnt++] = 3 * i * (i - 1) + 1;\n        if (a[cnt - 1] > 1e9) break;\n    }\n    while(t--) {\n        scanf(\"%d\", &m);\n        if (m % 6 == 0) {\n            puts(\"6\");\n            continue;\n        }\n        if (m % 6 == 1) {\n            int id = lower_bound(a, a + cnt, m) - a;\n            if (a[id] == m) puts(\"1\");\n            else puts(\"7\");\n            continue;\n        }\n        bool flag = false;\n        if (m % 6 == 2) {\n            for (int i = 0; 2 * a[i] <= m; i++) {\n                int id = lower_bound(a, a + cnt, m - a[i]) - a;\n                if (a[id] == m - a[i]) {\n                    puts(\"2\");\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) puts(\"8\");\n            continue;\n        }\n        printf(\"%d\\n\", m % 6);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14208127  2015-07-27 21:45:34 Accepted    5312    1014MS  1656K   1075 B  G++ SIO__Five\n","tags":["三角形数"],"categories":["ACM"]},{"title":"HDU 5313 Bipartite Graph（二分图染色, dp, bitset）","url":"/2015/07/27/BC1st-4 hdu 5313/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5313\n\n# 题意\n给定一张图，有n个点，m条边，保证其连通的部分是二分图。问要使该图成为完全二分图，问最多能够加多少条边。\n其中2≤n≤10000,0≤m≤100000\n\n# 思路\n首先，当点数固定时，两点之间越接近，完全二分图的边数越大。所以对每一个子图进行二分图染色，得到[ai, bi]的对。其中在X部有ai点，在Y部有bi点。把单一的点处理成[1, 0]。\n用bitset<N>dp来表示状态，一开始dp[0] = 1，表示X部选了0个点是可行的。然后每次考虑pair对，转移方程为dp = (dp << ai) | (dp << aj)。即X部可以加上ai或者aj个点。最后选择差值最小的即可。\n\n我比赛的时候用set来处理，结果在BC的评测平台上T了。赛后HDU上过了。。\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<set>\n#include<bitset>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\nconst int maxn = 10000 + 10;\nint n, m;\nbool has[maxn];\nint in[maxn];\nint od, ev, cc;\nvector<int> g[maxn];\npair<int, int> gg[maxn];\nvoid dfs(int u) {\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (!in[v]) {\n            in[v] = in[u] + 1;\n            if (in[v] == 3) in[v] = 1;\n            if (in[v] == 2) ev++;\n            else od++;\n            dfs(v);\n        }\n    }\n}\nbitset<maxn> dp;\nint main () {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 1; i <= n; i++) g[i].clear(), has[i] = false, in[i] = 0;\n        int u, v ;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            g[u].pb(v), g[v].pb(u);\n            has[u] = has[v] = true;\n        }\n        int cc = 0;\n        for (int u = 1; u <= n; u++) if (!in[u] && has[u]) {\n                od = 1, ev = 0;\n                in[u] = 1;\n                dfs(u);\n                gg[cc++] = {od, ev};\n        }\n        //bitset优化\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) if (!has[i]) gg[cc++] = {1, 0};\n        for (int i = 0; i < cc; i++)\n            dp = (dp << gg[i].first) | (dp << gg[i].second);\n        int ans;\n        for (int i = n/ 2; i >= 0; i--){\n            if (dp[i]) {\n                ans = i;\n                break;\n            }\n        }\n        printf(\"%d\\n\", ans * (n - ans) - m);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14206240  2015-07-27 20:14:49 Accepted    5313    546MS   3280K   1767 B  C++ SIO__Five\n","tags":["bitset"],"categories":["ACM"]},{"title":"HDU 5293 Tree chain problem（树dp，lca，树状数组）","url":"/2015/07/27/hdu 5293/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5293\n\n# 题意\n给定n个点的树，其中m条链有权值。现在需要选择一些链，使得其和最大。并且任意两条链之间没有公共点。1 ≤ n, m ≤ 100000\n\n\n# 思路\n题解：\n![](http://siofive.qiniudn.com/hdu5293.png)\n\n<!--more-->\n\n# 代码\n```\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<set>\n#include<vector>\n#define pb push_back\nusing namespace std;\nconst int N = 100000 + 100;\nint t, n, m, cnt, lev;\nint l[N], r[N], dep[N];\nint f[20][N];\nvector<int> g[N];\nvoid dfs(int u, int fa) {\n    l[u] = ++cnt;\n    dep[u] = dep[fa] + 1;\n    if (fa != 0) f[0][u] = fa;\n    else f[0][u] = 1;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (v == fa) continue;\n        dfs(v, u);\n    }\n    r[u] = ++cnt;\n}\nvoid st() {\n    int i, j;\n    for (j = 1; 1 << j < n; j++)\n        for (int i = 1; i <= n; i++)\n            f[j][i] = f[j - 1][f[j - 1][i]];\n    lev = j - 1;\n}\nint lca(int x, int y) {\n    if (dep[x] < dep[y]) swap(x, y);\n    int d = dep[x] - dep[y];\n    for (int i = lev; i >= 0; i--)\n        if (d >> i & 1)\n            x = f[i][x];\n    if (x == y) return x;\n    for (int i = lev; i >= 0; i--)\n        if (f[i][x] != f[i][y])\n            x = f[i][x], y = f[i][y];\n    return f[0][x];\n}\nint cs[N * 2], cd[N * 2];\nint sum[N], d[N];\nstruct node {\n    int u, v, lca, val;\n}p[N];\nvector<int> e[N];\nint lowbit(int x) {\n    return x & (-x);\n}\nvoid add(int p, int va, int *c) {\n    while(p <= 2 * n) {\n        c[p] += va;\n        p += lowbit(p);\n    }\n}\nint getsum(int p, int *c) {\n    int res = 0;\n    while(p) {\n        res += c[p];\n        p -= lowbit(p);\n    }\n    return res;\n}\nvoid solve(int u, int fa) {\n    sum[u] = d[u] = 0;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (v == fa) continue;\n        solve(v, u);\n        sum[u] += d[v];\n    }\n    d[u] = sum[u];\n    for (int i = 0; i < e[u].size(); i++) {\n        int x = p[e[u][i]].u;\n        int y = p[e[u][i]].v;\n        int tmp = getsum(l[x], cs) + getsum(l[y], cs) - getsum(l[x], cd) - getsum(l[y], cd) + sum[u];\n        d[u] = max(d[u], tmp + p[e[u][i]].val);\n    }\n    add(l[u], d[u], cd);\n    add(r[u], -d[u], cd);\n    add(l[u], sum[u], cs);\n    add(r[u], -sum[u], cs);\n}\nint main () {\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &m);\n        cs[0] = cd[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int j = 2 * i - 1;\n            cs[j] = cs[j + 1] = cd[j] = cd[j + 1] = 0;\n            g[i].clear();\n            e[i].clear();\n        }\n        int u, v;\n        for (int i = 1; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            g[u].pb(v); g[v].pb(u);\n        }\n        cnt = 0;\n        dep[0] = 0;\n        dfs(1, 0);\n        st();\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d%d\", &p[i].u, &p[i].v, &p[i].val);\n            p[i].lca = lca(p[i].u, p[i].v);\n            e[p[i].lca].pb(i);\n        }\n        solve(1, 0);\n        printf(\"%d\\n\", d[1]);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14199151  2015-07-27 15:26:38 Accepted    5293    1388MS  22824K  2513 B  C++ SIO__Five\n","tags":["树dp"],"categories":["ACM"]},{"title":"CF 313C Gerald and Giant Chess（组合数学+dp）","url":"/2015/07/25/CF313C/","content":"# 题目\t\n源地址：http://codeforces.com/contest/559/problem/C\n\n# 题意\n给定一张H*W的网格图，有N个坏点，求左上角走到右下角对10^9+7取模。\n1 ≤ H , W ≤ 10^5， 1 ≤ n ≤ 2000\n\n# 思路\n![](http://siofive.qiniudn.com/CF313C.png)\n来自：http://blog.csdn.net/popoqqq/article/details/46121519\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<vector>\n#define pb push_back\n#define debug puts(\"=====================\");\nusing namespace std;\ntypedef long long ll;\nint h, w, n;\nstruct node {\n    int x, y;\n}p[2010];\nbool cmp(node s, node v) {\n    if (s.x == v.x) return s.y < v.y;\n    return s.x < v.x;\n}\nconst int N = 200100;\nconst ll mod = 1e9 + 7;\nll inv[N], f[N], ff[N], dp[2010];\nvoid init(int n) {\n    inv[0] = inv[1] = 1;\n    f[0] = f[1] = 1;\n    ff[0] = ff[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        f[i] = f[i - 1] * i % mod;\n        inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n        ff[i] = ff[i - 1] * inv[i] % mod;\n    }\n}\nll C(int n, int m) {\n    return (f[n] * ff[m] % mod) * ff[n - m] % mod;\n}\nint main () {\n    cin>>h>>w>>n;\n    init(h + w);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &p[i].x, &p[i].y);\n        p[i].x--, p[i].y--;\n    }\n    p[n].x = h - 1, p[n].y = w - 1;\n    sort(p, p + n + 1, cmp);\n    for (int i = 0; i <= n; i++) {\n        dp[i] = C(p[i].x + p[i].y, p[i].x);\n        for (int j = 0; j < i; j++) {\n            if (p[j].y > p[i].y) continue;\n            dp[i] = (dp[i] - C(p[i].x + p[i].y - p[j].x - p[j].y, p[i].x - p[j].x) * dp[j] % mod + mod) % mod;\n        }\n        //cout<<dp[i]<<endl;\n    }\n    cout<<dp[n]<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- 12220472  2015-07-25 05:40:33 SIO__Five#  C - Gerald and Giant Chess  GNU C++ Accepted    139 ms  4700 KB\n","tags":["组合数学"],"categories":["ACM"]},{"title":"HDU 5296 Annoying problem（LCA+点到链的最短距离）","url":"/2015/07/22/hdu 5296/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5296\n\n# 题意\n给定n个点的树，q个询问。维护一个集合s，有两种操作\n1 u，表示选中树上的点u，加入集合\n2 u，表示取消选中点u，从集合中删除\n对于每个操作输出：\n使得选中的点联通的边权和是多少。\n\n# 思路\n题解：\n![](http://siofive.qiniudn.com/hdu 5296.jpg)\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<set>\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\nconst int N = 100010;\nint dep[N], dfn[N], rdfn[N], f[17][N], lev, dist[N];\nbool in[N];\nvector< pair<int, int> > g[N];\nint T, n, q, cnt;\nset<int> s;\nvoid dfs(int u, int fa) {\n    dfn[u] = ++cnt;\n    rdfn[cnt] = u;\n    dep[u] = dep[fa] + 1;\n    f[0][u] = fa;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i].fi, w = g[u][i].se;\n        if (v == fa) continue;\n        dist[v] = dist[u] + w;\n        dfs(v, u);\n    }\n}\nvoid st() {\n    int i, j;\n    for (j = 1; 1 << j < n; j++)\n        for (i = 1; i <= n; i++)\n            f[j][i] = f[j - 1][f[j - 1][i]];\n    lev = j - 1;\n}\nint lca(int x, int y) {\n    if (dep[x] < dep[y]) swap(x, y);\n    int d = dep[x] - dep[y];\n    for (int i = lev; i >= 0; i--)\n        if (d >> i & 1)\n            x = f[i][x];\n    if (x == y) return x;\n    for (int i = lev; i >= 0; i--)\n        if (f[i][x] != f[i][y])\n            x = f[i][x], y = f[i][y];\n    return f[0][x];\n}\nint add(int u) {\n    if (s.empty()) return 0;\n    set<int> :: iterator it = s.lower_bound(dfn[u]), it1 = it;\n    it1--;\n    if (it == s.begin() || it == s.end()) {\n        it = s.begin();\n        it1 = s.end();\n        it1--;\n    }\n    int x = *it, y = *it1;\n    x = rdfn[x], y =rdfn[y];\n    return dist[u] - dist[lca(x, u)] - dist[lca(y, u)] + dist[lca(x, y)];\n}\nint main () {\n    scanf(\"%d\", &T);\n    for (int cas = 1; cas <= T; cas++) {\n        scanf(\"%d%d\", &n, &q);\n        for (int i = 1; i <= n; i++) g[i].clear(), in[i] = false;\n        int u, v, w;\n        for (int i = 1; i < n; i++) {\n            scanf(\"%d%d%d\", &u, &v, &w);\n            g[u].pb({v, w});\n            g[v].pb({u, w});\n        }\n        printf(\"Case #%d:\\n\", cas);\n        cnt = 0;\n        dfs(1, 0);\n        st();\n        s.clear();\n        int ans = 0;\n        while(q--) {\n            scanf(\"%d%d\", &v, &u);\n            if (v == 1) {\n                if (!in[u]) {\n                    ans += add(u);\n                    s.insert(dfn[u]);\n                    in[u] = true;\n                }\n            } else {\n                if (in[u]) {\n                    s.erase(dfn[u]);\n                    ans -= add(u);\n                    in[u] = false;\n                }\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14120982    2015-07-22 22:49:10 Accepted    5296    2433MS  21724K  2510 B  G++ SIO__Five\n","tags":["点到链的最短距离"],"categories":["ACM"]},{"title":"HDU 5289 Assignment（st表 单调队列）","url":"/2015/07/22/hdu 5289/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5289\n\n# 题意\n给你n个数和一个数k，求存在多少个区间，区间内最大值减最小值小于k\n其中 n ≤ 100000; a[i], k ≤ 10^9\n\n# 思路\nst表：\n用st表来维护区间最小值最大值。维护一个队列，从左往右开始遍历，每次要将一个数放进队列时，判断是否符合条件，符合则加入，不符合则将队首的元素移出，直到符合位置。每次要移出元素时，答案加上当前队列个数。\n也可以用二分+st表来实现的，对于每一个数，二分查找其最靠右的符合条件的数，但复杂度略高。\n\n单调队列：\n维护两个单调队列，一个递增，一个递减。从左往右遍历，每次将数字加入两个队列队尾。然后判断队首的最大、最小值是否符合条件，符合则加入，不符合则将排在前面的数字移出队列，每次移出是更新答案。\n\n<!--more-->\n\n# 代码\nst表：\n```\n#include<iostream>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<map>\n#include<algorithm>\n#include<queue>\n#include<set>\n#define inf 1000000000\n#define pi acos(-1.0)\n#define eps 1e-8\n#define seed 131\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long ull;\ntypedef long long ll;\nconst int N = 100000 + 100;\nint T, n, k;\nint a[N];\nint maxsum[20][N], minsum[20][N];\nvoid rmq(int num) {\n    for (int i = 1; i != 20; i++) {\n        for (int j = 1; j <= num; j++)\n        if (j + (1 << i) - 1 <= num) {\n            maxsum[i][j] = max(maxsum[i - 1][j], maxsum[i - 1][j + (1 << i >> 1)]);\n            minsum[i][j] = min(minsum[i - 1][j], minsum[i - 1][j + (1 << i >> 1)]);\n        }\n    }\n}\nint getmx(int st, int ed) {\n    int k = (int) log2(ed - st + 1.0);\n    int mx = max(maxsum[k][st], maxsum[k][ed - (1 << k) + 1]);\n    return mx;\n}\nint getmn(int st, int ed) {\n    int k = (int) log2(ed - st + 1.0);\n    int mn = min(minsum[k][st], minsum[k][ed - (1 << k) + 1]);\n    return mn;\n}\nint mx, mn;\nll ans;\nbool check(int l, int r, int x) {\n    if (l > r) return false;\n    mx = getmx(l, r), mn = getmn(l, r);\n    if (abs(x - mx) < k && abs(x - mn) < k) return true;\n    return false;\n}\nqueue<int> q;\nint main() {\n    cin>>T;\n    while(T--) {\n        scanf(\"%d%d\", &n, &k);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d\", a + i);\n            minsum[0][i] = maxsum[0][i] = a[i];\n        }\n        rmq(n);\n        int l = 1, r = 1;\n        while(!q.empty()) q.pop();\n        q.push(a[1]);\n        ans = 0;\n        for (int i = 2; i <= n; i++) {\n            if (check(l, r, a[i])) {\n                q.push(a[i]);\n                r++;\n            }\n            else {\n                while(!q.empty()) {\n                    ans += q.size();\n                    q.pop();\n                    l++;\n                    if (check(l, r, a[i])) break;\n                }\n                q.push(a[i]);\n                r++;\n            }\n        }\n        ll tmp = q.size();\n        ans += tmp * (tmp + 1) / 2;\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n单调队列：\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\ntypedef long long ll;\nusing namespace std;\ndeque< pair<int, int> > q1, q2;\nconst int N = 100010;\nint n, k, T, a[N];\nll ans;\nint main () {\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d%d\", &n, &k);\n        while(!q1.empty()) q1.pop_back();\n        while(!q2.empty()) q2.pop_back();\n        ans = 0;\n        int head = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", a + i);\n            while(!q1.empty()) {\n                if (q1.back().first < a[i]) q1.pop_back();\n                else break;\n            }\n            q1.push_back({a[i], i});\n            while(!q2.empty()) {\n                if (q2.back().first > a[i]) q2.pop_back();\n                else break;\n            }\n            q2.push_back({a[i], i});\n            while(1) {\n                if (q1.front().first - q2.front().first < k) break;\n                else {\n                    if (q1.front().second < q2.front().second) {\n                        head = q1.front().second + 1;\n                        q1.pop_front();\n                    } else {\n                        head = q2.front().second + 1;\n                        q2.pop_front();\n                    }\n                }\n            }\n            ans += i - head + 1;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14110637  2015-07-22 15:29:58 Accepted    5289    374MS   12444K  2211 B  G++ SIO__Five st表\n- 14113375  2015-07-22 16:33:02 Accepted    5289    468MS   1940K   1105 B  G++ SIO__Five 单调队列\n","tags":["st表"],"categories":["ACM"]},{"title":"HDU 5288 OO’s Sequence（数学）","url":"/2015/07/22/hdu 5288/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5288\n\n# 题意\n在闭区间[l,r]内有一个数a[i]，a[i]不能整除除去自身以外的其他的数，f(l,r)表示在这区间内a[i]这样的数的个数，，现给你n个数，求所有区间的f(l,r)的和。\n其中 n ≤ 100000; a[i] ≤ 10000\n\n# 思路\n对于一个数a[i]，找到两端离他最近的因子l[i], r[i]，那么它能够贡献的答案就是(r[i] - i) * (i - l[i])。枚举每一个数的因子，然后用该数更行l，r数组。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 1e5 + 100;\nint a[N], l[N], r[N], n, p[10010];\nll ans;\nint main () {\n    while(~scanf(\"%d\", &n)) {\n        for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n        memset(p, -1, sizeof(p));\n        ans = 0;\n        p[a[0]] = 0, l[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int q = sqrt(a[i] + 0.5);\n            l[i] = -1;\n            for (int j = 1; j <= q; j++) if (a[i] % j == 0){\n                l[i] = max(l[i], p[a[i] / j]);\n                l[i] = max(l[i], p[j]);\n            }\n            if (l[i] == -1) l[i] = 0;\n            else l[i]++;\n            p[a[i]] = i;\n            //cout<<l[i]<<endl;\n        }\n        memset(p, INF, sizeof(p));\n        p[a[n - 1]] = n - 1, r[n - 1] = n - 1;\n        ans = (n - 1 - l[n - 1] + 1) * (r[n - 1] - (n - 1) + 1);\n        //cout<<ans<<endl;\n        for (int i = n - 2; i >= 0; i--) {\n            int q = sqrt(a[i] + 0.5);\n            r[i] = INF;\n            for (int j = 1; j <= q; j++) if (a[i] % j == 0) {\n                r[i] = min(r[i], p[a[i] / j]);\n                r[i] = min(r[i], p[j]);\n            }\n            if (r[i] == INF) r[i] = n - 1;\n            else r[i]--;\n            p[a[i]] = i;\n            //cout<<r[i]<<endl;\n            ans =(ans + (ll)(i - l[i] + 1) * (r[i] - i + 1)) % mod;\n        }\n        printf(\"%I64d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14110337  2015-07-22 15:23:36 Accepted    5288    967MS   2788K   1324 B  G++ SIO__Five\n","tags":["想法"],"categories":["ACM"]},{"title":"HDU 5294 Tricks Device（网络流 最短路）","url":"/2015/07/22/hdu 5294/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5294\n\n# 题意\n有一张图，其中n个点，m条双向边，边有权值。所以从起点1走到终点n有一个最短时间。问：\n（1）最少去掉多少条边，使得从起点到终点的时间大于最短时间（走不到也算）\n（2）最多去掉多少条边，使得从起点到终点的时间仍然为最短时间。\n其中 n ≤ 2000; m ≤ 60000\n\n# 思路\nspfa时找到最少边数的最短路，总边数减去最少变数即为第二问答案。\n第一问中，根据在最短路的边构造边流量为1的新图，对新图求最大流即为第一问答案。\n\n比赛的时候思路非常清晰，但是看到n和m这么大，感觉网络流肯定T，然后就没有敲。。。实际上新图的规模很小\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nconst int INF = (1 << 30);\nusing namespace std;\nconst int N = 2010;\nconst int M = 60010;\nvector< pair<int, int> > G[N];\nint n, m;\nconst int maxn = 2010;\nconst int maxm = 60010;\nstruct node {\n    int v;    // vertex\n    int cap;    // capacity\n    int flow;   // current flow in this arc\n    int nxt;\n} e[maxm * 2];\nint g[maxn], cnt;\nint st, ed;\nint dd[maxn], cc[maxn];\nqueue<int> Q;\nvoid spfa(int st, int ed) {\n    dd[st] = cc[st] = 0;\n    bool in[maxn] = {0};\n    while(!Q.empty()) Q.pop();\n    in[st] = true;\n    Q.push(st);\n    while(!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        in[u] = false;\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i].first, c = G[u][i].second;\n            if (dd[u] + c == dd[v]) cc[v] = min(cc[v], cc[u] + 1);\n            if (dd[u] + c < dd[v]) {\n                cc[v] = cc[u] + 1;\n                dd[v] = dd[u] + c;\n                if (!in[v]) Q.push(v), in[v] = true;\n            }\n        }\n    }\n}\n\nvoid add(int u, int v, int c) {\n    e[++cnt].v = v;\n    e[cnt].cap = c;\n    e[cnt].flow = 0;\n    e[cnt].nxt = g[u];\n    g[u] = cnt;\n\n    e[++cnt].v = u;\n    e[cnt].cap = 0;\n    e[cnt].flow = 0;\n    e[cnt].nxt = g[v];\n    g[v] = cnt;\n}\n\nvoid init() {\n    memset(g, 0, sizeof(g));\n    cnt = 1;\n    st = 1, ed = n;\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < G[u].size(); i++) {\n            if (dd[u] + G[u][i].second == dd[G[u][i].first]) add(u, G[u][i].first, 1);\n        }\n    }\n}\n\nint dist[maxn], numbs[maxn], q[maxn];\nvoid rev_bfs() {\n    int font = 0, rear = 1;\n    for (int i = 0; i <= n; i++) { //n为总点数\n        dist[i] = maxn;\n        numbs[i] = 0;\n    }\n    q[font] = ed;\n    dist[ed] = 0;\n    numbs[0] = 1;\n    while(font != rear) {\n        int u = q[font++];\n        for (int i = g[u]; i; i = e[i].nxt) {\n            if (e[i ^ 1].cap == 0 || dist[e[i].v] < maxn) continue;\n            dist[e[i].v] = dist[u] + 1;\n            ++numbs[dist[e[i].v]];\n            q[rear++] = e[i].v;\n        }\n    }\n}\nint maxflow() {\n    n += 3;\n    rev_bfs();\n    int u, totalflow = 0;\n    int curg[maxn], revpath[maxn];\n    for(int i = 0; i <= n; ++i) curg[i] = g[i];\n    u = st;\n    while(dist[st] < n) {\n        if(u == ed) {   // find an augmenting path\n            int augflow = INF;\n            for(int i = st; i != ed; i = e[curg[i]].v)\n                augflow = min(augflow, e[curg[i]].cap);\n            for(int i = st; i != ed; i = e[curg[i]].v) {\n                e[curg[i]].cap -= augflow;\n                e[curg[i] ^ 1].cap += augflow;\n                e[curg[i]].flow += augflow;\n                e[curg[i] ^ 1].flow -= augflow;\n            }\n            totalflow += augflow;\n            u = st;\n        }\n        int i;\n        for(i = curg[u]; i; i = e[i].nxt)\n            if(e[i].cap > 0 && dist[u] == dist[e[i].v] + 1) break;\n        if(i) {   // find an admissible arc, then Advance\n            curg[u] = i;\n            revpath[e[i].v] = i ^ 1;\n            u = e[i].v;\n        } else {    // no admissible arc, then relabel this vertex\n            if(0 == (--numbs[dist[u]])) break;    // GAP cut, Important!\n            curg[u] = g[u];\n            int mindist = n;\n            for(int j = g[u]; j; j = e[j].nxt)\n                if(e[j].cap > 0) mindist = min(mindist, dist[e[j].v]);\n            dist[u] = mindist + 1;\n            ++numbs[dist[u]];\n            if(u != st)\n                u = e[revpath[u]].v;    // Backtrack\n        }\n    }\n    n -= 3;\n    return totalflow;\n}\n\nint main () {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        for (int i = 1; i <= n; i++) {\n            G[i].clear();\n            dd[i] = cc[i] = INF;\n        }\n        int u, v, l;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d%d\", &u, &v, &l);\n            G[u].push_back({v, l});\n            G[v].push_back({u, l});\n        }\n        spfa(1, n);\n        init();\n        printf(\"%d %d\\n\", maxflow(), m - cc[n]);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14108329  2015-07-22 14:29:43 Accepted    5294    93MS    4992K   3960 B  C++ SIO__Five\n","tags":["网络流"],"categories":["ACM"]},{"title":"HDU 4909 String（组合数学）","url":"/2015/07/20/BC3-3 hdu 4909/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4909\n\n# 题意\n有长度为n的由小写字母组成字符串，其中可能有一个'?'或没有。求其非空子串（包括自身）的个数，且子串必须满足其中出现的字符的个数均为偶数。如果有'?'，则可以将其删去或者变为任意一个字母。其中 1 ≤ n ≤ 20000\n\n# 思路\n将每个字符表示为二进制中的一位，如果出现偶数个，则其异或后为0.\n假如字符串不包含'?'，则求每一个前缀的异或值，如果两个前缀异或之后为0，这表示两者相差的字符串为符合条件的串。所以只需要对每种异或值求C(n, 2)并累加即可。\n如果字符串包含'?'，那么有三种情况：\n1. 子串在?之前\n2. 子串在?之后\n3. 子串包括?\n对于前两种计算方式和不包含'?'的相同，第三种情况中，?可以有27种情况，变为26个字母或为空。枚举一下即可\n\n注意：\n```\n不能用ans += mp[x] 这种写法。虽然mp[x]为0时也正确，但是mp[x]每次都会把x加入到map中\n应该用 if(mp.count(x)) ans += mp[x];\n```\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\nusing namespace std;\nmap<int, int> mp;\nmap<int, int> mp2;\nint T, n;\nint w[30];\nconst int N = 20010;\nchar s[N];\nint main () {\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%s\", s);\n        mp.clear();\n        mp[0] = 1;\n        n = strlen(s);\n        int x = 0, i, cnt = 0;\n        bool flag = false;\n        for (i = 0; i < n; i++) {\n            if (s[i] == '?') {\n                flag = true;\n                break;\n            }\n            x = x ^ (1 << (s[i] - 'a'));\n            mp[x]++;\n        }\n        map<int, int> :: iterator it;\n        int ans = 0;\n        for (it = mp.begin(); it != mp.end(); it++) {\n            int t = (*it).second;\n            //cout<<(*it).first<<\" \"<<(*it).second<<endl;\n            if (t < 2) continue;\n            ans += t * (t - 1) / 2;\n        }\n        if (!flag) {\n            printf(\"%d\\n\", ans);\n            continue;\n        }\n        i++;\n        int xx = 0;\n        mp2.clear();\n        mp2[0]++;\n        for (; i < n; i++) {\n            xx = xx ^ (1 << (s[i] - 'a'));\n            mp2[xx]++;\n        }\n        //puts(\"-------------\");\n        for (it = mp2.begin(); it != mp2.end(); it++) {\n            int t = (*it).second;\n            //cout<<(*it).first<<\" \"<<(*it).second<<endl;\n            if (t < 2) continue;\n            ans += t * (t - 1) / 2;\n        }\n        for (int i = 0; i < 27; i++) {\n            for (it = mp.begin(); it != mp.end(); it++) {\n                int tmp = x ^ (1 << i);\n                if (i == 26) tmp = x;\n                //cout<<(*it).first<<\" \"<<(*it).second<<\" \"<<mp2[tmp ^ (*it).first]<<endl;\n                if (mp2.count(tmp ^ (*it).first))\n                    ans += (*it).second * (mp2[tmp ^ (*it).first]);\n            }\n        }\n\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14079251  2015-07-20 19:50:08 Accepted    4909    1216MS  3132K   1948 B  G++ SIO__Five\n","tags":["异或"],"categories":["ACM"]},{"title":"HDU 4908 BestCoder Sequence（数学）","url":"/2015/07/20/BC3-2 hdu 4908/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4908\n\n# 题意\n有n个数的序列，求其连续的、且中位数为M的、长度为奇数的子序列个数。其中 1 ≤ n ≤ 40000\n\n# 思路\n只需要将大于M的数标记为+1，小于M的为-1，M为0。然后从M左边开始长度为奇数（偶数）的子序列与M右边开始长度为奇数（偶数）的子序列的和为0，组成的序列便是一个答案。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n, m, a[40010];\nint odd[40010 * 2], even[40010 * 2];\nint main () {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        int x;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n            if (a[i] == m) x = i, a[i] = 0;\n            else if (a[i] > m) a[i] = 1;\n            else a[i] = -1;\n            odd[i] = odd[i + n] = 0;\n            even[i] = even[i + n] = 0;\n        }\n        int ans = 1;\n        for (int i = x + 1; i < n; i++) {\n            a[i] = a[i - 1] + a[i];\n            if ((i - x) % 2 == 1) odd[a[i] + n]++;\n            else even[a[i] + n]++;\n        }\n        ans += even[n];\n        for (int i = x - 1; i >= 0; i--) {\n            a[i] = a[i + 1] + a[i];\n            if ((x - i) % 2 == 1) ans += odd[n - a[i]];\n            else {\n                ans += even[n - a[i]];\n                if (a[i] == 0) ans++;\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14073501  2015-07-20 15:18:25 Accepted    4908    171MS   2344K   855 B   G++ SIO__Five\n","tags":["想法"],"categories":["ACM"]},{"title":"HDU 4885 TIANKENG’s travel（三点共线 最短路）","url":"/2015/07/20/BC2-3 hdu 4885/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4885\n\n# 题意\n给你一个起点，一个终点和n个加油站。只能走直线，只能到达这三种点，经过加油站必须加油，一次加油可以走L的距离，问最少经过加油站几次可以从起点到达终点。1 ≤ n ≤ 1000\n\n# 思路\n只需要把距离小于等于L的两个点连一条边，然后跑最短路即可。\n需要注意的是，有可能出现三点共线，此时从这三点的一端到另一端，要经过三个点。所以必须要处理三点共线的情况。\n方法是：\n将所有的点按照x从小到大排序，然后对于每个点，维护一个set。对于第i个点，只需要判断它后面的点与其构成线段的斜率是否已经存在，已存在则不加入。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<set>\n#include<queue>\n#define pi pair<int, int>\nusing namespace std;\nconst int N = 1010;\nconst int INF = 0x3f3f3f3f;\nstruct node {\n    int x, y, id;\n}p[N];\nbool cmp(node s, node v) {\n    return s.x < v.x;\n}\nint T, n, l;\nint head[N], nxt[N * N], pre[N * N], e;\nvoid init() {\n    memset(head, -1, sizeof(int) * (n + 5));\n    e = 0;\n}\nvoid add(int u, int v) {\n    pre[e] = v, nxt[e] = head[u], head[u] = e++;\n}\nbool dis(double x, double y) {\n    double L = sqrt(x * x + y * y);\n    if (L <= l) return true;\n    return false;\n}\nint dist[N];\nint bfs(int s, int e) {\n    memset(dist, 0x3f, sizeof(int) * (n + 5));\n    dist[s] = 0;\n//    priority_queue< pair<int, int> > q;\n//    q.push({0, s});\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()) {\n//        int u = q.top().first; q.pop();\n//        if (u == e) return dist[e];\n        int u = q.front(); q.pop();\n        for (int i = head[u]; i != -1; i = nxt[i]) {\n            int v = pre[i];\n            if (dist[u] + 1 < dist[v]) {\n                dist[v] = dist[u] + 1;\n                //q.push({dist[v], v});\n                q.push(v);\n            }\n        }\n    }\n    return dist[e];\n}\nint main () {\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d%d\", &n, &l);\n        scanf(\"%d%d\", &p[0].x, &p[0].y);\n        p[0].id = 0;\n        scanf(\"%d%d\", &p[n + 1].x, &p[n + 1].y);\n        p[n + 1].id = n + 1;\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%d%d\", &p[i].x, &p[i].y);\n            p[i].id = i;\n        }\n        sort(p, p + n + 2, cmp);\n        init();\n        for (int i = 0; i <= n + 1; i++) {\n            set< pi > s;\n            for (int j = i + 1; j <= n + 1; j++) {\n                int dx = p[j].x - p[i].x, dy = p[j].y - p[i].y;\n                if (!dis(dx, dy)) continue;\n                int gcd = abs(__gcd(dx, dy));\n                pi tmp = make_pair(dx / gcd, dy / gcd);\n                if (s.count(tmp)) continue;\n                add(i, j);\n                add(j, i);\n                s.insert(tmp);\n            }\n        }\n        int s, e;\n        for (int i = 0; i <= n + 1; i++) {\n            if (p[i].id == 0) s = i;\n            if (p[i].id == n + 1) e = i;\n        }\n        int ans = bfs(s, e);\n        if (ans == INF) puts(\"impossible\");\n        else printf(\"%d\\n\", ans - 1);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14070053  2015-07-20 11:56:32 Accepted    4885    93MS    1716K   2073 B  G++ SIO__Five\n","tags":["最短路"],"categories":["ACM"]},{"title":"HDU 4886 TIANKENG’s restaurant(Ⅱ)","url":"/2015/07/19/BC2-4 hdu 4886 TIANKENG’s restaurant(Ⅱ)/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4886\n\n# 题意\n有一个字符串S。只有ABCDEFGH这八个字符组成。现在需要找一个最小的由这八个字符组成的子串T，使其不是S的子串。\n数据范围：1 ≤ n ≤ 1000000 其中n为S的长度\n\n# 思路\n假设结果长度为L，那么当8^L >= Length(S)时必有结果，所以可以确定L的最大值。暴力枚举长度为1，长度为2...长度为L。在枚举过程中，先对S中所有枚举长度的子串求hash值，然后再搜索对应长度的所有子串，O(1)判断即可。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint T, n, len, a[100];\nconst int N = 1000000 + 100;\nchar s[N];\nbool ha[N];\nbool dfs(int k, int x) {\n    //cout<<k<<\" \"<<x<<endl;\n    if (k == len) {\n        if (!ha[x]) return 1;\n        return 0;\n    }\n    for (int i = 0; i < 8; i++) {\n        a[k] = i;\n        if (dfs(k + 1, x * 8 + i)) return 1;\n    }\n    return 0;\n}\nint main () {\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%s\", s);\n        n = strlen(s);\n        for (len = 1; ; len++) {\n            memset(ha, 0, sizeof(ha));\n            for (int i = 0; i + len - 1 < n; i++) {\n                int x = 0;\n                for (int j = 0; j < len; j++)\n                    x *= 8, x += s[i + j] - 'A';\n                ha[x] = 1;\n                //cout<<x<<endl;\n            }\n            if (!dfs(0, 0)) continue;\n            for (int i = 0; i < len; i++)\n                printf(\"%c\", 'A' + a[i]);\n            puts(\"\");\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14049001  2015-07-18 12:23:03 Accepted    4886    1466MS  3536K   1092 B  G++ SIO__Five\n","tags":["哈希"],"categories":["ACM"]},{"title":"HDU 4884 TIANKENG's rice shop（模拟）","url":"/2015/07/19/BC2-2 hdu 4884 TIANKENG’s rice shop/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4884\n\n# 题意\n有一家餐厅，有n种炒饭，每次炒一次饭需要t时间，其中炒一次饭有k碗。有m个人来到在某一个时间来到餐厅，他点了num碗第id种的炒饭。问每一个客人最早离开餐厅的时间。\n在炒饭过程中，保证先来先服务。但是每次炒会炒尽可能多的份数，不过不会有多余的。\n\n\n# 思路\n这道模拟题特别恶心。。\n举个例子，比如每次可以炒5份，每次5分钟。\n第一个顾客08:00进来，点了2份A，\n第二个顾客08:04进来，点了3份A。\n在08:00开始炒的话，由于这个时候第二个顾客还没进来，所以就只炒2份，第一个顾客在08:05离开，这时才炒第二个的3份，所以第二个离开时间是08:10。\n\n同样是每次可以炒5份，每次5分钟。\n第一个顾客08:00进来，点了6份A，\n第二个顾客08:01进来，点了5份B，\n第三个顾客08:02进来，点了4份A。\n同样地，先炒5份给第一个，还差一份，这是已经是08:05了，第三个顾客也进来了，所以这时直接炒5份A（因为会尽可能多地炒），08：10第一个和第三个可以同时离开。接着才炒第二个的。\n\n我的做法时，每次服务某个客人时，判断最多能够多炒几份饭，然后分给后来的客人。\n这道题还有一个坑的地方是，客人最后离开的时间可能会超过24小时，需要取模。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint T, n, t, k, m;\nint a[1010], id[1010], num[1010], out[1010], kind[1010];\nint main () {\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d%d%d%d\", &n ,&t, &k, &m);\n        //memset(kind, 0, sizeof(kind));\n        int x, y, now = 0;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d:%d%d%d\", &x, &y, &id[i], &num[i]);\n            a[i] = x * 60 + y;\n        }\n        for (int i = 0; i < m; i++) {\n            if (!i) now = 0;\n            else now = max(now, a[i - 1]);\n            //cout<<num[i]<<endl;\n            if (!num[i]) continue;\n            now = out[i] = max(now, a[i]) + (num[i] + k - 1) / k * t;\n            int tmp = k - num[i] % k;\n            if (tmp == k) continue;\n            for (int j = i + 1; j < m; j++) {\n                if (a[j] > out[i] - t) break;\n                if (id[j] == id[i]) {\n                    if (num[j] <= tmp) {\n                        tmp -= num[j];\n                        num[j] = 0;\n                        out[j] = max(out[i], a[j]);\n                    } else {\n                        num[j] -= tmp;\n                        tmp = 0;\n                    }\n                    //cout<<j<<\"-------------\"<<tmp<<endl;\n                    if (!tmp) break;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) printf(\"%02d:%02d\\n\", (out[i] % 1440) / 60, (out[i] % 1440) % 60);\n        if (T) puts(\"\");\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14055192  2015-07-18 21:42:51 Accepted    4884    93MS    1608K   1565 B  G++ SIO__Five\n","tags":["模拟"],"categories":["ACM"]},{"title":"HDU 4883 TIANKENG's restaurant","url":"/2015/07/19/BC2-1 hdu 4883 TIANKENG’s restaurant/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4883\n\n# 题意\n有一家餐厅，有n组人，每组包括Xi个人，在某一个时间段来到餐厅。问餐厅最少需要多少张凳子可以让每一个时刻所有在餐厅的人都有位子。\n\n# 思路\n把到达的和离开的时间按照从小到大排序，遇到到达时加上来的人数，遇到离开时减去离开的人数，遍历求出最大值即可。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N = 10000 + 10;\nint n, t;\npair<int, int> a[N + N];\nint main () {\n    scanf(\"%d\", &t);\n    int c, x, xx, y, yy, cnt;\n    while(t--) {\n        scanf(\"%d\", &n);\n        cnt = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d:%d%d:%d\", &c, &x, &xx, &y, &yy);\n            a[cnt++] = make_pair(x * 60 + xx, c);\n            a[cnt++] = make_pair(y * 60 + yy, -c);\n        }\n        sort(a, a + cnt);\n        int ans = 0, sum = 0;\n        for (int i = 0; i < cnt; i++) {\n            sum += a[i].second;\n            ans = max(ans, sum);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14040955  2015-07-17 16:01:31 Accepted    4883    577MS   1748K   643 B   G++ SIO__Five\n","tags":["想法"],"categories":["ACM"]},{"title":"HDU 4858 项目管理（分块）","url":"/2015/07/19/BC1-2 hdu 4858 项目管理(分块)/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4858\n\n# 题意\n有一个项目有n个点，项目是连通的。有m条边，可能有重边，但没有自环。\n接下来有Q次询问，每次询问分两种操作，操作符为0，表示给某一个点加上一个值。操作符为1，询问某一个点相邻项目值之和（如果多条边就算多次）\n数据范围：1 ≤ n ≤ 100000，1 ≤ m ≤ n + 10\n\n# 思路\n我只想到了暴力的方法，刚好可以水过。。\n正确的姿势是采用分块的思想，由于这个图比较稀疏，总度数为2*m，又由于整个图是连通的，所以每个点的度数至少为1。这是还剩下2*m-n个度数可以分配，故度数大于sqrt(n)的点的个数和sqrt(n)比较接近。\n因此我们将点分为两类，度数大于sqrt(n)的点为重点，度数小于sqrt(n)的点为轻点。每个重点维护与其相邻的所有轻点值之和。\n1. 每次修改轻点时，更新自己的值，并且更新与其相邻的所有重点相邻轻点和。复杂度为O(sqrt(n))\n2. 每次修改重点时，只更新自己的值。复杂度为O(1)\n3. 每次询问轻点时，只需要把与轻点的邻居相加。复杂度为O(sqrt(n))\n4. 每次询问重点时，只需要把与其相连的重点的值相加，再加上维护的其相邻轻点的和即可。复杂度为O(sqrt(n))\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define pb push_back\nusing namespace std;\nconst int N = 100000 + 100;\nint n, m, T;\nvector<int> g[N], gb[N];\nint d[N], sum[N], w[N];\nint main () {\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 0; i <= n; i++) {\n            g[i].clear(), gb[i].clear();\n            d[i] = sum[i] = w[i] = 0;\n        }\n        int u, v;\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d%d\", &u, &v);\n            g[u].pb(v); g[v].pb(u);\n            d[u]++, d[v]++;\n        }\n        int sq = sqrt(n) + 1.0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < g[i].size(); j++) {\n                int r = g[i][j];\n                if (d[r] > sq) gb[i].pb(r);\n            }\n        }\n        int Q, op;\n        scanf(\"%d\", &Q);\n        while(Q--) {\n            scanf(\"%d\", &op);\n            if (!op) {\n                scanf(\"%d%d\", &u, &v);\n                w[u] += v;\n                if (d[u] <= sq) {\n                    for (int j = 0; j < gb[u].size(); j++) sum[gb[u][j]] += v;\n                }\n            } else {\n                scanf(\"%d\", &u);\n                int ans = 0;\n                if (d[u] <= sq) {\n                    for (int j = 0; j < g[u].size(); j++) ans += w[g[u][j]];\n                } else {\n                    ans += sum[u];\n                    for (int j = 0; j < gb[u].size(); j++) ans += w[gb[u][j]];\n                }\n                printf(\"%d\\n\", ans);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 13943476  2015-07-02 16:54:16 Accepted    4858    514MS   12008K  1646 B  G++ SIO__Five\n","tags":["分块"],"categories":["ACM"]},{"title":"HDU 4857 逃生（拓扑排序 逆向思考）","url":"/2015/07/19/BC1-1 hdu 4857 逃生(拓扑排序 逆向思考)/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4857\n\n# 题意\n现在有n个人，从1标号到n。要把他们排成一排。同时有m个约束条件，每个都形如：a必须在b之前。此外这些人中1号最富，2号第二富，以此类推。在排顺序时，尽量让越有钱的人越靠前。即先让1尽量靠前，再让2尽量靠前，以此类推。求出这个序列。\n\n# 思路\n首先肯定想到拓扑排序。但是按照正常的拓扑排序之后得到的是字典序最小的序列。无法保证让越富有的人越靠前的情况。\n举个例子：有4个人，2个限制：1在4之前，4在2之前。\n按照正常的拓扑排序得到：1 3 4 2\n但是符合要求的序列则为：1 4 2 3\n所以正确的想法是：建边时逆向建边，然后每次选取最大的数排在前面，这样子便可以保证小数（富有的人）尽可能的排在后面。然后逆序输出序列即可。\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<set>\n#include<queue>\nusing namespace std;\nconst int N = 30000 + 100;\nstruct node {\n    int x;\n    bool operator < (const node &T) const {\n        return x < T.x;\n    }\n};\nvector<int> g[N];\nint n, m, du[N], out[N];\nint main () {\n    int t;\n    cin>>t;\n    while(t--) {\n        priority_queue<node> q;\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 0; i <= n; i++) g[i].clear(), du[i] = 0;\n        int u, v;\n        while(m--) {\n            scanf(\"%d%d\", &u, &v);\n            g[v].push_back(u);\n            du[u]++;\n        }\n        for (int i = 1; i <= n; i++) if (!du[i]) q.push({i});\n        int ct = 0;\n        while(!q.empty()) {\n            u = q.top().x;\n            q.pop();\n            out[ct++] = u;\n            for (int i = 0; i < g[u].size(); i++) {\n                v = g[u][i];\n                du[v]--;\n                if (!du[v]) q.push({v});\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) printf(\"%d%c\", out[i], i == 0 ? '\\n' : ' ');\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 14037388  2015-07-17 11:07:34 Accepted    4857    436MS   4616K   937 B   G++ SIO__Five\n","tags":["逆向思考"],"categories":["ACM"]},{"title":"CF练习赛4","url":"/2014/11/12/拉练4/","content":"# 题目\n- Problem A [CodeForces 9A] Die Roll\n- Problem B [CodeForces 8A] Train and Peter\n- Problem C [CodeForces 7A] Kalevitch and Chess\n- Problem D [CodeForces 7C] Line (扩展欧几里得)\n- Problem E [CodeForces 8C] Looking for Order (bitmasks, dp)\n\n<!-- more -->\n## Problem A Die Roll\n给定三个骰子，已知前两个的数字，问有多大的概率使得第三个骰子的值不小于前两个的最大值。\n\n```\nint main () {\n    int x, y;\n    cin>>x>>y;\n    if (x > y) swap(x, y);\n    x = 6 - y + 1;\n    int g = __gcd(x, 6);\n    if (x == 0) puts(\"0/1\");\n    else cout<<x / g<<\"/\"<<6 / g<<endl;\n    return 0;\n}\n```\n\n## Problem B Train and Peter\n给定三个字符串A，B，C。问B和C是否按照顺序出现在A中（B和C分别为A的子串，且不重复）\n如果只有从左到右可以，输出forward\n如果只有从右到左可以，输出backward\n如果都可以，输出both\n否则输出fantasy\n\n```\nconst int N = 1e5 + 10;\nchar str[N];\nchar a[111], b[111];\nint n, la, lb;\nint get(char a[], char b[], char str[]) {\n    char *t = strstr(str, a);\n    if (!t) return -1;\n    if (strstr(t + la, b)) return 1;\n    return -1;\n}\nint main () {\n    scanf(\"%s%s%s\", str, a, b);\n    n = strlen(str);\n    la = strlen(a); lb = strlen(b);\n    int x = get(a, b, str);\n    reverse(str, str + n);\n    int y = get(a, b, str);\n    if (x == 1 && y == 1) puts(\"both\");\n    else if (x == 1 && y == -1) puts(\"forward\");\n    else if (x == -1 && y == 1) puts(\"backward\");\n    else puts(\"fantasy\");\n    return 0;\n}\n```\n\n## Problem C Kalevitch and Chess\n给定一张8X8的地图，一开始全是白色，每次可以选择一行或一列将其全部染为黑色。现给定一个最终状态的地图，问最少需要染色多少次。\n\n```\nint mp[10][10];\nint b[10][10];\nint main () {\n    int tot = 1 << 16;\n    int mn = 100;\n    char ch;\n    rep(i, 0, 8) {\n        rep(j, 0, 8) {\n            cin>>ch;\n            if (ch == 'B') mp[i][j] = 1;\n            else mp[i][j] = 0;\n        }\n    }\n    for (int i = 0; i < tot; i++) {\n        memset(b, 0, sizeof(b));\n        int t = 0;\n        for (int j = 0; j < 16; j++) if ((i >> j) & 1) {\n            t++;\n            if (j >= 8) for (int l = 0; l < 8; l++) b[l][j - 8] = 1;\n            else rep(l, 0, 8) b[j][l] = 1;\n        }\n        if (t < mn) {\n            bool ok = 1;\n            rep(l, 0, 8) rep(q, 0, 8) if (mp[l][q] != b[l][q]) {\n                ok = 0;\n                break;\n            }\n            if (ok) mn = t;\n        }\n\n    }\n    cout<<mn<<endl;\n    return 0;\n}\n```\n\n## Problem D Line (扩展欧几里得)\n给定一条直线：$Ax+By+C=0$。请在$[-5{\\cdot}10^{18},5{\\cdot}10^{18}]$的范围内找到任意一个在该直线上的整点，否则输出-1\n数据范围：$-2{\\cdot}10^9{\\leq}A,B,C{\\leq}2{\\cdot}10^9$\n\n## 思路\n扩展欧几里得，如果C % gcd(A, B) != 0，无整数点，否则有解。\n\n```\nll x, y;\nll extend_gcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1, y = 0;\n        return a;\n    }\n    else {\n        ll r = extend_gcd(b, a % b, y, x);\n        y -= x * (a / b);\n        return r;\n    }\n}\nint main () {\n    ll A, B, C;\n    cin>>A>>B>>C;\n    if (A == 0) {\n        if (C % B) puts(\"-1\");\n        else {\n            cout<<0<<\" \"<<-C / B<<endl;\n        }\n    } else if (B == 0) {\n        if (C % A) puts(\"-1\");\n        else {\n            cout<<-C / A<<\" \"<<0<<endl;\n        }\n    } else {\n        ll d = __gcd(A, B);\n        if (C % d) puts(\"-1\");\n        else {\n            extend_gcd(A, B, x, y);\n            ll tx = x * (-C / d), ty = y * (-C / d);\n            cout<<tx<<\" \"<<ty<<endl;\n        }\n    }\n    return 0;\n}\n```\n\n## Problem E Exposition (bitmasks, dp)\n给定起点，以及$n$个物品的位置。现在规定每次从起点出发，可以选择一个物品，并且将其带回起点；或者选择两个物品，先后走到两个物品处，将其带回起点。问将所有物品带回起点的最少时间，每段路程的时间为该路程值的平方。\n数据范围：$1{\\leq}n{\\leq}24$\nhttp://siofive.github.io/2014/11/12/拉练4_E/\n\n# 更新日志\n- 2014-11-12 AK\n","categories":["Contest"]},{"title":"CF 8C Looking for Order (bitmasks, dp)","url":"/2014/11/12/拉练4_E/","content":"# 题目\n源地址：http://codeforces.com/problemset/problem/8/C\n\n# 题意\n给定起点，以及$n$个物品的位置。现在规定每次从起点出发，可以选择一个物品，并且将其带回起点；或者选择两个物品，先后走到两个物品处，将其带回起点。问将所有物品带回起点的最少时间，每段路程的时间为该路程值的平方。并且输出路径。\n数据范围：$1{\\leq}n{\\leq}24$\n\n# 思路\n用dp[i]表示i状态时所花的最短时间。\n那么从i状态出发，可以选择一个没有选过的物品v，即$j = i | 1 << v$, 转移方程为：$dp[j] = min(dp[j], dp[i] + dis[v] * 2)$\n或者选择两个没有选过的物品v，l，即$j = i | 1 << v | 1 << l$, 转移方程为：$dp[j] = min(dp[j], dp[i] + dis[v] + a[v][l] + dis[l])$\n但这样做还时间复杂度很大，会TLE。这里有个神奇的剪枝，因为所有的物品先取后取不影响结果，所以我们可以人为的规定一个取物品的顺序（从小到大）。（详见代码）\n\n<!-- more -->\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\n#define sqr(x) (x) * (x)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int maxn = 1e5 + 10;\nint sx, sy;\nint x[25], y[25], n;\nint dp[1 << 24], pre[1 << 24];\nint a[24][24], d[25];\nint main () {\n    scanf(\"%d%d%d\", &sx, &sy, &n);\n    for (int i = 0; i < n; i++) scanf(\"%d%d\", x + i, y + i);\n    for (int i = 0; i < n; i++) {\n        d[i] = sqr(x[i] - sx) + sqr(y[i] - sy);\n        for (int j = 0; j < n; j++) a[i][j] = sqr(x[i] - x[j]) + sqr(y[i] - y[j]);\n    }\n    int tot = 1 << n;\n    for (int i = 0; i < tot; i++) if (i == 0 || dp[i]) {\n        for (int j = 0; j < n; j++) if (!((i >> j) & 1)){\n            int v = i | (1 << j);\n            int s = d[j] * 2;\n            if (!dp[v] || dp[v] > dp[i] + s) dp[v] = dp[i] + s, pre[v] = i;\n            for (int l = j + 1; l < n; l++) if (!((i >> l) & 1)) {\n                s = d[j] + a[j][l] + d[l];\n                v = i | (1 << l) | (1 << j);\n                if (!dp[v] || dp[v] > dp[i] + s) dp[v] = dp[i] + s, pre[v] = i;\n            }\n            break; //每次只选择最小的进行状态的更新，然后就跳出\n        }\n    }\n    printf(\"%d\\n\", dp[tot - 1]);\n    cout<<0;\n    for (int t = tot - 1; t; t = pre[t]) {\n        int s = t ^ pre[t];\n        for (int i = 0; i < n; i++) if ((s >> i) & 1) cout<<\" \"<<i + 1;\n        cout<<\" \"<<0;\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-12 AC\n","tags":["bitmasks"],"categories":["ACM"]},{"title":"CF练习赛3","url":"/2014/11/09/拉练3/","content":"# 题目\n- Problem A [CodeForces 6A] Triangle (水题)\n- Problem B [CodeForces 6C] Alice, Bob and Chocolate (水题) \n- Problem C [CodeForces 6B] President's Office (水题)\n- Problem D [CodeForces 5C] Longest Regular Bracket Sequence (贪心)\n- Problem E [CodeForces 6E] Exposition (二分, RMQ)\n\n<!-- more -->\n## Problem A Triangle (水题)\n给出四个数字，从中任意选取三个，问能否构成三角形。如果不能，能否构成退化的三角形（即两边之和等于第三遍）\n\n## 思路\n每次选出三个数字，试试看能否构成三角形。试的时候可以先将数字排序一下。\n\n```\nint a, b, c, d;\nint get(int x, int y, int z) {\n    if (x > y) swap(x, y);\n    if (x > z) swap(x, z);\n    if (y > z) swap(y, z);\n    if (x + y > z) return 1;\n    if (x + y == z) return 0;\n    return -1;\n}\nint main () {\n    cin>>a>>b>>c>>d;\n    int q = get(a, b, c);\n    int w = get(a, b, d);\n    int x = get(a, c, d);\n    int y = get(b, c, d);\n    if (q == 1 || w == 1 || x == 1 || y == 1) puts(\"TRIANGLE\");\n    else if (q == 0 || w == 0 || x == 0 || y == 0) puts(\"SEGMENT\");\n    else puts(\"IMPOSSIBLE\");\n    return 0;\n}\n```\n\n## Problem B Alice, Bob and Chocolate (水题) \n有一排巧克力，Alice和Bob分别从两头开始吃巧克力，Alice从左边，Bob右边。每个巧克力要消耗不同的时间，两个人不能同时吃一块巧克力。当两人要同时开始吃一块时，Bob会让Alice吃，问Alice和Bob各可以吃几块巧克力。\n\n## 思路\n模拟一下就行。或者直接从中间时间找一下。\n\n```\nconst int N = 1e5 + 10;\nint n;\nint a[N];\nint main () {\n    cin>>n;\n    a[0] = 0;\n    int x;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &x);\n        a[i] = a[i - 1] + x;\n    }\n    if (n == 1) {\n        cout<<1<<\" \"<<0<<endl;\n        return 0;\n    }\n    int id = lower_bound(a + 1, a + n + 1, a[n] / 2) - a;\n    for (int j = max(id - 3, 1); j <= min(id + 3, n); j++) {\n        if (a[j - 1] > a[n] - a[j]) {\n            cout<<j - 1<<\" \"<<n - j + 1<<endl;\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n## Problem C President's Office (水题)\n给定一个地图，'R'表示boss的地盘，'.'表示空地，其他字符表示小怪的地盘。问与'R'相邻的小怪有多少种。\n\n## 思路\n对于每个'R'，上下左右搜一下，统计一下小怪数。\n\n```\nint n, m;\nchar mp[111][111];\nint dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nchar p;\nint pos[10010][2], cnt;\nmap<char, int> has;\nint main () {\n    cin>>n>>m>>p;\n    cnt = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin>>mp[i][j];\n            if (mp[i][j] == p) {\n                pos[cnt][0] = i, pos[cnt++][1] = j;\n            }\n        }\n    }\n    int sum = 0;\n    has.clear();\n    has[p] = 1;\n    for (int t = 0; t < cnt; t++) {\n        int x = pos[t][0], y = pos[t][1];\n        for (int i = 0; i < 4; i++) {\n            int tx = x + dx[i], ty = y + dy[i];\n            if (POSIN(tx, ty) && mp[tx][ty] != '.') {\n                int d = ++has[mp[tx][ty]];\n                if (d == 1) sum++;\n            }\n        }\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n```\n\n## Problem D Longest Regular Bracket Sequence (贪心)\n给定一串括号，长度为$n$, 求最长的能够匹配的(符合规则)的子序列，输出最长的长度，以及该长度的个数。如果没有匹配的，输出0 1\n数据范围：$1{\\leq}n{\\leq}10^6$\nhttp://siofive.github.io/2014/11/09/拉练3_D/\n\n## Problem E Exposition (二分, RMQ, set)\n给定$n$个数，每个数为$h_i$，以及一个$k$。求最长的区间，使得该区间内所有数字的差值不超过$k$。第一行输出区间长度以及区间的个数，第二行输出每个区间$[l_i, r_i]$\n数据范围：$1{\\leq}n{\\leq}10^5, 0{\\leq}k, h_i{\\leq}10^6$\nhttp://siofive.github.io/2014/11/09/拉练3_E/\n\n# 更新日志\n- 2014-11-9 AK\n","categories":["Contest"]},{"title":"CF 6E Exposition (二分, RMQ, set)","url":"/2014/11/09/拉练3_E/","content":"# 题目\n源地址：http://codeforces.com/problemset/problem/6/E\n\n# 题意\n给定$n$个数，每个数为$h_i$，以及一个$k$。求最长的区间，使得该区间内所有数字的差值不超过$k$。第一行输出区间长度以及区间的个数，第二行输出每个区间$[l_i, r_i]$\n数据范围：$1{\\leq}n{\\leq}10^5, 0{\\leq}k, h_i{\\leq}10^6$\n\n# 思路\n## 二分 + RMQ\n首先用RMQ预处理出任意区间[l, r]的最大值和最小值。然后二分答案，如果该长度下，存在最大值减最小值的差值不超过$k$，便有解。\n\n## Multiset\n也可以用Multiset来实现，从左到右依次将数字存入Multiset中。每加入一个数，如果此时出现最大值与最小值的差超过$k$，就要从头开始删数字，直到符合条件位置。\n\n<!-- more -->\n# 代码\n## 二分 + RMQ\n```\nconst int maxn = 1e5 + 10;\nint n, k, mx[20][maxn], mn[20][maxn];\nvoid RMQ(int num) {\n    for (int i = 1; i <= log2(num) + 1; i++)\n        for (int j = 1; j <= num; j++) if (j + (1 << i) - 1 <= num) {\n                mx[i][j] = max(mx[i - 1][j], mx[i - 1][j + (1 << i >> 1)]);\n                mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 << i >> 1)]);\n            }\n}\nint get(int st, int ed) {\n    int k = (int) log2(ed - st + 1.0);\n    int mxans = max(mx[k][st], mx[k][ed - (1 << k) + 1]);\n    int mnans = min(mn[k][st], mn[k][ed - (1 << k) + 1]);\n    return mxans - mnans;\n}\nbool check(int mid) {\n    for (int i = 1; i <= n - mid + 1; i++) {\n        if (get(i, i + mid - 1) <= k) return true;\n    }\n    return false;\n}\nint main () {\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &mx[0][i]);\n        mn[0][i] = mx[0][i];\n    }\n    RMQ(n);\n    int l = 0, r = n, mid;\n    while(l < r) {\n        mid = (l + r) >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n        if (l + 1 == r) break;\n    }\n    if (check(r)) l = r;\n    vector< pair<int, int> > g;\n    for (int i = 1; i <= n - l + 1; i++) {\n        if (get(i, i + l - 1) <= k) g.pb(make_pair(i, i + l - 1));\n    }\n    printf(\"%d %d\\n\", l, g.size());\n    for (int i = 0; i < g.size(); i++) cout<<g[i].first<<\" \"<<g[i].second<<endl;\n    return 0;\n}\n```\n\n## Multiset\n```\n#include<cstdio>\n#include<iostream>\n#include<set>\nusing namespace std;\nconst int N = 1e5 + 10;\nmultiset<int> s;\nint n, k, h[N], r[N], mx, cnt, t;\nint main () {\n    cin>>n>>k;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", h + i);\n        s.insert(h[i]);\n        while(*s.rbegin() - *s.begin() > k) s.erase(s.find(h[t++]));\n        int len = i - t + 1;\n        if (len > mx) {\n            mx = len, cnt = 0;\n            r[cnt++] = t;\n        }\n        else if (len == mx) r[cnt++] = t;\n    }\n    cout<<mx<<\" \"<<cnt<<endl;\n    for (int i = 0; i < cnt; i++) printf(\"%d %d\\n\", r[i] + 1, r[i] + mx);\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-9 AC\n","tags":["set"],"categories":["ACM"]},{"title":"CF 5C Longest Regular Bracket Sequence (贪心)","url":"/2014/11/09/拉练3_D/","content":"# 题目\t\n源地址：http://codeforces.com/problemset/problem/5/C\n\n# 题意\n给定一串括号，长度为$n$, 求最长的能够匹配的(符合规则)的子序列，输出最长的长度，以及该长度的个数。如果没有匹配的，输出0 1\n数据范围：$1{\\leq}n{\\leq}10^6$\n\n# 思路\n对于字符串串中的每个')'我们定义两个值：\n1. pos[i]表示')'对应匹配的'('的位置，如果不匹配则为-1。pos[i]可以用栈来存储'('的位置实现。\n2. f[i]表示以该')'结尾能够匹配的最长子序列。\n   首先，我们可以知道如果pos[i]不等于-1，那么(pos[i], i)这个子串一定可以。\n   其次，如果上述符合，再观察pos[i] - 1的位置，如果该位置也为')'，且也被匹配到了，那么该子序列就可以继续向前匹配到f[pos[i] - 1]\n\n<!-- more -->\n# 代码\n```\nconst int N = 1e6 + 10;\nchar str[N];\nint pos[N], f[N];\nint main () {\n    gets(str);\n    int n = strlen(str);\n    int mx = 0, m = 1, cnt = 0;\n    for (int i = 1; i <= n; i++) {\n        if (str[i - 1] == '(') pos[++cnt] = i;\n        else {\n            if (!cnt) continue;\n            f[i] = f[pos[cnt] - 1] + i - pos[cnt] + 1;\n            cnt--;\n            if (f[i] > mx) mx = f[i], m = 1;\n            else if (f[i] == mx) m++;\n        }\n    }\n    cout<<mx<<\" \"<<m<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-9 AC\n","tags":["贪心"],"categories":["ACM"]},{"title":"CF练习赛2","url":"/2014/11/07/拉练2/","content":"# 题目\n- Problem A [CodeForces 5A] Chat Server's Outgoing Traffic (水题)\n- Problem B [CodeForces 5B] Center Alignment (水题) \n- Problem C [CodeForces 4D] Mysterious Present (dp, 最长上升子序列)\n- Problem D [CodeForces 3B] Lorry (贪心)\n- Problem E [CodeForces 2C] Commentator problem (几何, 模拟退火)\n\n<!-- more -->\n## Problem A Chat Server's Outgoing Traffic (水题)\n有一个聊天系统，每次可以进来一个人，出去一个人，或是在系统内的一个人说一些话。而在系统内说的话，所有人（包括自己）的屏幕上都会出现。问所有人的屏幕上总共出现了多少字符。\n\n## 思路\n统计一下人数就好。总数就是每段话的字符串乘以人数的乘积和。\n\n## Problem B Center Alignment (水题)\n有一段文字，现在要把这段文字放在一个方框里，并且居中。如果不能绝对居中的，按照先靠左，再靠右的格式居中。\n\n## 思路\n用一个变量来区分靠左还是靠右。\n\n## Problem C Mysterious Present (dp, 最长上升子序列)\n有一个明信片，宽度为$w$，高度为$h$。以及$n$个信封，每个的宽度为$w_i$，高度为$h_i$，信封$A$的宽度和高度均大于$B$时，$B$可以装进$A$。现在要把明信片装进信封里（规则与信封嵌套一样），且要求信封嵌套的层数最多。问最多能有多少层，并输出嵌套方案。\n数据范围：$1{\\leq}n{\\leq}5000, 1{\\leq}w_i, h_i{\\leq}10^6$\nhttp://siofive.github.io/2014/11/07/拉练2_C/\n\n## Problem D Lorry (贪心)\n有两种船，$A$船的体积为$1$，$B$船的体积为$2$。而每条船的价值不同。现在有$n$条船，给出每条船的体积$t_i$和价值$p_i$。问一个体积为$v$的仓库，怎样存放可以使得价值最大。求最大的价值，并输出存放的船。\n数据范围：$1{\\leq}n{\\leq}10^5, 1{\\leq}v{\\leq}10^9, 1{\\leq}t_i{\\leq}2, 1{\\leq}p_i{\\leq}10^4$\n\n## 思路\n将$A$类型和$B$类型分开，然后按照价值排序。\n如果按照正常的思路：如果两个$A$船的价值和大于$B$船，那么选择两个$A$船，否则选$B$。然后依次处理。\n但上述方法需要处理很多细节，很容易出现问题。其实可以换个思路考虑，枚举选取的$A$船的个数，然后剩下的体积全部装$B$船，找出最大值即可。\n\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nint n, v;\nint ca, cb;\nconst int N = 100000 + 10;\nstruct ka {\n    int c, id;\n}a[N];\nstruct sb {\n    int c, id;\n}b[N];\nbool cmp1(ka s, ka v) {\n    return s.c > v.c;\n}\nbool cmp2(sb s, sb v) {\n    return s.c > v.c;\n}\nvector<int> g;\nint s_a[N], s_b[N];\nint main () {\n    cin>>n>>v;\n    int t, c;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &t, &c);\n        if (t == 1) a[ca].c = c, a[ca++].id = i + 1;\n        else b[cb].c = c, b[cb++].id = i + 1;\n    }\n    sort(a, a + ca, cmp1);\n    sort(b, b + cb, cmp2);\n    s_a[0] = 0;\n    for (int i = 0; i < ca; i++) {\n        s_a[i + 1] = s_a[i] + a[i].c;\n    }\n    s_b[0] = 0;\n    for (int i = 0; i < cb; i++) {\n        s_b[i + 1] = s_b[i] + b[i].c;\n    }\n    int na = 0, nb = 0;\n    int sum = 0;\n    int mx = 0;\n    for (int i = 0; i <= ca; i++) {\n        if (i > v) break;\n        int les = (v - i) / 2;\n        if (les >= cb) les = cb;\n        int tmp = s_a[i] + s_b[les];\n        if (tmp > mx) {\n            na = i, nb = les;\n            mx = tmp;\n        }\n    }\n    cout<<mx<<endl;\n    for (int i = 0; i < na; i++) printf(\"%d \", a[i].id);\n    for (int i = 0; i < nb; i++) printf(\"%d \", b[i].id);\n    cout<<endl;\n    return 0;\n}\n```\n\n## Problem E Commentator problem (几何, 模拟退火)\n给定三个圆的圆心坐标$(x_i, y_i)$和半径$r_i$，求点使得在该点看三个圆的视角相同，如果有多个点，取视角最大的点。\n数据范围：$-10^3{\\leq}x_i, y_i{\\leq}10^3, 1{\\leq}r_i{\\leq}10^3$\nhttp://siofive.github.io/2014/11/07/拉练2_E/\n\n# 更新日志\n- 2014-11-7 AK\n","categories":["Contest"]},{"title":"CF 2C Commentator problem (几何, 模拟退火)","url":"/2014/11/07/拉练2_E/","content":"# 题目\t\n源地址：http://codeforces.com/problemset/problem/2/C\n\n# 题意\n给定三个圆的圆心坐标$(x_i, y_i)$和半径$r_i$，求点使得在该点看三个圆的视角相同，如果有多个点，取视角最大的点。\n数据范围：$-10^3{\\leq}x_i, y_i{\\leq}10^3, 1{\\leq}r_i{\\leq}10^3$\n\n<!-- more -->\n# 方法1\n从某个点观察某个圆的视角为：$2asin\\frac{r}{d}$，其中$r$为圆的半径，$d$为点到圆心的半径。\n所以对于两个圆来说：\n两者的半径相同，那么观察视角相同的点所形成的曲线为一条直线，即两圆心所在直线的垂直平分线。\n两者的半径不同，那么曲线为圆。为什么为圆呢，将圆心所在的直线设为$x$轴，其中一个圆心为原点，然后设视角相同的点为$(x, y)$，根据前面提到的视角相同的条件列出方程，会发现$x^2, y^2$的系数相同且不为0。所以曲线为圆。\n知道这个线索之后，接下来题目就容易了。(只是理论AC容易了好么..)\n圆$1$，圆$2$的曲线和圆$2$，圆$3$的曲线的交点即是所求的点，如果有多个点，取视角最大的即可。\n问题就是以下几个情况：\n- 两直线求交点\n- 直线和圆求交点\n- 圆和圆求交点\n\n```\n挖个坑，这个方法还没有AC。\n```\n\n# 方法2\n神奇的模拟退火！\n模拟退火是一个随机算法，原理大致是：在某个局部解的周围随机的探测，如果有更优解，则更新。(这点和大多数贪心很相似)但与普通贪心不同的是，模拟退火有一个跳出局部解的机制，即会选择非最优解也进行进一步的探测。\n\n先来一份CF上看到的题解，选取重心为最开始的探测点，然后上下左右四个方向进行探测。但该方法没有一般性。后面有较为一般性的模拟退火\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\n#define sqr(x) (x) * (x)\ntypedef long long ll;\ntypedef unsigned long long ULL;\ndouble x[3], y[3], r[3], g[3];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\ndouble f(double ax, double ay) { //f函数是三个视角中两两差的平方和，用来衡量解的优劣\n    for (int i = 0; i < 3; i++)\n        g[i] = sqrt(sqr(x[i] - ax) + sqr(y[i] - ay)) / r[i];\n    double tmp = 0;\n    for (int i = 0; i < 3; i++)\n        tmp += sqr(g[i] - g[(i + 1) % 3]);\n    return tmp;\n}\nint main () {\n    double dt = 1, ax = 0, ay = 0;\n    for (int i = 0; i < 3; i++) {\n        scanf(\"%lf%lf%lf\", x + i, y + i, r + i);\n        ax += x[i], ay += y[i];\n    }\n    ax /= 3, ay /= 3; //选择重心进行探测\n    while(dt > eps) {\n        int fg = -1;\n        double now = f(ax, ay);\n        for (int i = 0; i < 4; i++) { //从四个方向进行探测\n            double nxt = f(ax + dx[i] * dt, ay + dy[i] * dt);\n            if (nxt < now) now = nxt, fg = i;\n        }\n        if (fg == -1) dt *= 0.5; //如果四个方向都没有找到最优解，则减小步长\n        else ax += dx[fg] * dt, ay += dy[fg] * dt; //否则更新探测中心\n    }\n    if (f(ax, ay) < eps) printf(\"%.5lf %.5lf\\n\", ax, ay);\n    return 0;\n}\n```\n\n上述的探测方式没有一般性，下面是较为一般性的探测方式。(ps 还没有写完)\n```\n我又来挖坑了==|\n```\n\n# 更新日志\n- 2014-11-7 AC\n","tags":["模拟退火"],"categories":["ACM"]},{"title":"CF 4D Mysterious Present (dp, 最长上升子序列)","url":"/2014/11/07/拉练2_C/","content":"# 题目\t\n源地址：http://codeforces.com/problemset/problem/4/D\n\n# 题意\n有一个明信片，宽度为$w$，高度为$h$。以及$n$个信封，每个的宽度为$w_i$，高度为$h_i$，信封$A$的宽度和高度均大于$B$时，$B$可以装进$A$。现在要把明信片装进信封里（规则与信封嵌套一样），且要求信封嵌套的层数最多。问最多能有多少层，并输出嵌套方案。\n数据范围：$1{\\leq}n{\\leq}5000, 1{\\leq}w_i, h_i{\\leq}10^6$\n\n<!-- more -->\n# 方法1\n由于n才5000，所以可以采用记忆化搜索来做，$dp[i]$表示以$i$信封为最内层，可以有多少层。\n每搜到一个信封$i$，如果之前已经搜索过了，返回$dp[i]$。\n否则先操作$dp[i] = 1$(因为一个信封为$1$层)。然后对其他所有信封进行搜索，如果其中有信封$j$能作为$i$信封的外层，且$dp[j] + 1 > dp[i]$，更新$dp[i]$。\n从明信片开始搜索。\n\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int N = 5010;\nint n, w[N], h[N], nxt[N], dp[N];\nint gao(int x) {\n    if (dp[x]) return dp[x];\n    dp[x] = 1;\n    for (int i = 0; i <= n; i++) if (w[i] > w[x] && h[i] > h[x]) {\n        if (gao(i) + 1 > dp[x]) {\n            nxt[x] = i;\n            dp[x] = dp[i] + 1;\n        }\n    }\n    return dp[x];\n}\nint main () {\n    cin>>n;\n    for (int i = 0; i <= n; i++) {\n        scanf(\"%d%d\", w + i, h + i);\n        nxt[i] = -1;\n    }\n    gao(0);\n    cout<<dp[0] - 1<<endl;\n    for (int i = nxt[0]; i != -1; i = nxt[i]) printf(\"%d \", i);\n    return 0;\n}\n```\n\n# 方法2\n首先先将信封进行筛选，即去除那些装不了明信片的。然后求二维偏序集$(x,y)$的最长上升子序列即可。\n求法是：先按照其中一维进行从小到大排序，第一维相同，按第二维从小到大排序，这样排序的目的是保证只有排在后面的信封才有可能装排在前面的信封。\n然后按照$O(N^2)$的思想找到最长上升子序列即可。\n\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int N = 5010;\nstruct node {\n    int w, h, id;\n}e[N];\nbool cmp(node s, node v) {\n    if (s.w != v.w) return s.w < v.w;\n    return s.h < v.h;\n}\nint dp[N], pre[N];\nint main () {\n    int n, w, h;\n    scanf(\"%d%d%d\", &n, &w, &h);\n    int x, y, cnt = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        if (x > w && y > h) e[cnt++] = {x, y, i + 1};\n    }\n    sort(e, e + cnt, cmp);\n    int mx = 0, fg = -1;\n    for (int i = 0; i < cnt; i++) {\n        pre[i] = -1;\n        dp[i] = 1;\n        for (int j = 0; j < i; j++) if (e[j].w < e[i].w && e[j].h < e[i].h) {\n            if (dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1;\n                pre[i] = j;\n            }\n        }\n        if (dp[i] > mx) mx = dp[i], fg = i;\n    }\n    cout<<mx<<endl;\n    vector<int> v;\n    for (int i = fg; i != -1; i = pre[i]) v.pb(e[i].id);\n    reverse(v.begin(), v.end());\n    for (int i = 0; i < v.size(); i++) cout<<v[i]<<\" \";\n    if (fg != -1) cout<<endl;\n}\n```\n\n# 更新日志\n- 2014-11-7 AC\n","tags":["最长上升子序列"],"categories":["ACM"]},{"title":"BestCoder Round 16","url":"/2014/11/04/BC16/","content":"# 题目\n源地址：http://acm.hdu.edu.cn/search.php?field=problem&key=BestCoder+Round+%2316&source=1&searchmode=source\n- 5086 Revenge of Segment Tree (水题)\n- 5087 Revenge of LIS II (dp)\n- 5088 Revenge of Nim II (高斯消元)\n- 5089 Revenge of iSea (数学 概率)\n\nBC第16场，感觉题目质量还可以。最近状态不太好，以前组队赛太依赖孟神的dp了，导致现在完全不会dp。。这是个忧伤的故事\n\n<!-- more -->\n# 1001 Revenge of Segment Tree (水题)\n求一个序列的所有连续子序列的序列和的和。\n## 思路\n考虑每个数出现在多少个子序列之中，假设第i个数为$A_i$，区间为[L,R]。那么包含$A_i$的区间满足$L{\\leq}i{\\bigcap}R{\\geq}i$。累加$(L+1){\\times}(N−R){\\times}A[i]$就可以了。\n复杂度：O(N)\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int N = 447000 + 30;\nconst int mod = 1000000007;\nint n;\nint main () {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d\", &n);\n        ll ans = 0;\n        int k;\n        for (int i = 1;i <= n; i++) {\n            scanf(\"%d\", &k);\n            ll s = i, ed = (n - i) + 1;\n            ll p = (((s * ed) % mod) * k) % mod;\n            ans = (ans + p) % mod;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n```\n\n# 1002 Revenge of LIS II (dp)\n求序列第二长的上升子序列。\nhttp://siofive.github.io/2014/11/04/BC16_2/\n\n# Revenge of Nim II (高斯消元)\nNim游戏的后手作弊移走一些整堆的物体（不能全拿走），可以保证先手必败吗？\nhttp://siofive.github.io/2014/11/04/BC16_3/\n\n# Revenge of iSea (数学 概率)\n给出N道难度递增的题目，难度用可能做出的百分比表示，选出K道题目使得做出K-1道题目的概率最大。\nhttp://siofive.github.io/2014/11/04/BC16_4/\n\n# 更新日志\n- 2014-11-4 AK","categories":["Contest"]},{"title":"hdu 5089 Revenge of iSea (数学 概率)","url":"/2014/11/04/BC16_4/","content":"# 题目\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5089\n\n# 题意\n给出N道难度递增的题目，难度用可能做出的百分比表示，选出K道题目使得做出K-1道题目的概率最大。\n\n<!-- more -->\n# 思路\n假设最优解已经包含了k-1个了，现在来选取最后一个。K-1个全部做出的概率是$P_a(k-1)$，有一道未做出的概率是$P_l(k−1)$，现在选取的是$P_k$，那么做出K-1道的概率是\n$P_a(k−1){\\times}(1−P_k)+P_l(k−1){\\times}P_k=P_a(k−1)+P_k{\\times}(P_l(k−1)−P_a(k−1))$\n这是一个关于$P_k$的一次函数，如果$P_l(k−1)−P_a(k−1)$为正，选取最大的$P_k$，否则选取最小的。\n这样，可以证明答案一定是选取两边的概率，枚举比较一下就可以算出最大的概率了。\n还有最后一个问题，需要求字典序最小的。对于左边选取的$P_i$，当然index越小越好，对于右边的，如果存在相同的value，应该选取index较小的。比如90 80 30 30，如果答案是第一个和最后一个，为了取得最小的字典序，需要用第三个来替换一下第四个。\n\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-8\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\ndouble p[50];\nint vis[50];\nint main () {\n    int t, n, k;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d%d\", &n, &k);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf\", p + i);\n            p[i] /= 100;\n        }\n        memset(vis, 0, sizeof(vis));\n        int pos[50], cnt = 0, tot = 0;\n        double ans = 0;\n        for (int i = 0; i <= k; i++) {\n            cnt = 0;\n            for (int j = 0; j < i; j++) pos[cnt++] = j;\n            for (int j = 0; j < k - i; j++) pos[cnt++] = n - j - 1;\n            double res = 0;\n            for (int j = 0; j < cnt; j++) {\n                double tmp = 1;\n                for (int l = 0; l < cnt; l++) {\n                    if (l != j) tmp *= p[pos[l]];\n                    else tmp *= (1 - p[pos[l]]);\n                }\n                res += tmp;\n            }\n            //cout<<res<<endl;\n            if (res - ans > -eps) { //这里为-eps是为了保证选的为最小字典序\n                ans = res;\n                tot = i;\n            }\n        }\n        for (int i = 0; i < tot; i++) vis[i] = 1;\n        int now;\n        for (int i = n - (k - tot); i < n; i++) {\n            now = i;\n            for (int j = i; j >= 0; j--) {\n                if (vis[j] || p[j] > p[i]) break;\n                now = j;\n            }\n            vis[now] = 1;\n        }\n        for (int i = 0, j = 0; i < n; i++) {\n            if (vis[i]) {\n                j++;\n                printf(\"%d%c\", i + 1, j == k ? '\\n' : ' ');\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-4 AK","tags":["概率"],"categories":["ACM"]},{"title":"hdu 5088 Revenge of Nim II (高斯消元)","url":"/2014/11/04/BC16_3/","content":"# 题目\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5088\n\n# 题意\nNim游戏的后手作弊移走一些整堆的物体（不能全拿走），可以保证先手必败吗？\n\n<!-- more -->\n# 思路\nNim游戏先手必败的条件是$XORSum(a[i])=0$。后手的目的就是找到这样的一个非空子集。把这里的a[i]看做一个每位为0或1的行，所有的数字组成一个矩阵，矩阵空间的运算是XOR。\n可以发现，$10^{12}$最多为40位二进制，所以当数字个数大于40时，对该矩阵高斯消元之后，一定有某些行全为0，代表着该数字和其他数字异或之后为0。\n当数字个数小于等于40时，对该矩阵进行高斯消元，如果矩阵的秩小于数字个数，代表能异或为0。\n\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int maxn = 65;\nconst int N = 1010;\nll a[N];\nint b[maxn][maxn];\nint rnk(int a[maxn][maxn], int n, int m) {\n    int ret = 0;\n    for (int i = 0, pivot = 0; i < n && pivot < m; ++pivot) {\n        int pos = -1;\n        for (int j = i; j < n; j++) {\n            if (a[j][pivot] == 1) {\n                pos = j;\n                break;\n            }\n        }\n        if (pos == -1) continue;\n        if (pos != i) {\n            for (int j = pivot; j < m; j++) swap(a[i][j], a[pos][j]);\n        }\n        ++ret;\n        for (int j = 0; j < n; j++) {\n            if (a[j][pivot] && j != i) {\n                for (int k = pivot; k < m; k++) a[j][k] ^= a[i][k];\n            }\n        }\n        i++;\n    }\n    return ret;\n}\nint main () {\n    int t, n;\n    scanf(\"%d\", &t);\n    while(t--) {\n        ll sum = 0;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) {\n            scanf(\"%I64d\", a + i);\n            sum ^= a[i];\n        }\n        if (n > maxn || sum == 0) {\n            puts(\"Yes\");\n            continue;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < maxn; j++) {\n                b[i][j] = a[i] >> j & 1;\n            }\n        }\n        if (rnk(b, n, maxn) < n) puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-4 AK","tags":["高斯消元"],"categories":["ACM"]},{"title":"hdu 5087 Revenge of LIS II (dp)","url":"/2014/11/04/BC16_2/","content":"# 题目\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=5087\n\n# 题意\n求序列第二长的上升子序列。\n\n# 思路\nLIS的$O(N^2)$做法是$dp[i]=max(dp[j]|a[j]<a[i])+1$。如果需要第二大的，额外开一维，记录到该位的最大长度能否由多个序列得到。\n复杂度：$O(N^2)$\n\n<!-- more -->\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int maxn = 1100;\nint a[maxn], dp[maxn][2], mx, ok, n;\nint main () {\n    int t;\n    scanf(\"%d\", &t);\n    while(t--) {\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n        mx = -1;\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1, dp[i][1] = 0;\n            for (int j = 0; j < i; j++) if (a[i] > a[j]) {\n                if (dp[i][0] < dp[j][0] + 1) dp[i][0] = dp[j][0] + 1, dp[i][1] = dp[j][1];\n                else if (dp[i][0] == dp[j][0] + 1) dp[i][1] = 1;\n            }\n            //cout<<dp[i][0]<<\" \"<<dp[i][1]<<endl;\n            if (dp[i][0] > mx) mx = dp[i][0];\n        }\n        ok = 0;\n        int has = 0;\n        for (int i = 0; i < n; i++) if (dp[i][0] == mx) {\n            ok++;\n            if (dp[i][1]) has = 1;\n        }\n        if (ok > 1 || has) cout<<mx<<endl;\n        else cout<<mx - 1<<endl;\n    }\n    return 0;\n}\n/*\n6\n3 5 2 5 1 6\n*/\n```\n\n# 更新日志\n- 2014-11-4 AC","tags":["最长上升子序列"],"categories":["ACM"]},{"title":"CF练习赛1","url":"/2014/11/02/拉练1/","content":"# 题目\t\n源地址：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=61581#overview\n- Problem A Before an Exam (水题)\n- Problem B The least round way (DP)\n- Problem C Tic-tac-toe (模拟)\n- Problem D\tAncient Berland Circus (几何)\n- Problem E\tLeast Cost Bracket Sequence (贪心)\n\n这场比赛做的很挫，水过A之后，看到学弟出了D，就去看D，发现可敲（不知道怎么发现的。。）敲一半不知道怎么处理圆心角了（赛后发现n才100！NM呀，这么重要的范围我竟然自动跳过了。n这么小枚举即可）。之后去做B，发现是个水DP（我这个不搞DP的都会，一定是水DP），但是在记录路径的时候写错坐标了。。一直没发现错。。然后听说C是模拟，便去看C。脑洞大开，以为接下来不管双方怎么走都赢不了才算平局，没什么太好的办法，只能二进制枚举一下。。然后死活不对。。最后时刻被告之是理解错题了。。sad。E比赛时候没时间看了。\n\n<!-- more -->\n# Problem A Before an Exam\n给定$d$天，每天可以学习$[min_i,max_i]$个小时，问如果一共学习了$sum$个小时，能否合理安排每天的学习，使得满足要求。\n# 思路\n求一下最小值和，最大值和，如果sum在之间，一定满足。\n\n# Problem B The least round way\n给定一个$n × n$的矩阵，每个格子上有一个数字。现在从左上角走到右下角，规定每次只能向右、向下走，每走到一格，得到该格子上的数字。问怎么走，能够使得这些数字的乘积末尾0最少。给出最少的0和路径。\n# 思路\n对于每一个数字，进行处理，我们只需要知道这个数字分别是2、5的多少次方。\n先每次走的时候，先保证取2最小，（2一样的时候，5要最小），且在走的过程中记录路径。\n然后反着来一遍，先保证取5最小，（5一样的时候，2要最小），且在走的过程中记录路径。\n最后的答案就是上面两个的最小值。\n这道题有个trick：有可能数字为0。如果起点或终点为0，乘积一定为0，否则上述得到的最小值大于1，那么便不取，而是选择走0那条路径。\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nconst int N = 1000 + 10;\nint a[N][N][2];\nint dp[N][N];\nint ss[N][N];\nint pre[N][N][2];\nint pre1[N][N][2];\nstring str;\nvoid out(int o, int x, int y) {\n    //cout<<x<<\" \"<<y<<endl;\n    if (x == -1 && y == -1) {\n        reverse(str.begin(), str.end());\n        cout<<str<<endl;\n        return ;\n    } else {\n        if (o == 2) {\n            int tx = pre[x][y][0], ty = pre[x][y][1];\n            if (tx == -1 || ty == -1) ;\n            else {\n                if (tx == x - 1) str += 'D';\n                else str += 'R';\n            }\n            out(2, tx, ty);\n        } else {\n            int tx = pre1[x][y][0], ty = pre1[x][y][1];\n            if (tx == -1 || ty == -1) ;\n            else {\n                if (tx == x - 1) str += 'D';\n                else str += 'R';\n            }\n            out(1, tx, ty);\n        }\n    }\n}\nint main () {\n    int n;\n    cin >> n;\n    int sx = -1, sy = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int x, s = 0, b = 0;\n            scanf(\"%d\", &x);\n            while(x % 2 == 0 && x) {\n                s++;\n                x /= 2;\n            }\n            while(x % 5 == 0 && x) {\n                b++;\n                x /= 5;\n            }\n            if (x == 0) {\n                sx = i, sy = j;\n                a[i][j][0] = INF, a[i][j][1] = INF;\n            }a[i][j][0] = s, a[i][j][1] = b;\n        }\n    }\n    if (a[0][0][0] == INF || a[n - 1][n - 1][0] == INF) {\n        cout<<1<<endl;\n        for (int i = 0; i < n - 1; i++) cout<<\"D\";\n        for (int i = 0; i < n - 1; i++) cout<<\"R\";\n        return 0;\n    }\n    dp[0][0] = a[0][0][0], ss[0][0] = a[0][0][1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!i && !j) continue;\n            dp[i][j] = INF, ss[i][j] = INF;\n            if (i) {\n                if ((dp[i][j] > dp[i - 1][j] + a[i][j][0]) || ((dp[i][j] == dp[i - 1][j] + a[i][j][0]) && ss[i][j] > ss[i - 1][j] + a[i][j][1])){\n                    dp[i][j] = dp[i - 1][j] + a[i][j][0];\n                    ss[i][j] = ss[i - 1][j] + a[i][j][1];\n                    pre[i][j][0] = i - 1, pre[i][j][1] = j;\n                }\n            }\n            if (j) {\n                if ((dp[i][j] > dp[i][j - 1] + a[i][j][0]) || ((dp[i][j] == dp[i][j - 1] + a[i][j][0]) && ss[i][j] > ss[i][j - 1] + a[i][j][1])){\n                    dp[i][j] = dp[i][j - 1] + a[i][j][0];\n                    ss[i][j] = ss[i][j - 1] + a[i][j][1];\n                    pre[i][j][0] = i, pre[i][j][1] = j - 1;\n                }\n            }\n        }\n    }\n    int mx1 = min(dp[n - 1][n - 1], ss[n - 1][n - 1]);\n\n    dp[0][0] = a[0][0][1], ss[0][0] = a[0][0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!i && !j) continue;\n            dp[i][j] = INF, ss[i][j] = INF;\n            if (i) {\n                if ((dp[i][j] > dp[i - 1][j] + a[i][j][1]) || ((dp[i][j] == dp[i - 1][j] + a[i][j][1]) && ss[i][j] > ss[i - 1][j] + a[i][j][0])){\n                    dp[i][j] = dp[i - 1][j] + a[i][j][1];\n                    ss[i][j] = ss[i - 1][j] + a[i][j][0];\n                    pre1[i][j][0] = i - 1, pre1[i][j][1] = j;\n                }\n            }\n            if (j) {\n                if ((dp[i][j] > dp[i][j - 1] + a[i][j][1]) || ((dp[i][j] == dp[i][j - 1] + a[i][j][1]) && ss[i][j] > ss[i][j - 1] + a[i][j][0])){\n                    dp[i][j] = dp[i][j - 1] + a[i][j][1];\n                    ss[i][j] = ss[i][j - 1] + a[i][j][0];\n                    pre1[i][j][0] = i, pre1[i][j][1] = j - 1;\n                }\n            }\n        }\n    }\n    int mx2 = min(dp[n - 1][n - 1], ss[n - 1][n - 1]);\n    int mx = min(mx1, mx2);\n    if (sx != -1 && mx > 0) {\n        cout<<1<<endl;\n        for (int i = 0; i < sx; i++) cout<<\"D\";\n        for (int i = 0; i < n - 1; i++) cout<<\"R\";\n        for (int i = sx; i < n - 1; i++) cout<<\"D\";\n    } else {\n        pre[0][0][0] = pre[0][0][1] = -1;\n        pre1[0][0][0] = pre1[0][0][1] = -1;\n        cout<<mx<<endl;\n        if (mx1 == mx) out(2, n - 1, n - 1);\n        else out(1, n - 1, n - 1);\n    }\n    return 0;\n}\n```\n\n# Problem C Tic-tac-toe\n有一个游戏，给定一个3 X 3的棋盘，两个人连续在棋盘上放棋子（第一个人为X，第二个人为0），如果出现某行某列或者对角线上全为同样的棋子，那么该人获胜。\n现在的问题是：给定一个棋盘，以及棋盘上的状态（空为.），问分别为以下哪种情况？\n- illegal 棋盘不可能出现这种情况\n- the first player won 第一个人赢\n- the second player won 第二个人赢\n- draw 平局\n- first 接下来轮到第一个人走\n- second 接下来轮到第二个人走 -\n\n# 思路\n其实理解对题意了，就是道很水的题。。\n主要illegal的情况比较多：\n- 双方棋子数不符合规则\n- 双方都赢了\n- 先手赢了，后手还放棋子\n- 后手赢了，先手还放棋子\n然后是判断先手赢、后手赢或是平局（摆满了才有平局。。）最后都不符合，判断该谁走。\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\nchar mp[4][4];\nint fi, se;\nint win(char mp[4][4], int t) {\n    char ch;\n    if (t == 1) ch = 'X';\n    else ch = '0';\n    for (int i = 0; i < 3; i++) {\n        int x = 0;\n        for (int j = 0; j < 3; j++) {\n            if (mp[i][j] == ch) x++;\n        }\n        if (x == 3) return 1;\n    }\n    for (int j = 0; j < 3; j++) {\n        int x = 0;\n        for (int i = 0; i < 3; i++) {\n            if (mp[i][j] == ch) x++;\n        }\n        if (x == 3) return 1;\n    }\n    int x = 0;\n    for (int i = 0; i < 3; i++) {\n        if (mp[i][i] == ch) x++;\n    }\n    if (x == 3) return 1;\n    x = 0;\n    for (int i = 0; i < 3; i++) {\n        if (mp[i][2 - i] == ch) x++;\n    }\n    if (x == 3) return 1;\n    return 0;\n}\nint check() {\n    int x = win(mp, 1);\n    int y = win(mp, 2);\n    //cout<<x<<\" \"<<y<<endl;\n    if (x == 1 && y == 1) return 0;\n    if (x == 1 && fi == se) return 0;\n    if (y == 1 && fi == se + 1) return 0;\n    if (x == 1) return 1;\n    if (y == 1) return 2;\n    if (fi + se == 9) return 3;\n    return 4;\n}\nint main () {\n    fi = se = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            cin>>mp[i][j];\n            if (mp[i][j] == 'X') fi++;\n            else if (mp[i][j] == '0') se++;\n        }\n    }\n    if ((fi > se + 1) || (fi < se)) {\n        puts(\"illegal\");\n        return 0;\n    }\n    int dd = check();\n    if (dd == 0) puts(\"illegal\");\n    else if (dd == 1) puts(\"the first player won\");\n    else if (dd == 2) puts(\"the second player won\");\n    else if (dd == 3) puts(\"draw\");\n    else {\n        if (fi == se) puts(\"first\");\n        else puts(\"second\");\n    }\n    return 0;\n}\n```\n\n# Problem D\t Ancient Berland Circus\n有一个正多边形(3<=n<=100)，现在只知道其中的三个顶点，问这个正多边形最小可能的面积。\nhttp://siofive.github.io/2014/11/02/拉练1_D/\n\n# Problem E\t Least Cost Bracket Sequence\n有一串字符串，每个字符为'(', ')' 或'?'。现在需要将其中的'?'替换为'('或')'，使得最后的括号匹配。每个'?'替换成相应的括号都有一个花费。如果最后不能匹配，输出-1。否则输出最少的花费。\nhttp://siofive.github.io/2014/11/02/拉练1_E/\n\n# 更新日志\n- 2014-11-2 AK\n","categories":["Contest"]},{"title":"CF 3D Least Cost Bracket Sequence (贪心)","url":"/2014/11/02/拉练1_E/","content":"# 题目\t\n源地址：http://codeforces.com/problemset/problem/3/D\n\n# 题意\n有一串字符串，每个字符为'(', ')' 或'?'。现在需要将其中的'?'替换为'('或')'，使得最后的括号匹配。每个'?'替换成相应的括号都有一个花费。如果最后不能匹配，输出-1。否则输出最少的花费。\n\n#思路\n首先要知道，对于每个')'而言，只要它之前的所有')'都被匹配了，且它本身也有'('与它匹配，那么该表达式一定成立。\n所以可以从头到尾的处理，一开始有个值now = 0，花费cost = 0，以及一个优先队列\n碰到'(', now++。\n碰到')', now--。\n碰到'?'，将问号变成')'，同时now++和cost += b (假设 '?'->'(' 费用为a，'?'->')' 费用为b)，然后将pair(b-a,i)放入优先队列。（i为位置）\n发现此时now < 0，即左括号比右括号少时，如果优先队列为空，说明前面已经没有有效的'?'了。即匹配失败。否则从优先队列里挑选一个能最大降低cost的'?'，转化为'('。\n最后看now是否为0即可。\n\n<!-- more -->\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\ntypedef pair<int, int> pii;\nconst int N = 50000 + 10;\npriority_queue< pii > q;\nint main () {\n    char str[N];\n    scanf(\"%s\", str);\n    ll c = 0, now = 0;\n    bool flag = true;\n    for (int i = 0; str[i]; i++) {\n        if (str[i] == '(') now++;\n        else now--;\n        if (str[i] == '?') {\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            str[i] = ')';\n            q.push(mkp(b - a, i));\n            c += b;\n        }\n        if (flag && now < 0) {\n            if (q.empty()) flag = false;\n            else {\n                pii x = q.top(); q.pop();\n                str[x.second] = '(';\n                c -= x.first;\n                now += 2;\n            }\n        }\n    }\n    if (now != 0 || !flag) puts(\"-1\");\n    else cout<<c<<endl<<str<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-2 AC\n","tags":["贪心"],"categories":["ACM"]},{"title":"CF 1C Ancient Berland Circus (几何)","url":"/2014/11/02/拉练1_D/","content":"# 题目\t\n源地址：http://codeforces.com/problemset/problem/1/C\n\n# 题意\n有一个正多边形(3<=n<=100)，现在只知道其中的三个顶点，问这个正多边形最小可能的面积。\n\n# 思路\n首先可以知道，这个正多边形一定是有一个外接圆的。可以通过给定的三个点，构造三角形，然后求得外接圆。\n外接圆的求法：\n  用余弦定理得到角A，然后用正弦定理得到 a / sinA = 2 * R\n之后可以得到每条边对应的圆心角。这三个圆心角一定是正多边形每条边对应圆心角的整数倍。由于n范围很小，才100。只要枚举一下n，找到最小的答案即可。\n  我看网上还有种做法：三个圆心角A，B，C。那么正多边形每条边对应圆心角 = gcd(A, B, C) = gcd(gcd(A, B), C)\n  这里用到了辗转相减法来求double的gcd，机智的做法（这就可以解决n很大的问题了）\n\n<!-- more -->\n```\n/*\nID: wuqi9395@126.com\nPROG:\nLANG: C++\n*/\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<fstream>\n#include<cstring>\n#include<ctype.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 30)\n#define LINF (1LL << 60)\n#define PI acos(-1.0)\n#define mem(a, b) memset(a, b, sizeof(a))\n#define rep(i, a, n) for (int i = a; i < n; i++)\n#define per(i, a, n) for (int i = n - 1; i >= a; i--)\n#define eps 1e-6\n#define debug puts(\"===============\")\n#define pb push_back\n#define mkp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)\ntypedef long long ll;\ntypedef unsigned long long ULL;\ndouble px[3], py[3];\ndouble a, b, c;\ndouble A, B, C;\ndouble dis(int i, int j) {\n    double x = px[i] - px[j], y = py[i] - py[j];\n    return sqrt(x * x + y * y);\n}\ndouble get(double a, double b, double c) {\n    return acos((b * b + c * c - a * a) / (2 * b * c));\n}\nbool check(int n) {\n    double e = 2 * PI / n;\n    //cout<<e<<\"---------\";\n    int x = (A + eps) / e, y = (B + eps) / e, z = (C + eps) / e;\n    //cout<<n<<\" \"<<x<<\" \"<<y<<\" \"<<z<<\" \"<<endl;\n    if (fabs((x + y + z) * e - 2 * PI) < 1e-6) return true;\n    return false;\n}\ndouble cal(int n, double R) {\n    double ans = R * R * sin(2 * PI / n) / 2 * n;\n    return ans;\n}\nint main () {\n    for (int i = 0; i < 3; i++) scanf(\"%lf%lf\", &px[i], &py[i]);\n    a = dis(0, 1);\n    b = dis(1, 2);\n    c = dis(2, 0);\n    //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<endl;\n    //余弦定理得到三角形的角度\n    A = get(a, b, c);\n    B = get(b, a, c);\n    C = get(c, a, b);\n    double R = a / sin(A) / 2;\n    //转化为圆心角\n    A *= 2, B *= 2, C *= 2;\n    //cout<<A<<\" \"<<B<<\" \"<<C<<\" \"<<R<<endl;\n    int n;\n    for (n = 3; n <= 100; n++) {\n        if (check(n)) break;\n    }\n    //cout<<n<<endl;\n    printf(\"%.10lf\\n\", cal(n, R));\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-11-2 AC\n","tags":["几何"],"categories":["ACM"]},{"title":"POJ 3225 Help with Intervals（线段树）","url":"/2014/10/31/poj 3225 线段树/","content":"# 题目\t\n源地址：http://poj.org/problem?id=3225\n\n# 题意\n规定集合的交并补差等操作：\n![](http://siofive.qiniudn.com/poj 3225_1.png)\n现在给定一个区间S,范围为[0, 65535],一开始全为0。\n可以对该集合进行下面五种操作，问最后操作之后有哪些区间为1\n![](http://siofive.qiniudn.com/poj 3225_2.png)\n其中T可以有4种形式：$(a,b) (a,b] [a, b) [a, b]$\n数据范围：$(a, b ∈ Z, 0 ≤ a ≤ b ≤ 65,535)$\n\n# 思路\nU：把区间$[l,r]$置为1\nI：把$[-∞,l),(r,∞]$置成0\nD：把区间$[l,r]$置为0\nC：把$[-∞,l),(r,∞]$置成0, 且$[l,r]$区间0/1互换\nS：$[l,r]$区间0/1互换\n成段替换比较好实现，互换的操作可以用一个XOR[]数组来进行标记。需要注意的是，如果该区间又有替换又有互换的话，只需要做等价的替换操作即可。\n将区间扩大两倍，就能够处理开、闭区间。\n<!--more-->\n\n# 代码\n```\n/*\n    U：把区间[l,r]置为1\n    I：把[-∞,l)(r,∞]置成0\n    D：把区间[l,r]置为0\n    C：把[-∞,l)(r,∞]置成0, 且[l,r]区间0/1互换\n    S；[l,r]区间0/1互换\n*/\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nconst int maxn = 65535 * 2 + 2;\nint col[maxn << 2], XOR[maxn << 2];\nbool has[maxn];\nvoid FXOR(int rt) {\n    if (col[rt] != -1) col[rt] ^= 1;\n    else XOR[rt] ^= 1;\n}\nvoid pushdown(int rt) {\n    if (col[rt] != -1) {\n        col[rt << 1] = col[rt << 1 | 1] = col[rt];\n        XOR[rt << 1] = XOR[rt << 1 | 1] = 0;\n        col[rt] = -1;\n    }\n    if (XOR[rt]) {\n        FXOR(rt << 1);\n        FXOR(rt << 1 | 1);\n        XOR[rt] = 0;\n    }\n}\nvoid update(char op, int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        if (op == 'U') col[rt] = 1, XOR[rt] = 0;\n        else if (op == 'D') col[rt] = 0, XOR[rt] = 0;\n        else if (op == 'C' || op == 'S') FXOR(rt);\n        return ;\n    }\n    pushdown(rt);\n    int m = (l + r) >> 1;\n    if (L <= m) update(op, L, R, lson);\n    else if (op == 'I' || op == 'C') col[rt << 1] = XOR[rt << 1] = 0;\n    if (R > m) update(op, L, R, rson);\n    else if (op == 'I' || op == 'C') col[rt << 1 | 1] = XOR[rt << 1 | 1] = 0;\n}\nvoid query(int l, int r, int rt) {\n    if (col[rt] == 1) {\n        for (int i = l; i <= r; i++) has[i] = true;\n        return ;\n    } else if (col[rt] == 0) return ;\n    if (l == r) return ;\n    pushdown(rt);\n    int m = (l + r) >> 1;\n    query(lson);\n    query(rson);\n}\nint main () {\n    col[1] = XOR[1] = 0;\n    char op, lq, rq;\n    int l, r;\n    while(~scanf(\"%c %c%d,%d%c\\n\", &op, &lq, &l, &r, &rq)) {\n        l <<= 1, r <<= 1;\n        if (lq == '(') l++;\n        if (rq == ')') r--;\n        if (l > r) {\n            if (op == 'I' || op == 'C') col[1] = XOR[1] = 0;\n        } else update(op, l, r, 0, maxn, 1);\n    }\n    query(0, maxn, 1);\n    bool flag = 0;\n    int st = -1, ed;\n    for (int i = 0; i <= maxn; i++) {\n        if (has[i]) {\n            if (st == -1) st = i;\n            ed = i;\n        } else {\n            if (st != -1) {\n                if (flag) putchar(' ');\n                flag = true;\n                printf(\"%c%d,%d%c\", st & 1 ? '(' : '[', st >> 1, (ed + 1) >> 1, ed & 1 ? ')' : ']');\n                st = -1;\n            }\n        }\n    }\n    if (!flag) puts(\"empty set\");\n    puts(\"\");\n    return 0;\n}\n```\n\n# 更新日志\n- 13585854\tSIO__Five\t3225\tAccepted\t2848K\t1188MS\tG++\t2546B\t2014-10-31 21:03:40\n","tags":["线段树"],"categories":["ACM"]},{"title":"POJ 2528 Mayor's posters（线段树）","url":"/2014/10/30/poj 2528 线段树/","content":"# 题目\t\n源地址：http://poj.org/problem?id=2528\n\n# 题意\n有一块长度为$1e7$的板子，现在有$n$张海报，依次贴上板子，后面的海报会覆盖前面的海报。每张海报占据[l, r]的区间。\n求最后能够在板子上看到多少张海报。\n数据范围：$1{\\leq}n{\\leq}1e4$, $1{\\leq}l,r{\\leq}1e7$\n\n如图所示\n![](http://siofive.qiniudn.com/2528_1.jpg)\n5\n1 4\n2 6\n8 10\n3 4\n7 10\n答案为4\n\n# 思路\n由于区间范围很大，但海报数相对较少，所以可以将海报的坐标离散化。\n离散化之后再用线段树维护。\n线段树成段更新，update：成段修改\tquery：区间求种类数\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nconst int maxn = 11111;\nint col[maxn << 4];\nint x[maxn << 2];\nint l[maxn], r[maxn], ans;\nbool has[maxn];\nvoid pushdown(int rt) {\n    if (col[rt] != -1) {\n        col[rt << 1] = col[rt << 1 | 1] = col[rt];\n        col[rt] = -1;\n    }\n}\nvoid update(int L, int R, int c, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        col[rt] = c;\n        return ;\n    }\n    pushdown(rt);\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, c, lson);\n    if (R > m) update(L, R, c, rson);\n}\nvoid query(int l, int r, int rt) {\n    if (col[rt] != -1) {\n        if (!has[col[rt]]) ans++;\n        has[col[rt]] = true;\n        return ;\n    }\n    if (l == r) return ;\n    int m = (l + r) >> 1;\n    query(lson);\n    query(rson);\n}\nint main () {\n    int T, n;\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%d\", &n);\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d%d\", l + i, r + i);\n            x[cnt++] = l[i], x[cnt++] = r[i];\n        }\n        sort(x, x + cnt);\n        cnt = unique(x, x + cnt) - x;\n        memset(col, -1, sizeof(col));\n        for (int i = 0; i < n; i++) {\n            int a = lower_bound(x, x + cnt, l[i]) - x;\n            int b = lower_bound(x, x + cnt, r[i]) - x;\n            update(a, b, i, 0, cnt, 1);\n        }\n        ans = 0;\n        memset(has, 0, sizeof(has));\n        query(0, cnt, 1);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 13582214\tSIO__Five\t2528\tAccepted\t1536K\t63MS\tG++\t1718B\t2014-10-30 20:42:27\n","tags":["线段树"],"categories":["ACM"]},{"title":"POJ 3468 A Simple Problem with Integers（线段树）","url":"/2014/10/29/poj 3468 线段树/","content":"# 题目\t\n源地址：http://poj.org/problem?id=3468\n\n# 题意\n给出一个有$n$个元素的数组，元素一开始有初值。\n现在有$q$次操作，每次操作有两个选择：\n“C a b c”：将[a, b]的所有元素加上c\n“Q a b”：查询[a, b]所有元素的和\n数据范围：$1{\\leq}N,Q{\\leq}1e5$, $-1e9{\\leq}a_i{\\leq}1e9$, $-1e4{\\leq}c{\\leq}1e4$\n\n# 思路\n线段树成段更新，update：成段增减\tquery：区间求和\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nconst int maxn = 111111;\nll sum[maxn << 2], add[maxn << 2];\nvoid pushup(int rt) {\n    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];\n}\nvoid build(int l, int r, int rt) {\n    add[rt] = 0;\n    if (l == r) {\n        scanf(\"%lld\", &sum[rt]);\n        return ;\n    }\n    int m = (l + r) >> 1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\nvoid pushdown(int rt, int m) {\n    if (add[rt]) {\n        add[rt << 1] += add[rt];\n        add[rt << 1 | 1] += add[rt];\n        sum[rt << 1] += (m - (m >> 1)) * add[rt];\n        sum[rt << 1 | 1] += (m >> 1) * add[rt];\n        add[rt] = 0;\n    }\n}\nvoid update(int L, int R, int c, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        add[rt] += c;\n        sum[rt] += c * (r - l + 1);\n        return ;\n    }\n    pushdown(rt, r - l + 1);\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, c, lson);\n    if (R > m) update(L, R, c, rson);\n    pushup(rt);\n}\nll query(int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) return sum[rt];\n    pushdown(rt, r - l + 1);\n    int m = (l + r) >> 1;\n    ll ret = 0;\n    if (L <= m) ret += query(L, R, lson);\n    if (R > m) ret += query(L, R, rson);\n    return ret;\n}\nint main () {\n    int n, q;\n    char ch[10];\n    int l, r, c;\n    scanf(\"%d%d\", &n, &q);\n    build(1, n, 1);\n    while(q--) {\n        scanf(\"%s\", ch);\n        scanf(\"%d%d\", &l, &r);\n        if (ch[0] == 'Q') printf(\"%lld\\n\", query(l, r, 1, n, 1));\n        else {\n            scanf(\"%d\", &c);\n            update(l, r, c, 1, n, 1);\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 13579810\tSIO__Five\t3468\tAccepted\t4776K\t2579MS\tG++\t1770B\t2014-10-29 23:52:08\n","tags":["线段树"],"categories":["ACM"]},{"title":"HDU 1698 Just a Hook（线段树）","url":"/2014/10/29/hdu 1698 Just a Hook/","content":"# 题目\t\n源地址：http://acm.hdu.edu.cn/showproblem.php?pid=1698\n\n# 题意\n给出一个有$n$个元素的数组，有$q$次操作：\n\tset(L, R, v)把区间{L, R}的值全部修改为 $v$(1,2,3)。\n一开始所有值都为1。求最后所有元素的和。\n\n# 思路\n线段树成段更新，要理解lazy的使用。update：成段替换\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nconst int maxn = 111111;\nint sum[maxn << 2], col[maxn << 2];\nvoid pushup(int rt) {\n    sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];\n}\nvoid pushdown(int m, int rt) {\n    if (col[rt]) {\n        col[rt << 1] = col[rt << 1 | 1] = col[rt];\n        sum[rt << 1] = (m - (m >> 1)) * col[rt];\n        sum[rt << 1 | 1] = (m >> 1) * col[rt];\n        col[rt] = 0;\n    }\n}\nvoid build(int l, int r, int rt) {\n    col[rt] = 0;\n    if (l == r) {\n        sum[rt] = 1;\n        return ;\n    }\n    int m = (l + r) >> 1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\nvoid update(int L, int R, int c, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        col[rt] = c;\n        sum[rt] = (r - l + 1) * c;\n        return ;\n    }\n    pushdown(r - l + 1, rt);\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, c, lson);\n    if (R > m) update(L, R, c, rson);\n    pushup(rt);\n}\nint main () {\n    int T, n, q;\n    scanf(\"%d\", &T);\n    for (int cas = 1; cas <= T; cas++) {\n        scanf(\"%d%d\", &n, &q);\n        build(1, n, 1);\n        int x, y, z;\n        while(q--) {\n            scanf(\"%d%d%d\", &x, &y, &z);\n            update(x, y, z, 1, n, 1);\n        }\n        printf(\"Case %d: The total value of the hook is %d.\\n\", cas, sum[1]);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 12011666\t2014-10-29 22:01:13\tAccepted\t1698\t687MS\t2288K\t1458 B\tC++\tSIO__Five\n","tags":["线段树"],"categories":["ACM"]},{"title":"UVa 1354 天平难题 (搜索)","url":"/2014/10/28/UVa 1354 天平难题 搜索/","content":"# 题目\t\n源地址：http://acm.bnu.edu.cn/v3/problem_show.php?pid=36971\n\n# 题意\n给出房间的宽度$r$和$s$个挂坠的重量$w_i$。设计一个尽量宽（但宽度不能超过房间宽度$r$）的天平，挂着所有挂坠。\n天平由一些长度为1的木棍组成。木棍的每一端要么挂着一个挂坠，要么挂着另外一个木棍。\n挂坠的宽度忽略不计，且不同的子天平可以相互重叠。\n数据范围：$(0<r<10, 1{\\leq}s{\\leq}6, 1{\\leq}w_i{\\leq}1000)$\n\n# 思路\n把挂坠和木棍都作为结点，则一个天平对应一棵二叉树，可以容易的算出对应的宽度。\n本题的核心任务就是枚举二叉树，采用回溯法即可。\n枚举的方式是自顶向下构造，每次枚举左子树用到哪个子集，则右子树就是剩下的子集。\n\n# 技巧\n```\nint subset = (1 << n) - 1; //全集\nfor (int left = (subset - 1) & subset; left; left = (left - 1) & subset) {\n\tint right = subset ^ left;  //left和right便是两个对应的子集\n}\n```\n\n<!--more-->\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstruct node {\n    double L, R;\n    node() : L(0), R(0) {}\n};\nconst int N = 6;\nint vis[1 << N], n;\ndouble w[N], sum[1 << N], r;\nvector<node> tree[1 << N];\nvoid dfs(int subset) {\n    if (vis[subset]) return ;\n    vis[subset] = true;\n    bool have_child = false;\n    for (int left = (subset - 1) & subset; left; left = (left - 1) & subset) {\n        have_child = true;\n        int right = subset ^ left;\n        double d1 = sum[right] / sum[subset];\n        double d2 = sum[left] / sum[subset];\n        dfs(left); dfs(right);\n        for (int i = 0; i < tree[left].size(); i++) {\n            for (int j = 0; j < tree[right].size(); j++) {\n                node t;\n                t.L = max(tree[left][i].L + d1, tree[right][j].L - d2);\n                t.R = max(tree[right][j].R + d2, tree[left][i].R - d1);\n                if (t.L + t.R < r) tree[subset].push_back(t);\n            }\n        }\n    }\n    if (!have_child) tree[subset].push_back(node());\n}\nint main () {\n    int T;\n    scanf(\"%d\", &T);\n    while(T--) {\n        scanf(\"%lf%d\", &r, &n);\n        for (int i = 0; i < n; i++) scanf(\"%lf\", w + i);\n        int tot = 1 << n;\n        for (int i = 0; i < tot; i++) {\n            sum[i] = 0;\n            tree[i].clear();\n            for (int j = 0; j < n; j++)\n                if (i & (1 << j)) sum[i] += w[j];\n        }\n        tot--;\n        memset(vis, 0, sizeof(vis));\n        dfs(tot);\n        double ans = -1;\n        for (int i = 0; i < tree[tot].size(); i++)\n            ans = max(ans, tree[tot][i].L + tree[tot][i].R);\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 29 ms\t\t1712 B\t2014-10-28 17:51:13\n","tags":["枚举二叉树"],"categories":["算法竞赛入门经典"]},{"title":"Project Euler 13 Large sum（大数）","url":"/2014/10/28/Project Euler 13/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=13\n\n# 题意\n给定100个50位的大数，求和的前10位\n\n# 思路\n大数\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\nusing namespace std;\nconst int ra = 10;\nint ten[4] = {1, ra, ra * ra, ra*ra * ra};\nint radix = ra * ra * ra * ra;\nconst int NV = 1000;\nstruct integer {\n    int d[NV];\n    integer() {\n        *this = integer(0);\n    }\n    integer(int x) {\n        for (int i = 0; i < NV; i++) d[i] = 0;\n        if (!x) d[0] = 1;\n        while(x) {\n            d[++d[0]] = x % radix;\n            x /= radix;\n        }\n    }\n    integer(long long x) {\n        for (int i = 0; i < NV; i++) d[i] = 0;\n        if (!x) d[0] = 1;\n        while(x) {\n            d[++d[0]] = x % radix;\n            x /= radix;\n        }\n    }\n    integer(const char s[]) {\n        int len = strlen(s), i, j, k;\n        d[0] = (len - 1) / 4 + 1;\n        for (i = 1; i < NV; i++) d[i] = 0;\n        for (i = len - 1; i >= 0; i--) {\n            j = (len - i - 1) / 4 + 1;\n            k = (len - i - 1) % 4;\n            d[j] += ten[k] * (s[i] - '0');\n        }\n        while(d[0] > 1 && d[d[0]] == 0) d[0]--;\n    }\n    string tostring() {\n        string s;\n        int i, j, temp;\n        for (i = 3; i >= 1; i--) if (d[d[0]] >= ten[i]) break;\n        temp = d[d[0]];\n        for (j = i; j >= 0; j--) {\n            s += (char) (temp / ten[j] + '0');\n            temp %= ten[j];\n        }\n        for (i = d[0] - 1; i > 0; i--) {\n            temp = d[i];\n            for (j = 3; j >= 0; j--) {\n                s += (char) (temp / ten[j] + '0');\n                temp %= ten[j];\n            }\n        }\n        return s;\n    }\n} d, mid1[15];\ninteger operator +(const integer &a, const integer &b) {\n    integer c;\n    c.d[0] = max(a.d[0], b.d[0]);\n    int i, x = 0;\n    for (i = 1; i <= c.d[0]; i++) {\n        x += a.d[i] + b.d[i];\n        c.d[i] = x % radix;\n        x /= radix;\n    }\n    while(x) {\n        c.d[++c.d[0]] = x % radix;\n        x /= radix;\n    }\n    return c;\n}\n\n\nchar str[110][60] = {\n    \"37107287533902102798797998220837590246510135740250\",\n    \"46376937677490009712648124896970078050417018260538\",\n    \"74324986199524741059474233309513058123726617309629\",\n    \"91942213363574161572522430563301811072406154908250\",\n    \"23067588207539346171171980310421047513778063246676\",\n    \"89261670696623633820136378418383684178734361726757\",\n    \"28112879812849979408065481931592621691275889832738\",\n    \"44274228917432520321923589422876796487670272189318\",\n    \"47451445736001306439091167216856844588711603153276\",\n    \"70386486105843025439939619828917593665686757934951\",\n    \"62176457141856560629502157223196586755079324193331\",\n    \"64906352462741904929101432445813822663347944758178\",\n    \"92575867718337217661963751590579239728245598838407\",\n    \"58203565325359399008402633568948830189458628227828\",\n    \"80181199384826282014278194139940567587151170094390\",\n    \"35398664372827112653829987240784473053190104293586\",\n    \"86515506006295864861532075273371959191420517255829\",\n    \"71693888707715466499115593487603532921714970056938\",\n    \"54370070576826684624621495650076471787294438377604\",\n    \"53282654108756828443191190634694037855217779295145\",\n    \"36123272525000296071075082563815656710885258350721\",\n    \"45876576172410976447339110607218265236877223636045\",\n    \"17423706905851860660448207621209813287860733969412\",\n    \"81142660418086830619328460811191061556940512689692\",\n    \"51934325451728388641918047049293215058642563049483\",\n    \"62467221648435076201727918039944693004732956340691\",\n    \"15732444386908125794514089057706229429197107928209\",\n    \"55037687525678773091862540744969844508330393682126\",\n    \"18336384825330154686196124348767681297534375946515\",\n    \"80386287592878490201521685554828717201219257766954\",\n    \"78182833757993103614740356856449095527097864797581\",\n    \"16726320100436897842553539920931837441497806860984\",\n    \"48403098129077791799088218795327364475675590848030\",\n    \"87086987551392711854517078544161852424320693150332\",\n    \"59959406895756536782107074926966537676326235447210\",\n    \"69793950679652694742597709739166693763042633987085\",\n    \"41052684708299085211399427365734116182760315001271\",\n    \"65378607361501080857009149939512557028198746004375\",\n    \"35829035317434717326932123578154982629742552737307\",\n    \"94953759765105305946966067683156574377167401875275\",\n    \"88902802571733229619176668713819931811048770190271\",\n    \"25267680276078003013678680992525463401061632866526\",\n    \"36270218540497705585629946580636237993140746255962\",\n    \"24074486908231174977792365466257246923322810917141\",\n    \"91430288197103288597806669760892938638285025333403\",\n    \"34413065578016127815921815005561868836468420090470\",\n    \"23053081172816430487623791969842487255036638784583\",\n    \"11487696932154902810424020138335124462181441773470\",\n    \"63783299490636259666498587618221225225512486764533\",\n    \"67720186971698544312419572409913959008952310058822\",\n    \"95548255300263520781532296796249481641953868218774\",\n    \"76085327132285723110424803456124867697064507995236\",\n    \"37774242535411291684276865538926205024910326572967\",\n    \"23701913275725675285653248258265463092207058596522\",\n    \"29798860272258331913126375147341994889534765745501\",\n    \"18495701454879288984856827726077713721403798879715\",\n    \"38298203783031473527721580348144513491373226651381\",\n    \"34829543829199918180278916522431027392251122869539\",\n    \"40957953066405232632538044100059654939159879593635\",\n    \"29746152185502371307642255121183693803580388584903\",\n    \"41698116222072977186158236678424689157993532961922\",\n    \"62467957194401269043877107275048102390895523597457\",\n    \"23189706772547915061505504953922979530901129967519\",\n    \"86188088225875314529584099251203829009407770775672\",\n    \"11306739708304724483816533873502340845647058077308\",\n    \"82959174767140363198008187129011875491310547126581\",\n    \"97623331044818386269515456334926366572897563400500\",\n    \"42846280183517070527831839425882145521227251250327\",\n    \"55121603546981200581762165212827652751691296897789\",\n    \"32238195734329339946437501907836945765883352399886\",\n    \"75506164965184775180738168837861091527357929701337\",\n    \"62177842752192623401942399639168044983993173312731\",\n    \"32924185707147349566916674687634660915035914677504\",\n    \"99518671430235219628894890102423325116913619626622\",\n    \"73267460800591547471830798392868535206946944540724\",\n    \"76841822524674417161514036427982273348055556214818\",\n    \"97142617910342598647204516893989422179826088076852\",\n    \"87783646182799346313767754307809363333018982642090\",\n    \"10848802521674670883215120185883543223812876952786\",\n    \"71329612474782464538636993009049310363619763878039\",\n    \"62184073572399794223406235393808339651327408011116\",\n    \"66627891981488087797941876876144230030984490851411\",\n    \"60661826293682836764744779239180335110989069790714\",\n    \"85786944089552990653640447425576083659976645795096\",\n    \"66024396409905389607120198219976047599490197230297\",\n    \"64913982680032973156037120041377903785566085089252\",\n    \"16730939319872750275468906903707539413042652315011\",\n    \"94809377245048795150954100921645863754710598436791\",\n    \"78639167021187492431995700641917969777599028300699\",\n    \"15368713711936614952811305876380278410754449733078\",\n    \"40789923115535562561142322423255033685442488917353\",\n    \"44889911501440648020369068063960672322193204149535\",\n    \"41503128880339536053299340368006977710650566631954\",\n    \"81234880673210146739058568557934581403627822703280\",\n    \"82616570773948327592232845941706525094512325230608\",\n    \"22918802058777319719839450180888072429661980811197\",\n    \"77158542502016545090413245809786882778948721859617\",\n    \"72107838435069186155435662884062257473692284509516\",\n    \"20849603980134001723930671666823555245252804609722\",\n    \"53503534226472524250874054075591789781264330331690\"\n};\nint main () {\n    integer A(0);\n    for (int i = 0; i < 100; i++) A = A + integer(str[i]);\n    string s = A.tostring();\n    for (int i = 0; i < 10; i++) cout<<s[i];\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 14:20.23\n","tags":["大数"],"categories":["Project Euler"]},{"title":"Project Euler 12 Highly divisible triangular number（质因数分解）","url":"/2014/10/28/Project Euler 12/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=12\n\n# 题意\n规定$f(n)=1+2+\\cdots+n$\n求最小的$f(n)$使得其因子个数超过500\n\n# 思路\n$N=2^{a_1}3^{a_2}5^{a_3}\\cdots$ 的因子个数为 $(a_1+1)(a_2+1)(a_3+1)\\cdots$\n而$f(n)=\\frac{n(1+n)}{2}$ ，且相邻的两个数一定互质，所以$f(n)$的因子个数 = $\\frac{n}{2}$的因子个数 $*(1+n)$的因子个数（n为偶数）\n\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define maxn 1111111\nint a[maxn], b[maxn], tot = 0;\nvoid factor(int n, int a[], int b[], int &tot) {\n    int tmp, now;\n    tmp = (int)(sqrt(n) + 1);\n    tot = 0;\n    now = n;\n    for (int i = 2; i <= tmp; i++) if (now % i == 0) {\n        a[tot] = i, b[tot] = 0;\n        while(now % i == 0) {\n            b[tot]++;\n            now /= i;\n        }\n        tot++;\n    }\n    if (now != 1) a[tot] = now, b[tot++] = 1;\n}\nint f[maxn] = {0};\nvoid get(int x) {\n    f[x] = 1;\n    factor(x, a, b, tot);\n    for (int i = 0; i < tot; i++) f[x] *= b[i] + 1;\n}\nint main () {\n    int x, y;\n    f[1] = 1, f[2] = 2;\n    for (int i = 3; i; i++) {\n        if (i % 2 == 0) x = i / 2, y = i + 1;\n        else x = (i + 1) / 2, y = i;\n        if (!f[x]) get(x);\n        if (!f[y]) get(y);\n        int ans = f[x] * f[y];\n        if (ans > 500) {\n            cout<<(x * y)<<endl;\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 13:54.49\n","tags":["质因数分解"],"categories":["Project Euler"]},{"title":"Project Euler 11 Largest product in a grid（暴力）","url":"/2014/10/28/Project Euler 11/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=11\n\n# 题意\n给定一个$20*20$的方格，求在同一条直线上（横、纵、对角）的四个数的最大乘积\n\n# 思路\n直接暴力找就行\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar str[] = {\"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\"};\nint a[25][25];\nint main () {\n    for (int i = 0; i < 20; i++) {\n        for (int j = 0; j < 20; j++) {\n            int k = i * 60 + j * 3;\n            a[i][j] = (str[k] - '0') * 10 + str[k + 1] - '0';\n        }\n    }\n    int mx = 0;\n    int dx[4] = {1, 1, 0, -1};\n    int dy[4] = {0, 1, 1, 1};\n    for (int i = 0; i < 20; i++) {\n        for (int j = 0; j < 20; j++) {\n            for (int k = 0; k < 4; k++) {\n                int ok = 1;\n                int x = i, y = j, now = a[x][y];\n                for (int l = 0; l < 3; l++) {\n                    int tx = x + dx[k], ty = y + dy[k];\n                    if (!(0 <= tx && tx < 20 && 0 <= ty && ty < 20)) {\n                        ok = 0;\n                        break;\n                    }\n                    now *= a[tx][ty];\n                    x = tx, y = ty;\n                }\n                if (ok) mx = max(now, mx);\n            }\n        }\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 12:13.31\n","categories":["Project Euler"]},{"title":"Project Euler 10 Summation of primes（线性筛素数）","url":"/2014/10/28/Project Euler 10/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=10\n\n# 题意\n求所有小于2000000的素数和\n\n# 思路\n线性筛素数\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define maxn 2000010\n#define ll long long\nint ans[maxn], valid[maxn], tot = 0;\nll sum = 0;\nvoid getPrime(int n, int &tot, int ans[]) {\n    for (int i = 2; i <= n; i++) {\n        if (!valid[i]) ans[tot++] = i, sum += i;\n        for (int j = 0; j < tot && i * ans[j] <= n; j++) {\n            valid[i * ans[j]] = 1;\n            if (i % ans[j] == 0) break;\n        }\n    }\n}\nint main () {\n    sum = 0;\n    getPrime(2000000, tot, ans);\n    cout<<sum<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 12:03.18\n","tags":["数论"],"categories":["Project Euler"]},{"title":"Project Euler 9 Special Pythagorean triplet（枚举）","url":"/2014/10/27/Project Euler 9/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=9\n\n# 题意\n$a^2+b^2=c^2$\n$a+b+c=1000$\n且$a<b<c$\n求$abc$\n\n# 思路\n直接枚举a,b,c即可\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nvoid work() {\n    for (int i = 1; i <= 1000 / 3; i++) {\n        for (int j = i + 1; j <= (1000 - i) / 2; j++) {\n            int k = 1000 - i - j;\n            if (i * i + j * j == k * k) {\n                cout<<i * j * k <<endl;\n                return ;\n            }\n        }\n    }\n}\nint main () {\n    work();\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 11:46\n","categories":["Project Euler"]},{"title":"Project Euler 8 Largest product in a series（暴力）","url":"/2014/10/27/Project Euler 8/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=8\n\n# 题意\n给定一串数字，求相邻13个数字相乘的最大值\n\n# 思路\n直接枚举子段的开头，如果碰到0可以跳到0后面\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nchar str[] = {\"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\"};\nint main () {\n    ll mx = 0;\n    for (int i = 0; i < 1000 - 13; i++) {\n        int o = -1;\n        ll t = 1;\n        if (i + 13 > 1000) break;\n        for (int j = 0; j < 13; j++) {\n            t = t * (str[i + j] - '0');\n            if (str[i + j] == '0') o = i + j;\n        }\n        mx = max(t, mx);\n        if (o != -1) i = o;\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 10:10\n","categories":["Project Euler"]},{"title":"Project Euler 7 10001st prime（筛素数）","url":"/2014/10/27/Project Euler 7/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=7\n\n# 题意\n求第10001个素数\n\n# 思路\n采用线性筛素数，复杂度为O(N)\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define maxn 1000000\nint ans[maxn], valid[maxn], tot = 0;\nvoid getPrime(int n, int &tot, int ans[]) {\n    for (int i = 2; i <= n; i++) {\n        if (!valid[i]) ans[tot++] = i;\n        for (int j = 0; j < tot && i * ans[j] <= n; j++) {\n            valid[i * ans[j]] = 1;\n            if (i % ans[j] == 0) break;\n        }\n    }\n}\nint main () {\n    getPrime(999999, tot, ans);\n    cout<<ans[10000]<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 09:36\n","tags":["数论"],"categories":["Project Euler"]},{"title":"Project Euler 6 Sum square difference（公式）","url":"/2014/10/27/Project Euler 6/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=6\n\n# 题意\n$f(x) = 1^2 + 2^2 + \\cdots + n^2$\n$g(x) = (1 + 2 + \\cdots + n)^2$\n求$g(x)-f(x)$\n\n# 思路\n$f(x) = \\frac{n(n+1)(2n+1)}{6}$\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define ll long long\nint main () {\n    int n = 100;\n    ll sum = (2 * n + 1) * n * (n + 1) / 6;\n    ll sq = (1 + n) * n / 2;\n    sq *= sq;\n    cout<<sq - sum<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 06:45\n","tags":["公式"],"categories":["Project Euler"]},{"title":"Project Euler 5 Smallest multiple（gcd）","url":"/2014/10/27/Project Euler 5/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=5\n\n# 题意\n求一个最小的整数，使得该整数能够整除[1,20]的所有数\n\n# 思路\nlcm(a, b) = a * b / gcd(a, b)\n要注意答案会超int\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nint main () {\n    ll ans = 1;\n    for (ll i = 1; i <= 20; i++) {\n        ans = ans * i / __gcd(ans, i);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 06:20\n","categories":["Project Euler"]},{"title":"Project Euler 4 Largest palindrome product（枚举）","url":"/2014/10/27/Project Euler 4/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=4\n\n# 题意\n求最大的回文数，该数字由两个三位数相乘得到。\n\n# 思路\n枚举两个三位数即可\n<!--more-->\n\n# 代码\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nbool check(int x) {\n    string s = \"\";\n    while(x) {\n        s += x % 10 + '0';\n        x /= 10;\n    }\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) if (s[i] != s[j]) return false;\n    return true;\n}\nint main () {\n    int mx = 0;\n    for (int i = 999; i >= 100; i--) {\n        for (int j = i; j >= 100; j--) {\n            int t = i * j;\n            if (t <= mx) break;\n            if (check(t)) mx = t;\n        }\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 03:41\n","categories":["Project Euler"]},{"title":"Project Euler 3 Largest prime factor（pollard_rho大数分解）","url":"/2014/10/27/Project Euler 3/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=3\n\n# 题意\n给定一个数（600851475143），求其最大的质因数\n\n# 思路\n这个当然可以直接暴力搞定，不过用pollard_rho大数分解效率要高\n<!--more-->\n\n# 代码\n```\n/*\n    给定一个数（600851475143），求其最大的质因数\n*/\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nconst int S = 20; //随机算法判定次数，S越大，判错概率越小\n\n//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的\n//  a,b,c <2^63\nll mult_mod(ll a, ll b, ll c) {\n    a %= c;\n    b %= c;\n    ll ret = 0;\n    while(b) {\n        if(b & 1) {\n            ret += a;\n            ret %= c;\n        }\n        a <<= 1;\n        if(a >= c)a %= c;\n        b >>= 1;\n    }\n    return ret;\n}\n\n//计算  x^n %c\nll pow_mod(ll x, ll n, ll mod) { //x^n%c\n    if(n == 1)return x % mod;\n    x %= mod;\n    ll tmp = x;\n    ll ret = 1;\n    while(n) {\n        if(n & 1) ret = mult_mod(ret, tmp, mod);\n        tmp = mult_mod(tmp, tmp, mod);\n        n >>= 1;\n    }\n    return ret;\n}\n\n//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数\n//一定是合数返回true,不一定返回false\nbool check(ll a, ll n, ll x, ll t) {\n    ll ret = pow_mod(a, x, n);\n    ll last = ret;\n    for(int i = 1; i <= t; i++) {\n        ret = mult_mod(ret, ret, n);\n        if(ret == 1 && last != 1 && last != n - 1) return true; //合数\n        last = ret;\n    }\n    if(ret != 1) return true;\n    return false;\n}\n\n// Miller_Rabin()算法素数判定\n//是素数返回true.(可能是伪素数，但概率极小)\n//合数返回false;\nbool Miller_Rabbin(ll n) {\n    if(n < 2)return false;\n    if(n == 2)return true;\n    if((n & 1) == 0) return false; //偶数\n    ll x = n - 1;\n    ll t = 0;\n    while((x & 1) == 0) {\n        x >>= 1;\n        t++;\n    }\n    for(int i = 0; i < S; i++) {\n        ll a = rand() % (n - 1) + 1; //rand()需要stdlib.h头文件\n        if(check(a, n, x, t))\n            return false;//合数\n    }\n    return true;\n}\n\nll factor[100];//质因数分解结果（刚返回时是无序的）\nint tot;//质因数的个数。数组小标从0开始\n\nll gcd(ll a, ll b) {\n    if(a == 0) return 1;\n    if(a < 0) return gcd(-a, b);\n    while(b) {\n        ll t = a % b;\n        a = b;\n        b = t;\n    }\n    return a;\n}\n\nll Pollard_rho(ll x, ll c) {\n    ll i = 1, k = 2;\n    ll x0 = rand() % x;\n    ll y = x0;\n    while(1) {\n        i++;\n        x0 = (mult_mod(x0, x0, x) + c) % x;\n        ll d = gcd(y - x0, x);\n        if(d != 1 && d != x) return d;\n        if(y == x0) return x;\n        if(i == k) {\n            y = x0;\n            k += k;\n        }\n    }\n}\n//对n进行素因子分解\nvoid findfac(ll n) {\n    if(Miller_Rabbin(n)) { //素数\n        factor[tot++] = n;\n        return;\n    }\n    ll p = n;\n    while(p >= n) p = Pollard_rho(p, rand() % (n - 1) + 1);\n    findfac(p);\n    findfac(n / p);\n}\nint main () {\n    ll n = 600851475143LL;\n    findfac(n);\n    cout<<factor[tot - 1]<<endl;\n}\n```\n\n# 更新日志\n- Completed on Mon, 27 Oct 2014, 02:36\n","tags":["pollard_rho大数分解"],"categories":["Project Euler"]},{"title":"Project Euler 2 Even Fibonacci numbers（递推）","url":"/2014/10/27/Project Euler 2/","content":"# 题目\t\n源地址：https://projecteuler.net/problem=2\n\n# 题意\n求不超过4000000的菲波那切偶数和\n\n# 思路\n递推\n\n<!--more-->\n# 代码\n```\n/*\n    所有不超过4000000的菲波那切偶数和\n*/\n#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint f[40];\nint main () {\n    f[0] = 1, f[1] = 2;\n    int sum = 2;\n    for (int i = 2; i < 40; i++) {\n        f[i] = f[i - 1] + f[i - 2];\n        if (f[i] > 4000000) break;\n        if (f[i] % 2 == 0) sum += f[i];\n    }\n    cout<<sum<<endl;\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-10-27 AC\n- 开始做Project Euler\n","categories":["Project Euler"]},{"title":"LA 3938 动态最大连续和（线段树）","url":"/2014/10/26/LA 3938 动态最大连续和 线段树/","content":"# 题目\t\n源地址：https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=22&problem=1939&mosmsg=Submission+received+with+ID+1584539\n\n# 题意\n给定一个序列，长度为n。有m个操作，每次操作给定(a,b)。求区间[a,b]之间的一段区间[l,r]，使得a ≤ l ≤ r ≤ b。且区间[l,r]为最大子段和。当有多组答案时，使l最小，l相同时，r最小。\n数据范围：1 ≤ n,m ≤ 500000，序列元素的绝对值 ≤ 1e9\n\n# 思路\n采用线段树来维护动态最大连续和。每个区间维护最大子段和sub[]，最大前缀和pre[]，最大后缀和[]。在建立线段树的时候，进行维护。当左右两个区间l，r进行合并时，维护的方式是：\n- prefix  最大前缀和为max(pre[l], sum[l] + pre[r])\n- suffix  最大后缀和为max(suf[r], sum[r] + suf[l])\n- sub 最大子段和为max(max(sub[l], suf[l] + pre[r]), sub[r])\n在维护的过程中，还要记录相应的坐标信息\n查询相似\n\n<!--more-->\n# 代码\n```\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n#define ll long long\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nconst int maxn = 500100;\nll sub[maxn << 2], pre[maxn << 2], suf[maxn << 2]; //记录每段的最大子段和，最大前缀和，最大后缀和\nll sum[maxn << 2]; //记录每段的和\nll st[maxn << 2], ed[maxn << 2];  //记录最大子段和的起点、终点\nll pst[maxn << 2], ped[maxn << 2]; //记录最大前缀和的起点、终点\nll sst[maxn << 2], sed[maxn << 2]; //记录最大后缀和的起点、终点\nint n, m;\nvoid pushup(int rt) {\n    int l = rt << 1, r = rt << 1 | 1;\n    sum[rt] = sum[l] + sum[r];\n    //prefix\n    ll maxt = pre[l];\n    ll ss = pst[l], ee = ped[l];\n    if (pre[l] < sum[l] + pre[r])\n        maxt = sum[l] + pre[r], ss = pst[l], ee = ped[r];\n    pre[rt] = maxt, pst[rt] = ss, ped[rt] = ee;\n    //suffix\n    maxt = suf[r], ss = sst[r], ee = sed[r];\n    if (suf[r] <= sum[r] + suf[l])\n        maxt = sum[r] + suf[l], ss = sst[l], ee = sed[r];\n    suf[rt] = maxt, sst[rt] = ss, sed[rt] = ee;\n    //sub\n    maxt = sub[l], ss = st[l], ee = ed[l];\n    if (maxt < suf[l] + pre[r]) maxt = suf[l] + pre[r], ss = sst[l], ee = ped[r];\n    if (maxt < sub[r]) maxt = sub[r], ss = st[r], ee = ed[r];\n    sub[rt] = maxt, st[rt] = ss, ed[rt] = ee;\n}\nvoid build(int l, int r, int rt) {\n    if (l == r) {\n        scanf(\"%lld\", sum + rt);\n        sub[rt] = pre[rt] = suf[rt] = sum[rt];\n        st[rt] = ed[rt] = pst[rt] = ped[rt] = sst[rt] = sed[rt] = l;\n        return ;\n    }\n    int m = (l + r) >> 1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\nstruct node {\n    ll sum, l, m, r; //sum表示该段和，l，m，r分别表示最大前缀和、最大子段和、最大后缀和\n    int ls, le, ms, me, rs, re; //分别表示l，m，r的起点、终点\n};\nnode query(int L, int R, int l, int r, int rt) {\n    if (L <= l && r <= R) {\n        node tp;\n        tp.l = pre[rt], tp.m = sub[rt], tp.r = suf[rt];\n        tp.ls = pst[rt], tp.le = ped[rt];\n        tp.ms = st[rt], tp.me = ed[rt];\n        tp.rs = sst[rt], tp.re = sed[rt];\n        tp.sum = sum[rt];\n        return tp;\n    }\n    node tp, tp1, tp2;\n    int m = (l + r) >> 1, sl = 0, sr = 0;\n    if (L <= m) {\n        tp1 = query(L, R, lson);\n        sl = 1;\n    }\n    if (R > m) {\n        tp2 = query(L, R, rson);\n        sr = 1;\n    }\n    if (sl && !sr) return tp1;\n    if (!sl && sr) return tp2;\n    //prefix\n    tp.l = tp1.l, tp.ls = tp1.ls, tp.le = tp1.le;\n    if (tp.l < tp1.sum + tp2.l)\n        tp.l = tp1.sum + tp2.l, tp.le = tp2.le;\n    //suffix\n    tp.r = tp2.r, tp.rs = tp2.rs, tp.re = tp2.re;\n    if (tp.r <= tp2.sum + tp1.r)\n        tp.r = tp2.sum + tp1.r, tp.rs = tp1.rs;\n    //sub\n    tp.m = tp1.m, tp.ms = tp1.ms, tp.me = tp1.me;\n    if (tp.m < tp1.r + tp2.l)\n        tp.m = tp1.r + tp2.l, tp.ms = tp1.rs, tp.me = tp2.le;\n    if (tp.m < tp2.m)\n        tp.m = tp2.m, tp.ms = tp2.ms, tp.me = tp2.me;\n    tp.sum = tp1.sum + tp2.sum;\n    return tp;\n}\nint main () {\n    int cas = 1;\n    while(~scanf(\"%d%d\", &n, &m)) {\n        build(1, n, 1);\n        printf(\"Case %d:\\n\", cas++);\n        int a, b;\n        while(m--) {\n            scanf(\"%d%d\", &a, &b);\n            node ans = query(a, b, 1, n, 1);\n            printf(\"%d %d\\n\", ans.ms, ans.me);\n        }\n    }\n    return 0;\n}\n```\n\n# 更新日志\n- 2014-10-27 已AC \n- 3938\t\"Ray, Pass me the dishes!\"\tAccepted\tC++11\t0.219\t2014-10-26 16:33:27\n","tags":["线段树"],"categories":["算法竞赛训练指南"]},{"title":"Codeforces Round 275","url":"/2014/10/25/cf275/","content":"# 题目\t\n源地址：http://codeforces.com/contest/482\n\n# 理解\n\n<!-- more -->\n\n# 新技能get\n\n# 代码\n```\n\n```\n\n# 更新日志\n- 挖个坑。\n","categories":["Codeforces"]}]