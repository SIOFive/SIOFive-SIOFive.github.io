title: HDU 4858 项目管理（分块）
date: 2015-7-19 19:50
tags: [分块]
categories: [ACM]
toc: true
---
# 题目	
源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4858

# 题意
有一个项目有n个点，项目是连通的。有m条边，可能有重边，但没有自环。
接下来有Q次询问，每次询问分两种操作，操作符为0，表示给某一个点加上一个值。操作符为1，询问某一个点相邻项目值之和（如果多条边就算多次）
数据范围：1 ≤ n ≤ 100000，1 ≤ m ≤ n + 10

# 思路
我只想到了暴力的方法，刚好可以水过。。
正确的姿势是采用分块的思想，由于这个图比较稀疏，总度数为2*m，又由于整个图是连通的，所以每个点的度数至少为1。这是还剩下2*m-n个度数可以分配，故度数大于sqrt(n)的点的个数和sqrt(n)比较接近。
因此我们将点分为两类，度数大于sqrt(n)的点为重点，度数小于sqrt(n)的点为轻点。每个重点维护与其相邻的所有轻点值之和。
1. 每次修改轻点时，更新自己的值，并且更新与其相邻的所有重点相邻轻点和。复杂度为O(sqrt(n))
2. 每次修改重点时，只更新自己的值。复杂度为O(1)
3. 每次询问轻点时，只需要把与轻点的邻居相加。复杂度为O(sqrt(n))
4. 每次询问重点时，只需要把与其相连的重点的值相加，再加上维护的其相邻轻点的和即可。复杂度为O(sqrt(n))

<!--more-->

# 代码
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#define pb push_back
using namespace std;
const int N = 100000 + 100;
int n, m, T;
vector<int> g[N], gb[N];
int d[N], sum[N], w[N];
int main () {
    scanf("%d", &T);
    while(T--) {
        scanf("%d%d", &n, &m);
        for (int i = 0; i <= n; i++) {
            g[i].clear(), gb[i].clear();
            d[i] = sum[i] = w[i] = 0;
        }
        int u, v;
        for (int i = 0; i < m; i++) {
            scanf("%d%d", &u, &v);
            g[u].pb(v); g[v].pb(u);
            d[u]++, d[v]++;
        }
        int sq = sqrt(n) + 1.0;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < g[i].size(); j++) {
                int r = g[i][j];
                if (d[r] > sq) gb[i].pb(r);
            }
        }
        int Q, op;
        scanf("%d", &Q);
        while(Q--) {
            scanf("%d", &op);
            if (!op) {
                scanf("%d%d", &u, &v);
                w[u] += v;
                if (d[u] <= sq) {
                    for (int j = 0; j < gb[u].size(); j++) sum[gb[u][j]] += v;
                }
            } else {
                scanf("%d", &u);
                int ans = 0;
                if (d[u] <= sq) {
                    for (int j = 0; j < g[u].size(); j++) ans += w[g[u][j]];
                } else {
                    ans += sum[u];
                    for (int j = 0; j < gb[u].size(); j++) ans += w[gb[u][j]];
                }
                printf("%d\n", ans);
            }
        }
    }
    return 0;
}
```

# 更新日志
- 13943476  2015-07-02 16:54:16 Accepted    4858    514MS   12008K  1646 B  G++ SIO__Five
