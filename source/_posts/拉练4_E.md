title: CF 8C Looking for Order (bitmasks, dp)
date: 2014-11-12 18:30
tags: [bitmasks, dp]
categories: [ACM]
toc: true
---
# 题目
源地址：http://codeforces.com/problemset/problem/8/C

# 题意
给定起点，以及$n$个物品的位置。现在规定每次从起点出发，可以选择一个物品，并且将其带回起点；或者选择两个物品，先后走到两个物品处，将其带回起点。问将所有物品带回起点的最少时间，每段路程的时间为该路程值的平方。并且输出路径。
数据范围：$1{\leq}n{\leq}24$

# 思路
用dp[i]表示i状态时所花的最短时间。
那么从i状态出发，可以选择一个没有选过的物品v，即$j = i | 1 << v$, 转移方程为：$dp[j] = min(dp[j], dp[i] + dis[v] * 2)$
或者选择两个没有选过的物品v，l，即$j = i | 1 << v | 1 << l$, 转移方程为：$dp[j] = min(dp[j], dp[i] + dis[v] + a[v][l] + dis[l])$
但这样做还时间复杂度很大，会TLE。这里有个神奇的剪枝，因为所有的物品先取后取不影响结果，所以我们可以人为的规定一个取物品的顺序（从小到大）。（详见代码）

<!-- more -->
```
/*
ID: wuqi9395@126.com
PROG:
LANG: C++
*/
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<cmath>
#include<cstdio>
#include<vector>
#include<string>
#include<fstream>
#include<cstring>
#include<ctype.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define INF (1 << 30)
#define LINF (1LL << 60)
#define PI acos(-1.0)
#define mem(a, b) memset(a, b, sizeof(a))
#define rep(i, a, n) for (int i = a; i < n; i++)
#define per(i, a, n) for (int i = n - 1; i >= a; i--)
#define eps 1e-6
#define debug puts("===============")
#define pb push_back
#define mkp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)
#define sqr(x) (x) * (x)
typedef long long ll;
typedef unsigned long long ULL;
const int maxn = 1e5 + 10;
int sx, sy;
int x[25], y[25], n;
int dp[1 << 24], pre[1 << 24];
int a[24][24], d[25];
int main () {
    scanf("%d%d%d", &sx, &sy, &n);
    for (int i = 0; i < n; i++) scanf("%d%d", x + i, y + i);
    for (int i = 0; i < n; i++) {
        d[i] = sqr(x[i] - sx) + sqr(y[i] - sy);
        for (int j = 0; j < n; j++) a[i][j] = sqr(x[i] - x[j]) + sqr(y[i] - y[j]);
    }
    int tot = 1 << n;
    for (int i = 0; i < tot; i++) if (i == 0 || dp[i]) {
        for (int j = 0; j < n; j++) if (!((i >> j) & 1)){
            int v = i | (1 << j);
            int s = d[j] * 2;
            if (!dp[v] || dp[v] > dp[i] + s) dp[v] = dp[i] + s, pre[v] = i;
            for (int l = j + 1; l < n; l++) if (!((i >> l) & 1)) {
                s = d[j] + a[j][l] + d[l];
                v = i | (1 << l) | (1 << j);
                if (!dp[v] || dp[v] > dp[i] + s) dp[v] = dp[i] + s, pre[v] = i;
            }
            break; //每次只选择最小的进行状态的更新，然后就跳出
        }
    }
    printf("%d\n", dp[tot - 1]);
    cout<<0;
    for (int t = tot - 1; t; t = pre[t]) {
        int s = t ^ pre[t];
        for (int i = 0; i < n; i++) if ((s >> i) & 1) cout<<" "<<i + 1;
        cout<<" "<<0;
    }
    cout<<endl;
    return 0;
}
```

# 更新日志
- 2014-11-12 AC
