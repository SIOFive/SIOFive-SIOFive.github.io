title: POJ 3225 Help with Intervals（线段树）
date: 2014-10-31 21:08
tags: [数据结构, 线段树]
categories: [ACM]
toc: true
---
# 题目	
源地址：http://poj.org/problem?id=3225

# 题意
规定集合的交并补差等操作：
![](http://siofive.qiniudn.com/poj 3225_1.png)
现在给定一个区间S,范围为[0, 65535],一开始全为0。
可以对该集合进行下面五种操作，问最后操作之后有哪些区间为1
![](http://siofive.qiniudn.com/poj 3225_2.png)
其中T可以有4种形式：$(a,b) (a,b] [a, b) [a, b]$
数据范围：$(a, b ∈ Z, 0 ≤ a ≤ b ≤ 65,535)$

# 思路
U：把区间$[l,r]$置为1
I：把$[-∞,l),(r,∞]$置成0
D：把区间$[l,r]$置为0
C：把$[-∞,l),(r,∞]$置成0, 且$[l,r]$区间0/1互换
S：$[l,r]$区间0/1互换
成段替换比较好实现，互换的操作可以用一个XOR[]数组来进行标记。需要注意的是，如果该区间又有替换又有互换的话，只需要做等价的替换操作即可。
将区间扩大两倍，就能够处理开、闭区间。
<!--more-->

# 代码
```
/*
    U：把区间[l,r]置为1
    I：把[-∞,l)(r,∞]置成0
    D：把区间[l,r]置为0
    C：把[-∞,l)(r,∞]置成0, 且[l,r]区间0/1互换
    S；[l,r]区间0/1互换
*/
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
const int maxn = 65535 * 2 + 2;
int col[maxn << 2], XOR[maxn << 2];
bool has[maxn];
void FXOR(int rt) {
    if (col[rt] != -1) col[rt] ^= 1;
    else XOR[rt] ^= 1;
}
void pushdown(int rt) {
    if (col[rt] != -1) {
        col[rt << 1] = col[rt << 1 | 1] = col[rt];
        XOR[rt << 1] = XOR[rt << 1 | 1] = 0;
        col[rt] = -1;
    }
    if (XOR[rt]) {
        FXOR(rt << 1);
        FXOR(rt << 1 | 1);
        XOR[rt] = 0;
    }
}
void update(char op, int L, int R, int l, int r, int rt) {
    if (L <= l && r <= R) {
        if (op == 'U') col[rt] = 1, XOR[rt] = 0;
        else if (op == 'D') col[rt] = 0, XOR[rt] = 0;
        else if (op == 'C' || op == 'S') FXOR(rt);
        return ;
    }
    pushdown(rt);
    int m = (l + r) >> 1;
    if (L <= m) update(op, L, R, lson);
    else if (op == 'I' || op == 'C') col[rt << 1] = XOR[rt << 1] = 0;
    if (R > m) update(op, L, R, rson);
    else if (op == 'I' || op == 'C') col[rt << 1 | 1] = XOR[rt << 1 | 1] = 0;
}
void query(int l, int r, int rt) {
    if (col[rt] == 1) {
        for (int i = l; i <= r; i++) has[i] = true;
        return ;
    } else if (col[rt] == 0) return ;
    if (l == r) return ;
    pushdown(rt);
    int m = (l + r) >> 1;
    query(lson);
    query(rson);
}
int main () {
    col[1] = XOR[1] = 0;
    char op, lq, rq;
    int l, r;
    while(~scanf("%c %c%d,%d%c\n", &op, &lq, &l, &r, &rq)) {
        l <<= 1, r <<= 1;
        if (lq == '(') l++;
        if (rq == ')') r--;
        if (l > r) {
            if (op == 'I' || op == 'C') col[1] = XOR[1] = 0;
        } else update(op, l, r, 0, maxn, 1);
    }
    query(0, maxn, 1);
    bool flag = 0;
    int st = -1, ed;
    for (int i = 0; i <= maxn; i++) {
        if (has[i]) {
            if (st == -1) st = i;
            ed = i;
        } else {
            if (st != -1) {
                if (flag) putchar(' ');
                flag = true;
                printf("%c%d,%d%c", st & 1 ? '(' : '[', st >> 1, (ed + 1) >> 1, ed & 1 ? ')' : ']');
                st = -1;
            }
        }
    }
    if (!flag) puts("empty set");
    puts("");
    return 0;
}
```

# 更新日志
- 13585854	SIO__Five	3225	Accepted	2848K	1188MS	G++	2546B	2014-10-31 21:03:40
