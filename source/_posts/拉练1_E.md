title: CF 3D Least Cost Bracket Sequence (贪心)
date: 2014-11-02 14:57
tags: [贪心]
categories: [ACM]
toc: true
---
# 题目	
源地址：http://codeforces.com/problemset/problem/3/D

# 题意
有一串字符串，每个字符为'(', ')' 或'?'。现在需要将其中的'?'替换为'('或')'，使得最后的括号匹配。每个'?'替换成相应的括号都有一个花费。如果最后不能匹配，输出-1。否则输出最少的花费。

#思路
首先要知道，对于每个')'而言，只要它之前的所有')'都被匹配了，且它本身也有'('与它匹配，那么该表达式一定成立。
所以可以从头到尾的处理，一开始有个值now = 0，花费cost = 0，以及一个优先队列
碰到'(', now++。
碰到')', now--。
碰到'?'，将问号变成')'，同时now++和cost += b (假设 '?'->'(' 费用为a，'?'->')' 费用为b)，然后将pair(b-a,i)放入优先队列。（i为位置）
发现此时now < 0，即左括号比右括号少时，如果优先队列为空，说明前面已经没有有效的'?'了。即匹配失败。否则从优先队列里挑选一个能最大降低cost的'?'，转化为'('。
最后看now是否为0即可。

<!-- more -->
```
/*
ID: wuqi9395@126.com
PROG:
LANG: C++
*/
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<cmath>
#include<cstdio>
#include<vector>
#include<string>
#include<fstream>
#include<cstring>
#include<ctype.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define INF (1 << 30)
#define LINF (1LL << 60)
#define PI acos(-1.0)
#define mem(a, b) memset(a, b, sizeof(a))
#define rep(i, a, n) for (int i = a; i < n; i++)
#define per(i, a, n) for (int i = n - 1; i >= a; i--)
#define eps 1e-6
#define debug puts("===============")
#define pb push_back
#define mkp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
#define POSIN(x,y) (0 <= (x) && (x) < n && 0 <= (y) && (y) < m)
typedef long long ll;
typedef unsigned long long ULL;
typedef pair<int, int> pii;
const int N = 50000 + 10;
priority_queue< pii > q;
int main () {
    char str[N];
    scanf("%s", str);
    ll c = 0, now = 0;
    bool flag = true;
    for (int i = 0; str[i]; i++) {
        if (str[i] == '(') now++;
        else now--;
        if (str[i] == '?') {
            int a, b;
            scanf("%d%d", &a, &b);
            str[i] = ')';
            q.push(mkp(b - a, i));
            c += b;
        }
        if (flag && now < 0) {
            if (q.empty()) flag = false;
            else {
                pii x = q.top(); q.pop();
                str[x.second] = '(';
                c -= x.first;
                now += 2;
            }
        }
    }
    if (now != 0 || !flag) puts("-1");
    else cout<<c<<endl<<str<<endl;
    return 0;
}
```

# 更新日志
- 2014-11-2 AC
