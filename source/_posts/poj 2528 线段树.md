title: POJ 2528 Mayor's posters（线段树）
date: 2014-10-30 21:03
tags: [数据结构, 线段树]
categories: [ACM]
toc: true
---
# 题目	
源地址：http://poj.org/problem?id=2528

# 题意
有一块长度为$1e7$的板子，现在有$n$张海报，依次贴上板子，后面的海报会覆盖前面的海报。每张海报占据[l, r]的区间。
求最后能够在板子上看到多少张海报。
数据范围：$1{\leq}n{\leq}1e4$, $1{\leq}l,r{\leq}1e7$

如图所示
![](http://siofive.qiniudn.com/2528_1.jpg)
5
1 4
2 6
8 10
3 4
7 10
答案为4

# 思路
由于区间范围很大，但海报数相对较少，所以可以将海报的坐标离散化。
离散化之后再用线段树维护。
线段树成段更新，update：成段修改	query：区间求种类数
<!--more-->

# 代码
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
const int maxn = 11111;
int col[maxn << 4];
int x[maxn << 2];
int l[maxn], r[maxn], ans;
bool has[maxn];
void pushdown(int rt) {
    if (col[rt] != -1) {
        col[rt << 1] = col[rt << 1 | 1] = col[rt];
        col[rt] = -1;
    }
}
void update(int L, int R, int c, int l, int r, int rt) {
    if (L <= l && r <= R) {
        col[rt] = c;
        return ;
    }
    pushdown(rt);
    int m = (l + r) >> 1;
    if (L <= m) update(L, R, c, lson);
    if (R > m) update(L, R, c, rson);
}
void query(int l, int r, int rt) {
    if (col[rt] != -1) {
        if (!has[col[rt]]) ans++;
        has[col[rt]] = true;
        return ;
    }
    if (l == r) return ;
    int m = (l + r) >> 1;
    query(lson);
    query(rson);
}
int main () {
    int T, n;
    scanf("%d", &T);
    while(T--) {
        scanf("%d", &n);
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            scanf("%d%d", l + i, r + i);
            x[cnt++] = l[i], x[cnt++] = r[i];
        }
        sort(x, x + cnt);
        cnt = unique(x, x + cnt) - x;
        memset(col, -1, sizeof(col));
        for (int i = 0; i < n; i++) {
            int a = lower_bound(x, x + cnt, l[i]) - x;
            int b = lower_bound(x, x + cnt, r[i]) - x;
            update(a, b, i, 0, cnt, 1);
        }
        ans = 0;
        memset(has, 0, sizeof(has));
        query(0, cnt, 1);
        printf("%d\n", ans);
    }
    return 0;
}
```

# 更新日志
- 13582214	SIO__Five	2528	Accepted	1536K	63MS	G++	1718B	2014-10-30 20:42:27
