title: HDU 4857 逃生（拓扑排序 逆向思考）
date: 2015-7-19 19:10
tags: [拓扑排序, 逆向思考]
categories: [ACM]
toc: true
---
# 题目	
源地址：http://acm.hdu.edu.cn/showproblem.php?pid=4857

# 题意
现在有n个人，从1标号到n。要把他们排成一排。同时有m个约束条件，每个都形如：a必须在b之前。此外这些人中1号最富，2号第二富，以此类推。在排顺序时，尽量让越有钱的人越靠前。即先让1尽量靠前，再让2尽量靠前，以此类推。求出这个序列。

# 思路
首先肯定想到拓扑排序。但是按照正常的拓扑排序之后得到的是字典序最小的序列。无法保证让越富有的人越靠前的情况。
举个例子：有4个人，2个限制：1在4之前，4在2之前。
按照正常的拓扑排序得到：1 3 4 2
但是符合要求的序列则为：1 4 2 3
所以正确的想法是：建边时逆向建边，然后每次选取最大的数排在前面，这样子便可以保证小数（富有的人）尽可能的排在后面。然后逆序输出序列即可。

<!--more-->

# 代码
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<set>
#include<queue>
using namespace std;
const int N = 30000 + 100;
struct node {
    int x;
    bool operator < (const node &T) const {
        return x < T.x;
    }
};
vector<int> g[N];
int n, m, du[N], out[N];
int main () {
    int t;
    cin>>t;
    while(t--) {
        priority_queue<node> q;
        scanf("%d%d", &n, &m);
        for (int i = 0; i <= n; i++) g[i].clear(), du[i] = 0;
        int u, v;
        while(m--) {
            scanf("%d%d", &u, &v);
            g[v].push_back(u);
            du[u]++;
        }
        for (int i = 1; i <= n; i++) if (!du[i]) q.push({i});
        int ct = 0;
        while(!q.empty()) {
            u = q.top().x;
            q.pop();
            out[ct++] = u;
            for (int i = 0; i < g[u].size(); i++) {
                v = g[u][i];
                du[v]--;
                if (!du[v]) q.push({v});
            }
        }
        for (int i = n - 1; i >= 0; i--) printf("%d%c", out[i], i == 0 ? '\n' : ' ');
    }
    return 0;
}
```

# 更新日志
- 14037388  2015-07-17 11:07:34 Accepted    4857    436MS   4616K   937 B   G++ SIO__Five
