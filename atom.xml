<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SIO__Five</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-17T11:47:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SIO__Five</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15213：CSAPP 实验一：DataLab</title>
    <link href="http://yoursite.com/2017/10/16/cmu15213-datalab/"/>
    <id>http://yoursite.com/2017/10/16/cmu15213-datalab/</id>
    <published>2017-10-16T14:33:00.000Z</published>
    <updated>2017-10-17T11:47:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>《深入理解计算机系统》的第一个实验，内容包括位操作，用二进制表示整数，浮点数，以及相应的操作。实验限定了可选用的操作符，并且有最大次数限制，总体来讲还是非常有趣的。</p><h2 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h2><p>只使用 ~ 和 | 实现 &amp;</p><p>De Morgan定律</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * bitAnd - x&amp;y using only ~ and | </div><div class="line"> *   Example: bitAnd(6, 5) = 4</div><div class="line"> *   Legal ops: ~ |</div><div class="line"> *   Max ops: 8</div><div class="line"> *   Rating: 1</div><div class="line"> */</div><div class="line">int bitAnd(int x, int y) &#123;</div><div class="line">  return ~(~x | ~y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h2><p>从一个整数（4字节）中提取第0，1，2，3个字节。每个字节8bits，所以通过右移8*n位，然后取最后8位bits</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * getByte - Extract byte n from word x</div><div class="line"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</div><div class="line"> *   Examples: getByte(0x12345678,1) = 0x56</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 6</div><div class="line"> *   Rating: 2</div><div class="line"> */</div><div class="line">int getByte(int x, int n) &#123;</div><div class="line">  return x&gt;&gt;(n&lt;&lt;3) &amp; 0xFF;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h2><p>将一个数逻辑右移，当x为负数时，代码实际上进行的是算术右移，所以要将右移的1改为0</p><p>最高位右移之后的位置为：32-n，所以将-1[1..1]左移动31-n位，得到[1..10..0]。取反之后再&amp;算术右移的数即可。</p><p>但由于不能使用-，使用-n=~n+1. 32-n= 32+~n+1。并且使得每次移位的范围在[0,31]之间，分成两次移位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * logicalShift - shift x to the right by n, using a logical shift</div><div class="line"> *   Can assume that 0 &lt;= n &lt;= 31</div><div class="line"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 20</div><div class="line"> *   Rating: 3 </div><div class="line"> */</div><div class="line">int logicalShift(int x, int n) &#123;</div><div class="line">  int tmp = (~0)&lt;&lt;(32 + (~n));</div><div class="line">  tmp = tmp &lt;&lt; 1;</div><div class="line">  return x&gt;&gt;n &amp; (~tmp);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h2><p>计算二进制中bit为1的个数，由于不能使用循环等操作，这道题难度很大。可以采用一种分治的思想解决。</p><p><img src="http://siofive.qiniudn.com/datalab-bitCount.jpg" alt=""></p><p>为了能够将对应位上的数字相加，需要产生5个mask，分别是0x55555555, 0x33333333, 0x0f0f0f0f, 0x00ff00ff, 0x0000ffff。 分别代表了[1,2,4,8,16]个0和1间隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * bitCount - returns count of number of 1&apos;s in word</div><div class="line"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 40</div><div class="line"> *   Rating: 4</div><div class="line"> */</div><div class="line">int bitCount(int x) &#123;</div><div class="line">  int _mask1 = 0x55 | (0x55 &lt;&lt; 8);   //  0x5555</div><div class="line">  int _mask2 = 0x33 | (0x33 &lt;&lt; 8);   //  0x3333</div><div class="line">  int _mask3 = 0x0f | (0x0f &lt;&lt; 8);   //  0x0f0f</div><div class="line"></div><div class="line">  int mask1 = _mask1 | (_mask1 &lt;&lt; 16);  //  0x55555555 = [0101...0101]</div><div class="line">  int mask2 = _mask2 | (_mask2 &lt;&lt; 16);  //  0x33333333 = [0011...0011]</div><div class="line">  int mask3 = _mask3 | (_mask3 &lt;&lt; 16);  //  0x0f0f0f0f = [00001111...00001111]</div><div class="line">  int mask4 = 0xff | (0xff &lt;&lt; 16);      //  0x00ff00ff = [00000000111111110000000011111111]</div><div class="line">  int mask5 = 0xff | (0xff &lt;&lt; 8);       //  0x0000ffff = [00000000000000001111111111111111]</div><div class="line">  </div><div class="line">  x = (x &amp; mask1) + ((x &gt;&gt; 1) &amp; mask1);</div><div class="line">  x = (x &amp; mask2) + ((x &gt;&gt; 2) &amp; mask2);</div><div class="line">  x = (x &amp; mask3) + ((x &gt;&gt; 4) &amp; mask3);</div><div class="line">  x = (x &amp; mask4) + ((x &gt;&gt; 8) &amp; mask4);</div><div class="line">  x = (x &amp; mask5) + ((x &gt;&gt; 16) &amp; mask5);</div><div class="line">  return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h2><p>计算!x，但不能使用！</p><p>只用当x为0时，!x=1, 观察得到只有0和-0的最高位都不为1，其它的都至少有一个1（tmin有两个，-tmin=tmin）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * bang - Compute !x without using !</div><div class="line"> *   Examples: bang(3) = 0, bang(0) = 1</div><div class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 12</div><div class="line"> *   Rating: 4 </div><div class="line"> */</div><div class="line">int bang(int x) &#123;</div><div class="line">  return ((~(x|(~x+1)))&gt;&gt;31) &amp; 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>计算tmin，直接1&lt;&lt;31即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * tmin - return minimum two&apos;s complement integer </div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 4</div><div class="line"> *   Rating: 1</div><div class="line"> */</div><div class="line">int tmin(void) &#123;</div><div class="line">  return 1&lt;&lt;31;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h2><p>这题关键点是理解题意。如果x能够被表示成n-bit的补码，则返回1. 其实问的是，用一个长度为n-bit的二进制表示补码，对应范围为[n-tmin, n-tmax]，问x是否在该范围内。</p><p>观察n-bit能够表示的范围，如果将这个数右移n-1位，如果x为正，此时x全为0，如果x为负，那么x全为1（为-1）。再将x+1之后再右移1位，此时x应该全为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * fitsBits - return 1 if x can be represented as an </div><div class="line"> *  n-bit, two&apos;s complement integer.</div><div class="line"> *   1 &lt;= n &lt;= 32</div><div class="line"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 15</div><div class="line"> *   Rating: 2</div><div class="line"> */</div><div class="line">int fitsBits(int x, int n) &#123;</div><div class="line">  x = (x&gt;&gt;(n + ~0)) + 1;</div><div class="line">  return !(x&gt;&gt;1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h2><p>计算x/(2^n), 并且向零取整</p><ul><li>当x为整数的时候，直接右移n为即可。</li><li>当x为负数的时候，由于要向上取整，所以需要加上偏移量。ans = (x+(1&lt;<k)-1)>&gt;k</k)-1)></li></ul><p>所以这道题的关键是先判断是否为负数，若是，加上对应的偏移量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</div><div class="line"> *  Round toward zero</div><div class="line"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 15</div><div class="line"> *   Rating: 2</div><div class="line"> */</div><div class="line">int divpwr2(int x, int n) &#123;</div><div class="line">    int s = (x &gt;&gt; 31) &amp; 1;</div><div class="line">    return (x + (s&lt;&lt;n) + ~s + 1) &gt;&gt; n;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>计算-x。-x=~x+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * negate - return -x </div><div class="line"> *   Example: negate(1) = -1.</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 5</div><div class="line"> *   Rating: 2</div><div class="line"> */</div><div class="line">int negate(int x) &#123;</div><div class="line">  return ~x + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h2><p>如果x&gt;0, 返回1。否则返回0</p><p>这道题咋一看很简单，只需要判断最高位。但是0并不是一个正数，所以需要特殊处理。</p><ul><li>x为0，!x=1, ~x的最高位为1，相减得0</li><li>x为整数，!x=0, ~x的最高位为1，相减得1</li><li>x为负数，!x=0, ~x的最高位为0，相减得0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </div><div class="line"> *   Example: isPositive(-1) = 0.</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 8</div><div class="line"> *   Rating: 3</div><div class="line"> */</div><div class="line">int isPositive(int x) &#123;</div><div class="line">  int z = !x;</div><div class="line">  return (((~x)&gt;&gt;31) &amp; 1) + (~z + 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>判断 x&lt;=y<br>如果直接用y-x，会溢出。所以这题需要先判断x和y的两者符号是否相同。不同的情况很好处理，如果相同，两者相减并不会发生溢出，再判断即可。</p><p>如果两者相同，x-y&lt;=0, x-y-1&lt;=-1, 即x+~y+1-1&lt;=-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </div><div class="line"> *   Example: isLessOrEqual(4,5) = 1.</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 24</div><div class="line"> *   Rating: 3</div><div class="line"> */</div><div class="line">int isLessOrEqual(int x, int y) &#123;</div><div class="line">  int sx = (x&gt;&gt;31) &amp; 1;</div><div class="line">  int sy = (y&gt;&gt;31) &amp; 1;</div><div class="line">  int sign_diff = sx &amp; !sy;</div><div class="line">  int sign_same = !(sx^sy) &amp; (((x+~y)&gt;&gt;31) &amp; 1);</div><div class="line">  return sign_diff | sign_same;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h2><p>ilog2(16)=4</p><p>本质上就是求x的最高位1的位置，可以使用上面bitCount中分治法的思想。ilog2(x)的最大值为31，可以表示为 $ilog2(x) = 16<em>a+8</em>b+4<em>c+2</em>d+1*e$。其中a,b,c,d,e为0或1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</div><div class="line"> *   Example: ilog2(16) = 4</div><div class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</div><div class="line"> *   Max ops: 90</div><div class="line"> *   Rating: 4</div><div class="line"> */</div><div class="line">int ilog2(int x) &#123;</div><div class="line">  // max(x) = 31</div><div class="line">  // x can be replace by : x = 16*a+8*b+4*c+2*d+1*e</div><div class="line">  int ans = 0;</div><div class="line">  ans += (!!(x&gt;&gt;16)) &lt;&lt; 4;</div><div class="line">  ans += (!!(x&gt;&gt;(8+ans))) &lt;&lt; 3;</div><div class="line">  ans += (!!(x&gt;&gt;(4+ans))) &lt;&lt; 2;</div><div class="line">  ans += (!!(x&gt;&gt;(2+ans))) &lt;&lt; 1;</div><div class="line">  ans += (!!(x&gt;&gt;(1+ans))) &lt;&lt; 0;</div><div class="line">  return ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h2><p>用unsigned x表示float，并返回-x</p><p>先判断uf是否为NaN，如果是，返回NaN，如果不是的话，返回-uf即可。当浮点数中阶数全为1，而尾数不为0时，表示该数为NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * float_neg - Return bit-level equivalent of expression -f for</div><div class="line"> *   floating point argument f.</div><div class="line"> *   Both the argument and result are passed as unsigned int&apos;s, but</div><div class="line"> *   they are to be interpreted as the bit-level representations of</div><div class="line"> *   single-precision floating point values.</div><div class="line"> *   When argument is NaN, return argument.</div><div class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</div><div class="line"> *   Max ops: 10</div><div class="line"> *   Rating: 2</div><div class="line"> */</div><div class="line">unsigned float_neg(unsigned uf) &#123;</div><div class="line">  unsigned t = uf &amp; 0x7fffffff;</div><div class="line">  if (t &gt; 0x7f800000) return uf;</div><div class="line">  return uf ^ 0x80000000;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h2><p>将一个int数转化为float</p><p>x=(s&lt;&lt;31) | (exponent&lt;&lt;23) | fraction</p><p>先得到符号位，然后如果x=0，或者x=-tmin，直接返回相应的float。如果x为负数，转化为整数考虑。再分别计算该数的exponent和fraction，在计算fraction的时候需要注意向偶数进位，并且进位之后exponent是否需要改变。具体的细节见代码注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * float_i2f - Return bit-level equivalent of expression (float) x</div><div class="line"> *   Result is returned as unsigned int, but</div><div class="line"> *   it is to be interpreted as the bit-level representation of a</div><div class="line"> *   single-precision floating point values.</div><div class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</div><div class="line"> *   Max ops: 30</div><div class="line"> *   Rating: 4</div><div class="line"> */</div><div class="line">unsigned float_i2f(int x) &#123;</div><div class="line">  // return (s&lt;&lt;31)|(exponent&lt;&lt;23)|fraction</div><div class="line">  int s = (x&gt;&gt;31) &amp; 1;  //sign</div><div class="line">  int exponent;</div><div class="line">  int fraction = 0;</div><div class="line">  int fraction_mask;</div><div class="line">  int delta;</div><div class="line">  int i = 30;</div><div class="line">  if (x == 0) return x;   //x=0</div><div class="line">  else if (x == 0x80000000) &#123; //x=-tmin, exponent = 31 + 127</div><div class="line">    exponent = 158;</div><div class="line">  &#125; else &#123;</div><div class="line">    if (s) x = -x;  //if x is negative, change to positive</div><div class="line">    while(!(x&gt;&gt;i)) i--; //right shift until x=0</div><div class="line">    exponent = i + 127;</div><div class="line">    x = x &lt;&lt; (31 - i);  //clean zeros in higher bits</div><div class="line">    fraction_mask = 0x7fffff;</div><div class="line">    fraction = fraction_mask &amp; (x &gt;&gt; 8); //get fraction</div><div class="line">    x = x &amp; 0xff; //the lower 8 bits will be truncated</div><div class="line">    delta = (x &gt; 128) || ((x == 128) &amp;&amp; (fraction &amp; 1)); //if x&gt;=odd.5, delta = 1</div><div class="line">    fraction += delta;</div><div class="line">    if (fraction &gt;&gt; 23) &#123; //if fraction is larger than 23 bits</div><div class="line">      exponent += 1;</div><div class="line">      fraction &amp;= fraction_mask;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return (s&lt;&lt;31) | (exponent&lt;&lt;23) | fraction;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h2><p>将给定的unsigned uf表示的float * 2</p><p>如果uf是denormalized，uf的二进制左移1就是该数乘2。如果uf <em> 2还是denormalized，好理解。如果uf </em> 2变成了normalized，阶码变为1，尾数变为0.也成立。</p><p>如果uf是normalized，直接将uf的阶码+1，但如果uf的阶码+1之后全为1，就变成了inf，需要将尾数全部置为0.</p><p>如果uf是NaN或者inf，直接返回uf。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * float_twice - Return bit-level equivalent of expression 2*f for</div><div class="line"> *   floating point argument f.</div><div class="line"> *   Both the argument and result are passed as unsigned int&apos;s, but</div><div class="line"> *   they are to be interpreted as the bit-level representation of</div><div class="line"> *   single-precision floating point values.</div><div class="line"> *   When argument is NaN, return argument</div><div class="line"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</div><div class="line"> *   Max ops: 30</div><div class="line"> *   Rating: 4</div><div class="line"> */</div><div class="line">unsigned float_twice(unsigned uf) &#123;</div><div class="line">  if ((uf &amp; 0x7f800000) == 0) &#123; //denormalized</div><div class="line">    return (uf &amp; 0x80000000) | (uf &lt;&lt; 1);</div><div class="line">  &#125; else if ((uf &amp; 0x7f800000) != 0x7f800000) &#123;  //normalized</div><div class="line">    uf += (1 &lt;&lt; 23);</div><div class="line">    if ((uf &amp; 0x7f800000) == 0x7f800000) uf = uf &gt;&gt; 23 &lt;&lt; 23;</div><div class="line">    return uf;</div><div class="line">  &#125; else return uf;   // NaN or inf </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>整个实验内容让我更深入的理解计算机如何用二进制表示整数和浮点数，收获很大。可以配套CMU的网上课程学习该书，效果会更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h1&gt;&lt;p&gt;《深入理解计算机系统》的第一个实验，内容包括位操作，用二进制表示整数，浮点数，以及相应的操作。实验限定了可选用的操作符，并且
      
    
    </summary>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="整数表示" scheme="http://yoursite.com/tags/%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    
      <category term="浮点数表示" scheme="http://yoursite.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDU5157 Harry and magic string（Manacher+差分前缀）</title>
    <link href="http://yoursite.com/2015/11/04/HDU5157/"/>
    <id>http://yoursite.com/2015/11/04/HDU5157/</id>
    <published>2015-11-04T14:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5157" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5157</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个字符串s，问有多少对子串对(suba, subb)，使得suba和subb均为回文子串，且两个子串不能有重叠部分。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先可以用Manacher算法预处理出以每个字符（包括两个字符之间的位置）为中心能有多少个回文串。然后用差分前缀处理处pre、suf、sum三个数组。<br>其中pre数组表示到以某个字符结尾的回文串个数，suf表示以某个字符为开头的回文串个数，sum表示以某个字符之后的所有字符为开头的回文串个数。</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 210000;</div><div class="line">char s[N], str[N];</div><div class="line">int n, p[N];</div><div class="line">void KP(int len, char *str) &#123;</div><div class="line">    for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">        s[2 * i + 1] = &apos;#&apos;;</div><div class="line">        s[2 * i + 2] = str[i];</div><div class="line">    &#125;</div><div class="line">    int n = 2 * len;</div><div class="line">    s[0] = s[n + 1] = &apos;#&apos;;</div><div class="line">    s[n + 2] = 0;</div><div class="line">    int mx = 0, id;</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        if (mx &gt; i) p[i] = min(p[2 * id - i], mx - i);</div><div class="line">        else p[i] = 1;</div><div class="line">        while(s[i + p[i]] == s[i - p[i]]) p[i]++;</div><div class="line">        if (p[i] + i &gt; mx) &#123;</div><div class="line">            mx = p[i] + i;</div><div class="line">            id = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ll pre[N / 2], suf[N / 2], sum[N / 2];</div><div class="line">int main () &#123;</div><div class="line">    while(~scanf(&quot;%s&quot;, str)) &#123;</div><div class="line">        int len = strlen(str);</div><div class="line">        KP(len, str);</div><div class="line">        for (int i = 0; i &lt;= len + 1; i++) pre[i] = suf[i] = sum[i] = 0;</div><div class="line">        for (int i = 2; i &lt;= 2 * len; i++) &#123;</div><div class="line">            int x = i / 2;</div><div class="line">            if (i % 2 == 0) pre[x]++, pre[x + (p[i] / 2)]--;</div><div class="line">            else pre[x + 1]++, pre[x + (p[i] / 2) + 1]--;</div><div class="line">        &#125;</div><div class="line">        for (int i = 2 * len; i &gt;= 2; i--) &#123;</div><div class="line">            int x = i / 2;</div><div class="line">            if (i % 2 == 0) suf[x]++, suf[x - (p[i] / 2)]--;</div><div class="line">            else suf[x]++, suf[x - (p[i] / 2)]--;</div><div class="line">        &#125;</div><div class="line">        for (int i = len; i &gt;= 1; i--) &#123;</div><div class="line">            suf[i] += suf[i + 1];</div><div class="line">            sum[i] += sum[i + 1] + suf[i];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ll ans = 0;</div><div class="line">        for (int i = 1; i &lt;= len; i++) &#123;</div><div class="line">            pre[i] += pre[i - 1];</div><div class="line">            ans += (ll)pre[i] * (sum[i + 1]);</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%I64d\n&quot;, ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5157&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5157&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;有一个字符串s，问有多少对子串对(suba, subb)，使得suba和subb均为回文子串，且两个子串不能有重叠部分。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;首先可以用Manacher算法预处理出以每个字符（包括两个字符之间的位置）为中心能有多少个回文串。然后用差分前缀处理处pre、suf、sum三个数组。&lt;br&gt;其中pre数组表示到以某个字符结尾的回文串个数，suf表示以某个字符为开头的回文串个数，sum表示以某个字符之后的所有字符为开头的回文串个数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="Manacher" scheme="http://yoursite.com/tags/Manacher/"/>
    
      <category term="差分前缀" scheme="http://yoursite.com/tags/%E5%B7%AE%E5%88%86%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>HDU5156 Harry and Christmas tree（dfs序+查询区间内有多少个数）</title>
    <link href="http://yoursite.com/2015/10/29/HDU5156/"/>
    <id>http://yoursite.com/2015/10/29/HDU5156/</id>
    <published>2015-10-29T14:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5156" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5156</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一颗树，每个节点上有一些颜色的礼物，现在问以每个节点为根的子树有多少种不同的颜色。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先把每个节点相同的颜色去除，然后按照dfs序得到一个关于颜色的序列。问题就转化为查询若干个区间内有多少种不同的颜色。</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 50000 + 10;</div><div class="line">const int M = 500000 + 10;</div><div class="line">vector&lt;int&gt; g[N], gift[N];</div><div class="line">int st[N], ed[N], pos[N], ans[N], mp[2 * N], seq[M], s[M], nxt[M];</div><div class="line">int tot, n, m;</div><div class="line">bool cmp1(int a, int b) &#123; ///按左区间从小到大排</div><div class="line">    return st[a] &lt; st[b];</div><div class="line">&#125;</div><div class="line">bool cmp(int a, int b) &#123; ///按有区间从小到大排</div><div class="line">    return ed[a] &lt; ed[b];</div><div class="line">&#125;</div><div class="line">int lowbit(int x) &#123;</div><div class="line">    return x &amp; -x;</div><div class="line">&#125;</div><div class="line">void add(int p, int v) &#123;</div><div class="line">    while(p &lt;= tot) &#123;</div><div class="line">        s[p] += v;</div><div class="line">        p += lowbit(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int sum(int p) &#123;</div><div class="line">    int res = 0;</div><div class="line">    while(p &gt; 0) &#123;</div><div class="line">        res += s[p];</div><div class="line">        p -= lowbit(p);</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">void dfs(int u, int fa) &#123;</div><div class="line">    st[u] = tot + 1;</div><div class="line">    for (int i = 0; i &lt; gift[u].size(); i++) seq[++tot] = gift[u][i];</div><div class="line">    for (int i = 0; i &lt; g[u].size(); i++) &#123;</div><div class="line">        int v = g[u][i];</div><div class="line">        if (v != fa) dfs(v, u);</div><div class="line">    &#125;</div><div class="line">    ed[u] = tot;</div><div class="line">&#125;</div><div class="line">void init() &#123;</div><div class="line">    tot = 0;</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        g[i].clear();</div><div class="line">        gift[i].clear();</div><div class="line">        pos[i] = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123;</div><div class="line">        init();</div><div class="line">        int u, v;</div><div class="line">        for (int i = 1; i &lt; n; i++) &#123;</div><div class="line">            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</div><div class="line">            g[u].pb(v);</div><div class="line">            g[v].pb(u);</div><div class="line">        &#125;</div><div class="line">        int mx = 0;</div><div class="line">        while(m--) &#123;</div><div class="line">            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</div><div class="line">            if (find(gift[u].begin(), gift[u].end(), v) == gift[u].end()) gift[u].pb(v);</div><div class="line">            mx = max(mx, v);</div><div class="line">        &#125;</div><div class="line">        dfs(1, -1);</div><div class="line">        memset(s, 0, sizeof(int) * (tot + 5));</div><div class="line">        memset(mp, 0, sizeof(int) * (mx + 5));</div><div class="line">        ///按右区间从小到大排</div><div class="line">        sort(pos + 1, pos + n + 1, cmp);</div><div class="line">        for(int i = 1; i &lt;= tot; i++) &#123;</div><div class="line">            if(!mp[seq[i]]) &#123;</div><div class="line">                add(i, 1);</div><div class="line">                mp[seq[i]] = i; ///如果是第一次出现, mp[seq[i]]记录为当前位置</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int right = 1;</div><div class="line">        for(int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            int now = pos[i];</div><div class="line">            while(right &lt;= ed[now]) &#123;</div><div class="line">                if(mp[seq[right]] != right) &#123; ///如果不是第一次出现</div><div class="line">                    add(mp[seq[right]], -1);  ///减去前一次出现的</div><div class="line">                    add(right, 1);</div><div class="line">                    mp[seq[right]] = right;   ///重新定义这个数最近一次出现位置</div><div class="line">                &#125;</div><div class="line">                right++;</div><div class="line">            &#125;</div><div class="line">            ans[now] = sum(ed[now]) - sum(st[now] - 1);</div><div class="line">        &#125;</div><div class="line">/*</div><div class="line">        ///按左区间从小到大排</div><div class="line">        for (int i = 1; i &lt;= tot; i++) &#123;</div><div class="line">            if (!mp[seq[i]]) &#123;</div><div class="line">                mp[seq[i]] = i;</div><div class="line">                add(i, 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        memset(mp, 0, sizeof(int) * (mx + 5));</div><div class="line">        for (int i = tot; i &gt;= 1; i--) &#123;</div><div class="line">            if (!mp[seq[i]]) nxt[i] = tot + 1;</div><div class="line">            else nxt[i] = mp[seq[i]];</div><div class="line">            mp[seq[i]] = i;</div><div class="line">        &#125;</div><div class="line">        sort(pos + 1, pos + n + 1, cmp1);</div><div class="line">        int t = 1;</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            int now = pos[i];</div><div class="line">            while(t &lt;= tot &amp;&amp; t &lt; st[now]) &#123;</div><div class="line">                add(nxt[t++], 1);</div><div class="line">            &#125;</div><div class="line">            //cout&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;st[now]&lt;&lt;&quot; &quot;&lt;&lt;ed[now]&lt;&lt;endl;</div><div class="line">            ans[now] = sum(ed[now]) - sum(st[now] - 1);</div><div class="line">        &#125;</div><div class="line">*/</div><div class="line">        for (int i = 1; i &lt;= n; i++) printf(&quot;%d%c&quot;, ans[i], i == n ? &apos;\n&apos; : &apos; &apos;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5156&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5156&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;有一颗树，每个节点上有一些颜色的礼物，现在问以每个节点为根的子树有多少种不同的颜色。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;先把每个节点相同的颜色去除，然后按照dfs序得到一个关于颜色的序列。问题就转化为查询若干个区间内有多少种不同的颜色。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="dfs序" scheme="http://yoursite.com/tags/dfs%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ZOJ2112 Dynamic Rankings（动态区间第K大 树状数组套主席树）</title>
    <link href="http://yoursite.com/2015/10/28/ZOJ2112/"/>
    <id>http://yoursite.com/2015/10/28/ZOJ2112/</id>
    <published>2015-10-28T14:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112" target="_blank" rel="external">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>动态查询区间第K大数，带修改</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="http://www.cnblogs.com/Empress/p/4659824.html" target="_blank" rel="external">http://www.cnblogs.com/Empress/p/4659824.html</a><br>需要将询问离线处理，将一开始的数列用主席树维护。之后修改的部分用N个树状数组来维护，每次更新logn棵树。<br>时间复杂度：nlog^2n<br><a id="more"></a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 60000 + 10;</div><div class="line">#define lson l, m</div><div class="line">#define rson m + 1, r</div><div class="line">int a[N], Hash[N];</div><div class="line">int root[N], ln[N &lt;&lt; 5], rn[N &lt;&lt; 5], sum[N &lt;&lt; 5];</div><div class="line">int S[N];</div><div class="line">int n, m, tot;</div><div class="line">struct node &#123;</div><div class="line">    int l, r, k;</div><div class="line">    bool Q;</div><div class="line">&#125;op[10005];</div><div class="line">int build(int l, int r) &#123;</div><div class="line">    int rt = ++tot;</div><div class="line">    sum[rt] = 0;</div><div class="line">    if (l != r) &#123;</div><div class="line">        int m = l + r &gt;&gt; 1;</div><div class="line">        ln[rt] = build(lson);</div><div class="line">        rn[rt] = build(rson);</div><div class="line">    &#125;</div><div class="line">    return rt;</div><div class="line">&#125;</div><div class="line">int update(int pre, int l, int r, int x, int val) &#123;</div><div class="line">    int rt = ++tot;</div><div class="line">    ln[rt] = ln[pre], rn[rt] = rn[pre], sum[rt] = sum[pre] + val;</div><div class="line">    if (l &lt; r) &#123;</div><div class="line">        int m = l + r &gt;&gt; 1;</div><div class="line">        if (x &lt;= m) ln[rt] = update(ln[pre], lson, x, val);</div><div class="line">        else rn[rt] = update(rn[pre], rson, x, val);</div><div class="line">    &#125;</div><div class="line">    return rt;</div><div class="line">&#125;</div><div class="line">int lowbit(int x) &#123;</div><div class="line">    return x &amp; -x;</div><div class="line">&#125;</div><div class="line">int use[N];</div><div class="line">void add(int x, int pos, int val) &#123;</div><div class="line">    while(x &lt;= n) &#123;</div><div class="line">        S[x] = update(S[x], 1, m, pos, val);</div><div class="line">        x += lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int get_sum(int x) &#123;</div><div class="line">    int ret = 0;</div><div class="line">    while(x) &#123;</div><div class="line">        ret += sum[ln[use[x]]];</div><div class="line">        x -= lowbit(x);</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">int query(int u, int v, int lr, int rr, int l, int r, int k) &#123;</div><div class="line">    if (l &gt;= r) return l;</div><div class="line">    int m = l + r &gt;&gt; 1;</div><div class="line">    int tmp = get_sum(v) - get_sum(u) + sum[ln[rr]] - sum[ln[lr]];</div><div class="line">    if (tmp &gt;= k) &#123;</div><div class="line">        for (int i = u; i; i -= lowbit(i)) use[i] = ln[use[i]];</div><div class="line">        for (int i = v; i; i -= lowbit(i)) use[i] = ln[use[i]];</div><div class="line">        return query(u, v, ln[lr], ln[rr], lson, k);</div><div class="line">    &#125; else &#123;</div><div class="line">        for (int i = u; i; i -= lowbit(i)) use[i] = rn[use[i]];</div><div class="line">        for (int i = v; i; i -= lowbit(i)) use[i] = rn[use[i]];</div><div class="line">        return query(u, v, rn[lr], rn[rr], rson, k - tmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void modify(int x, int p, int d) &#123;</div><div class="line">    while(x &lt;= n) &#123;</div><div class="line">        S[x] = update(S[x], 1, m, p, d);</div><div class="line">        x += lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int t, q;</div><div class="line">    scanf(&quot;%d&quot;, &amp;t);</div><div class="line">    while(t--) &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;q);</div><div class="line">        m = tot = 0;</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            scanf(&quot;%d&quot;, a + i);</div><div class="line">            Hash[++m] = a[i];</div><div class="line">        &#125;</div><div class="line">        char s[10];</div><div class="line">        for (int i = 0; i &lt; q; i++) &#123;</div><div class="line">            scanf(&quot;%s&quot;, s);</div><div class="line">            if (s[0] == &apos;Q&apos;) &#123;</div><div class="line">                scanf(&quot;%d%d%d&quot;, &amp;op[i].l, &amp;op[i].r, &amp;op[i].k);</div><div class="line">                op[i].Q = 1;</div><div class="line">            &#125; else &#123;</div><div class="line">                scanf(&quot;%d%d&quot;, &amp;op[i].l, &amp;op[i].r);</div><div class="line">                op[i].Q = 0;</div><div class="line">                Hash[++m] = op[i].r;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        sort(Hash + 1, Hash + m + 1);</div><div class="line">        m = unique(Hash + 1, Hash + m + 1) - Hash - 1;</div><div class="line">        root[0] = build(1, m);</div><div class="line">        for (int i = 1; i &lt;= n; i++) root[i] = update(root[i - 1], 1, m, lower_bound(Hash + 1, Hash + m + 1, a[i]) - Hash, 1);</div><div class="line">        for (int i = 1; i &lt;= n; i++) S[i] = root[0];</div><div class="line">        for (int i = 0; i &lt; q; i++) &#123;</div><div class="line">            if (op[i].Q) &#123;</div><div class="line">                for (int j = op[i].l - 1; j; j -= lowbit(j)) use[j] = S[j];</div><div class="line">                for (int j = op[i].r; j; j -= lowbit(j)) use[j] = S[j];</div><div class="line">                printf(&quot;%d\n&quot;, Hash[query(op[i].l - 1, op[i].r, root[op[i].l - 1], root[op[i].r], 1, m, op[i].k)]);</div><div class="line">            &#125; else &#123;</div><div class="line">                modify(op[i].l, lower_bound(Hash + 1, Hash + m + 1, a[op[i].l]) - Hash, -1);</div><div class="line">                modify(op[i].l, lower_bound(Hash + 1, Hash + m + 1, op[i].r) - Hash, 1);</div><div class="line">                a[op[i].l] = op[i].r;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2112&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;动态查询区间第K大数，带修改&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Empress/p/4659824.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/Empress/p/4659824.html&lt;/a&gt;&lt;br&gt;需要将询问离线处理，将一开始的数列用主席树维护。之后修改的部分用N个树状数组来维护，每次更新logn棵树。&lt;br&gt;时间复杂度：nlog^2n&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>POJ2104 K-th Number（静态区间第K大 主席树）</title>
    <link href="http://yoursite.com/2015/10/22/POJ2104/"/>
    <id>http://yoursite.com/2015/10/22/POJ2104/</id>
    <published>2015-10-22T14:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://poj.org/problem?id=2104" target="_blank" rel="external">http://poj.org/problem?id=2104</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>静态查询区间第K大数</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="http://www.cnblogs.com/Empress/p/4652449.html" target="_blank" rel="external">http://www.cnblogs.com/Empress/p/4652449.html</a><br>主席数利用函数式线段树来维护数列，即每一个前缀维护一个线段树。再利用两个相邻的线段树只需要修改log级别，所以空间也能开下。一般用来解决区间第k大问题</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">#define lson l, m</div><div class="line">#define rson m + 1, r</div><div class="line">const int N = 1e5 + 5;</div><div class="line">int ln[N &lt;&lt; 5], rn[N &lt;&lt; 5], sum[N &lt;&lt; 5];</div><div class="line">int tot;</div><div class="line">int a[N], root[N], b[N];</div><div class="line">int build(int l, int r) &#123;</div><div class="line">    int rt = ++tot;</div><div class="line">    sum[rt] = 0;</div><div class="line">    if (l &lt; r) &#123;</div><div class="line">        int m = l + r &gt;&gt; 1;</div><div class="line">        ln[rt] = build(lson);</div><div class="line">        rn[rt] = build(rson);</div><div class="line">    &#125;</div><div class="line">    return rt;</div><div class="line">&#125;</div><div class="line">int update(int pre, int l, int r, int x) &#123;</div><div class="line">    int rt = ++tot;</div><div class="line">    ln[rt] = ln[pre], rn[rt] = rn[pre], sum[rt] = sum[pre] + 1;</div><div class="line">    if (l &lt; r) &#123;</div><div class="line">        int m = l + r &gt;&gt; 1;</div><div class="line">        if (x &lt;= m) ln[rt] = update(ln[pre], lson, x);</div><div class="line">        else rn[rt] = update(rn[pre], rson, x);</div><div class="line">    &#125;</div><div class="line">    return rt;</div><div class="line">&#125;</div><div class="line">int query(int u, int v, int l, int r, int k) &#123;</div><div class="line">    if (l &gt;= r) return l;</div><div class="line">    int m = l + r &gt;&gt; 1;</div><div class="line">    int num = sum[ln[v]] - sum[ln[u]];</div><div class="line">    if (num &gt;= k) return query(ln[u], ln[v], lson, k);</div><div class="line">    else return query(rn[u], rn[v], rson, k - num);</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    tot = 0;</div><div class="line">    int n, m;</div><div class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</div><div class="line">    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i), b[i] = a[i];</div><div class="line">    sort(b + 1, b + n + 1);</div><div class="line">    int cnt = unique(b + 1, b + n + 1) - b - 1;</div><div class="line">    root[0] = build(1, cnt);</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        int x = lower_bound(b + 1, b + n + 1, a[i]) - b;</div><div class="line">        root[i] = update(root[i - 1], 1, cnt, x);</div><div class="line">    &#125;</div><div class="line">    while(m--) &#123;</div><div class="line">        int l, r, k;</div><div class="line">        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);</div><div class="line">        int x = query(root[l - 1], root[r], 1, cnt, k);</div><div class="line">        printf(&quot;%d\n&quot;, b[x]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://poj.org/problem?id=2104&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://poj.org/problem?id=2104&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;静态查询区间第K大数&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Empress/p/4652449.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/Empress/p/4652449.html&lt;/a&gt;&lt;br&gt;主席数利用函数式线段树来维护数列，即每一个前缀维护一个线段树。再利用两个相邻的线段树只需要修改log级别，所以空间也能开下。一般用来解决区间第k大问题&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>SPOJ DQUERY - D-query（查询区间内有几个数 离线树状数组OR在线主席树）</title>
    <link href="http://yoursite.com/2015/10/22/SPOJ-DQUERY/"/>
    <id>http://yoursite.com/2015/10/22/SPOJ-DQUERY/</id>
    <published>2015-10-22T05:40:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://www.spoj.com/problems/DQUERY/en/" target="_blank" rel="external">http://www.spoj.com/problems/DQUERY/en/</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>查询区间内有几个不同的数</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="http://blog.csdn.net/acm_cxlove/article/details/8562634" target="_blank" rel="external">http://blog.csdn.net/acm_cxlove/article/details/8562634</a></p><ol><li><p>离线树状数组<br>将查询区间按左端点排序<br>对于相同的数，先更新最左边的位置<br>然后根据查询区间，不断更新next，保证查询区间内只记录一个位置<br>维护前缀和用树状数组，时空效率都高</p></li><li><p>在线主席树<br><a href="http://www.cnblogs.com/Empress/p/4675386.html" target="_blank" rel="external">http://www.cnblogs.com/Empress/p/4675386.html</a><br>将重复的元素建树。在query的时候把区间内重复的数加起来，用区间长度(r-l+1)去减就是答案<br>(query的是[l, r]之间重复元素的个数)<br>举个例子：1 1 2 1 3 2 3<br>我们从左到右枚举，如果没有重复的，那么树的形态和之前一样，出现重复的则在重复的位置加1，建一颗新树<br>这样我们需要建7颗数<br> 1 2 3 4 5 6 7<br>T0:<br>T1:<br>T2: 1<br>T3: 1<br>T4: 1 1<br>T5: 1 1<br>T6: 1 1 1<br>T7: 1 1 1  1<br>例如查询区间[2，5] 就需要用T5-T1，但是不能直接减，直接减重复的数为2个1。需要统计的是区间[2,5]内重复的个数，正好为1个1.</p></li></ol><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>离线树状数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 30000 + 100;</div><div class="line">const int M = 200000 + 100;</div><div class="line">int a[N], s[N], n, nxt[N];</div><div class="line">struct node &#123;</div><div class="line">    int l, r, id;</div><div class="line">    bool operator &lt; (const node &amp; T) const &#123;</div><div class="line">        return l &lt; T.l;</div><div class="line">    &#125;</div><div class="line">&#125; Q[M];</div><div class="line">int ans[M];</div><div class="line">int lowbit(int x) &#123;</div><div class="line">    return x &amp; -x;</div><div class="line">&#125;</div><div class="line">void add(int p, int v) &#123;</div><div class="line">    while(p &lt;= n) &#123;</div><div class="line">        s[p] += v;</div><div class="line">        p += lowbit(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int sum(int p) &#123;</div><div class="line">    int res = 0;</div><div class="line">    while(p &gt; 0) &#123;</div><div class="line">        res += s[p];</div><div class="line">        p -= lowbit(p);</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">map&lt;int, int&gt; mp;</div><div class="line">int main () &#123;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;n)) &#123;</div><div class="line">        mp.clear();</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            scanf(&quot;%d&quot;, a + i);</div><div class="line">            if (!mp.count(a[i])) &#123;</div><div class="line">                mp[a[i]] = i;</div><div class="line">                add(i, 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mp.clear();</div><div class="line">        for (int i = n; i &gt;= 1; i--) &#123;</div><div class="line">            if (!mp.count(a[i])) nxt[i] = n + 1;</div><div class="line">            else nxt[i] = mp[a[i]];</div><div class="line">            mp[a[i]] = i;</div><div class="line">        &#125;</div><div class="line">        int q;</div><div class="line">        scanf(&quot;%d&quot;, &amp;q);</div><div class="line">        for (int i = 0; i &lt; q; i++) &#123;</div><div class="line">            scanf(&quot;%d%d&quot;, &amp;Q[i].l, &amp;Q[i].r);</div><div class="line">            Q[i].id = i;</div><div class="line">        &#125;</div><div class="line">        sort(Q, Q + q);</div><div class="line">        int t = 1;</div><div class="line">        for (int i = 0; i &lt; q; i++) &#123;</div><div class="line">            while(t &lt;= n &amp;&amp; t &lt; Q[i].l) &#123;</div><div class="line">                add(nxt[t++], 1);</div><div class="line">            &#125;</div><div class="line">            ans[Q[i].id] = sum(Q[i].r) - sum(Q[i].l - 1);</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; q; i++) printf(&quot;%d\n&quot;, ans[i]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在线主席树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;map&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">typedef long long LL;</div><div class="line">#define lson l, m</div><div class="line">#define rson m + 1, r</div><div class="line">const int N = 30000 + 10;</div><div class="line">int ln[N &lt;&lt; 5], rn[N &lt;&lt; 5], sum[N &lt;&lt; 5];</div><div class="line">int tot, root[N], a[N];</div><div class="line">map&lt;int, int&gt; mp;</div><div class="line">int build(int l, int r) &#123;</div><div class="line">    int rt = ++tot;</div><div class="line">    sum[rt] = 0;</div><div class="line">    if (l &lt; r) &#123;</div><div class="line">        int m = l + r &gt;&gt; 1;</div><div class="line">        ln[rt] = build(lson);</div><div class="line">        rn[rt] = build(rson);</div><div class="line">    &#125;</div><div class="line">    return rt;</div><div class="line">&#125;</div><div class="line">int update(int pre, int l, int r, int x) &#123;</div><div class="line">    int rt = ++tot;</div><div class="line">    ln[rt] = ln[pre], rn[rt] = rn[pre], sum[rt] = sum[pre] + 1;</div><div class="line">    if (l &lt; r) &#123;</div><div class="line">        int m = l + r &gt;&gt; 1;</div><div class="line">        if (x &lt;= m) ln[rt] = update(ln[pre], lson, x);</div><div class="line">        else rn[rt] = update(rn[pre], rson, x);</div><div class="line">    &#125;</div><div class="line">    return rt;</div><div class="line">&#125;</div><div class="line">int query(int u, int v, int l, int r, int k) &#123;</div><div class="line">    if (l &gt;= k) return sum[v] - sum[u];</div><div class="line">    int ans = 0;</div><div class="line">    int m = l + r &gt;&gt; 1;</div><div class="line">    if (k &lt;= m) ans += query(ln[u], ln[v], lson, k);</div><div class="line">    ans += query(rn[u], rn[v], rson, k);</div><div class="line">    return ans;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int n, m;</div><div class="line">    tot = 0;</div><div class="line">    scanf(&quot;%d&quot;, &amp;n);</div><div class="line">    for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i);</div><div class="line">    root[0] = build(1, n);</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        if (mp.find(a[i]) != mp.end()) root[i] = update(root[i - 1], 1, n, mp[a[i]]);</div><div class="line">        else root[i] = root[i - 1];</div><div class="line">        mp[a[i]] = i;</div><div class="line">    &#125;</div><div class="line">    scanf(&quot;%d&quot;, &amp;m);</div><div class="line">    int l, r;</div><div class="line">    while(m--) &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);</div><div class="line">        printf(&quot;%d\n&quot;, r - l + 1 - query(root[l - 1], root[r], 1, n, l));</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://www.spoj.com/problems/DQUERY/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.spoj.com/problems/DQUERY/en/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;查询区间内有几个不同的数&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/acm_cxlove/article/details/8562634&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/acm_cxlove/article/details/8562634&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;离线树状数组&lt;br&gt;将查询区间按左端点排序&lt;br&gt;对于相同的数，先更新最左边的位置&lt;br&gt;然后根据查询区间，不断更新next，保证查询区间内只记录一个位置&lt;br&gt;维护前缀和用树状数组，时空效率都高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在线主席树&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/Empress/p/4675386.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/Empress/p/4675386.html&lt;/a&gt;&lt;br&gt;将重复的元素建树。在query的时候把区间内重复的数加起来，用区间长度(r-l+1)去减就是答案&lt;br&gt;(query的是[l, r]之间重复元素的个数)&lt;br&gt;举个例子：1 1 2 1 3 2 3&lt;br&gt;我们从左到右枚举，如果没有重复的，那么树的形态和之前一样，出现重复的则在重复的位置加1，建一颗新树&lt;br&gt;这样我们需要建7颗数&lt;br&gt; 1 2 3 4 5 6 7&lt;br&gt;T0:&lt;br&gt;T1:&lt;br&gt;T2: 1&lt;br&gt;T3: 1&lt;br&gt;T4: 1 1&lt;br&gt;T5: 1 1&lt;br&gt;T6: 1 1 1&lt;br&gt;T7: 1 1 1  1&lt;br&gt;例如查询区间[2，5] 就需要用T5-T1，但是不能直接减，直接减重复的数为2个1。需要统计的是区间[2,5]内重复的个数，正好为1个1.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5152 A Strange Problem（线段树+数论）</title>
    <link href="http://yoursite.com/2015/10/13/hdu5152/"/>
    <id>http://yoursite.com/2015/10/13/hdu5152/</id>
    <published>2015-10-13T08:29:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5152" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5152</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>某天你收到了一个信封，信封里是一个奇怪的题目。首先给你一个长度为N的序列，序列为A1,A2,…,AN.然后有M个操作，每个操作为以下三种操作的其中一个：</p><ol><li>输出操作。给你l,r，输出区间和。</li><li>修改操作。给你x，把Ax修改为2^Ax</li><li>加法操作。给你l,r,x，区间加上​​x<br>由于输出操作的结果可能很大，输出结果对2333333取模。</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题复杂就是操作2。需要补充一个知识<br>指数循环节：当x &gt;= Phi(C)时, A^x = A ^ (x%Phi(C) + Phi(C)) (mod C). Phi(C)是C的欧拉函数，<br>对于2333333这个模数来说，求18次欧拉函数后就变成了1，所以只需要保存19层第三次操作的加数即可，然后就直接是线段树区间更新和询问操作了<br>参考题解写的代码，主要是计算操作二的时候，用一个vector记录某一位置操作二的个数，其实只需要记录最后的19个操作即可。具体细节见代码</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define lson l, m, rt &lt;&lt; 1</div><div class="line">#define rson m+1, r, rt &lt;&lt; 1 | 1</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int mod = 2333333;</div><div class="line">const int N = 50005;</div><div class="line">int mo[20] = &#123;2333333, 2196720, 580608, 165888, 55296, 18432, 6144, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1&#125;;</div><div class="line">int pow2[33];</div><div class="line">vector&lt;ll&gt; vt[N];</div><div class="line">ll mark[N &lt;&lt; 2];</div><div class="line">int len[N &lt;&lt; 2], sum[N &lt;&lt; 2];</div><div class="line">int n, m;</div><div class="line">inline void add(int &amp;x, int y) &#123;</div><div class="line">    x += y;</div><div class="line">    if (x &gt;= mod) x -= mod;</div><div class="line">&#125;</div><div class="line">void up(int rt) &#123;</div><div class="line">    sum[rt]  = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];</div><div class="line">    add(sum[rt], 0);</div><div class="line">&#125;</div><div class="line">void down(int rt) &#123;</div><div class="line">    if (mark[rt]) &#123;</div><div class="line">        mark[rt &lt;&lt; 1] += mark[rt];</div><div class="line">        mark[rt &lt;&lt; 1 | 1] += mark[rt];</div><div class="line">        add(sum[rt &lt;&lt; 1], 1LL * len[rt &lt;&lt; 1] * mark[rt] % mod);</div><div class="line">        add(sum[rt &lt;&lt; 1 | 1], 1LL * len[rt &lt;&lt; 1 | 1] * mark[rt] % mod);</div><div class="line">        mark[rt] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void build(int l, int r, int rt) &#123;</div><div class="line">    mark[rt] = 0;</div><div class="line">    len[rt] = r - l + 1;</div><div class="line">    if (l == r) &#123;</div><div class="line">        int x;</div><div class="line">        scanf(&quot;%d&quot;, &amp;x);</div><div class="line">        vt[l].clear();</div><div class="line">        vt[l].pb(x);</div><div class="line">        sum[rt] = x % mod;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    int m = l + r &gt;&gt; 1;</div><div class="line">    build(lson);</div><div class="line">    build(rson);</div><div class="line">    up(rt);</div><div class="line">&#125;</div><div class="line">int query(int L, int R, int l, int r, int rt) &#123;</div><div class="line">    if (L &lt;= l &amp;&amp; r &lt;= R) return sum[rt];</div><div class="line">    down(rt);</div><div class="line">    int m = l + r &gt;&gt; 1, ret = 0;</div><div class="line">    if (L &lt;= m) add(ret, query(L, R, lson));</div><div class="line">    if (R &gt; m) add(ret, query(L, R, rson));</div><div class="line">    up(rt);</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">void update(int L, int R, int v, int l, int r, int rt) &#123;</div><div class="line">    if (L &lt;= l &amp;&amp; r &lt;= R) &#123;</div><div class="line">        mark[rt] += v;</div><div class="line">        add(sum[rt], 1LL * len[rt] * v % mod);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    down(rt);</div><div class="line">    int m = l + r &gt;&gt; 1;</div><div class="line">    if (L &lt;= m) update(L, R, v, lson);</div><div class="line">    if (R &gt; m) update(L, R, v, rson);</div><div class="line">    up(rt);</div><div class="line">&#125;</div><div class="line">int pow_mod(int x, int n, int mod) &#123;</div><div class="line">    int ret = 1;</div><div class="line">    while(n) &#123;</div><div class="line">        if (n &amp; 1) ret = 1LL * ret * x % mod;</div><div class="line">        x = 1LL * x * x % mod;</div><div class="line">        n &gt;&gt;= 1;</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">int cal(vector&lt;ll&gt; &amp;v) &#123;</div><div class="line">    if (v.size() &lt; 19) &#123;</div><div class="line">        int pos = v.size() - 1;</div><div class="line">        ll ret = v[0];</div><div class="line">        bool flag = false;</div><div class="line">        if (v[0] &gt;= mo[pos]) &#123;</div><div class="line">            flag = true;</div><div class="line">            ret = ret % mo[pos] + mo[pos];</div><div class="line">        &#125;</div><div class="line">        pos--;</div><div class="line">        for (int i = 1; i &lt; v.size(); i++) &#123;</div><div class="line">            if (flag) &#123;</div><div class="line">                ret = (pow_mod(2, ret, mo[pos]) + v[i]) % mo[pos] + mo[pos];</div><div class="line">            &#125; else &#123;</div><div class="line">                if (ret &gt;= 30 || pow2[ret] &gt;= mo[pos]) &#123;</div><div class="line">                    flag = true;</div><div class="line">                    ret = (pow_mod(2, ret, mo[pos]) + v[i]) % mo[pos] + mo[pos];</div><div class="line">                &#125; else &#123;</div><div class="line">                    ret = pow2[ret] + v[i];</div><div class="line">                    if (ret &gt;= mo[pos]) &#123;</div><div class="line">                        flag = true;</div><div class="line">                        ret = ret % mo[pos] + mo[pos];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            pos--;</div><div class="line">        &#125;</div><div class="line">        return ret % mod;</div><div class="line">    &#125; else &#123;</div><div class="line">        ll ret = 1;</div><div class="line">        int pos = 17;</div><div class="line">        for (int i = v.size() - 18; i &lt; v.size(); i++) &#123;</div><div class="line">            ret = (pow_mod(2, ret, mo[pos]) + v[i]) % mo[pos] + mo[pos];</div><div class="line">            pos--;</div><div class="line">        &#125;</div><div class="line">        return ret % mod;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">void modify(int x, int l, int r, int rt) &#123;</div><div class="line">    if (l == r) &#123;</div><div class="line">        if (mark[rt]) &#123;</div><div class="line">            vt[l][vt[l].size() - 1] += mark[rt];</div><div class="line">            mark[rt] = 0;</div><div class="line">        &#125;</div><div class="line">        vt[l].pb(0);</div><div class="line">        sum[rt] = cal(vt[l]);</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    down(rt);</div><div class="line">    int m = l + r &gt;&gt; 1;</div><div class="line">    if (x &lt;= m) modify(x, lson);</div><div class="line">    else modify(x, rson);</div><div class="line">    up(rt);</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    pow2[0] = 1;</div><div class="line">    for (int i = 1; i &lt;= 30; i++) pow2[i] = pow2[i - 1] &lt;&lt; 1;</div><div class="line">    int op, l, r, x;</div><div class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123;</div><div class="line">        build(1, n, 1);</div><div class="line">        while(m--) &#123;</div><div class="line">            scanf(&quot;%d&quot;, &amp;op);</div><div class="line">            if (op == 1) &#123;</div><div class="line">                scanf(&quot;%d%d&quot;, &amp;l, &amp;r);</div><div class="line">                printf(&quot;%d\n&quot;, query(l, r, 1, n, 1));</div><div class="line">            &#125;else if (op == 2) &#123;</div><div class="line">                scanf(&quot;%d&quot;, &amp;x);</div><div class="line">                modify(x, 1, n, 1);</div><div class="line">            &#125; else &#123;</div><div class="line">                scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;x);</div><div class="line">                update(l, r, x, 1, n, 1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5152&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5152&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;某天你收到了一个信封，信封里是一个奇怪的题目。首先给你一个长度为N的序列，序列为A1,A2,…,AN.然后有M个操作，每个操作为以下三种操作的其中一个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输出操作。给你l,r，输出区间和。&lt;/li&gt;
&lt;li&gt;修改操作。给你x，把Ax修改为2^Ax&lt;/li&gt;
&lt;li&gt;加法操作。给你l,r,x，区间加上​​x&lt;br&gt;由于输出操作的结果可能很大，输出结果对2333333取模。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;这道题复杂就是操作2。需要补充一个知识&lt;br&gt;指数循环节：当x &amp;gt;= Phi(C)时, A^x = A ^ (x%Phi(C) + Phi(C)) (mod C). Phi(C)是C的欧拉函数，&lt;br&gt;对于2333333这个模数来说，求18次欧拉函数后就变成了1，所以只需要保存19层第三次操作的加数即可，然后就直接是线段树区间更新和询问操作了&lt;br&gt;参考题解写的代码，主要是计算操作二的时候，用一个vector记录某一位置操作二的个数，其实只需要记录最后的19个操作即可。具体细节见代码&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5151 Sit sit sit（区间dp）</title>
    <link href="http://yoursite.com/2015/10/13/hdu5151/"/>
    <id>http://yoursite.com/2015/10/13/hdu5151/</id>
    <published>2015-10-13T06:58:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5151" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5151</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有n个人陆续坐到n个椅子上，每张椅子为两种颜色中的一种。每个人每次可以选择一个空位置，如果该空位置两边都有人，且两边的椅子颜色不同，那么他便不能坐下，需要离开。现在问n个人全部坐下的方案数</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>dp[i][j]表示编号i-j的位置上都有人坐下的方案数。dp[i][i] = 1, dp[i][i+1] = 2<br>dp[i][j] =sum(dp[i][k-1] <em> dp[k+1][j] </em> C(j-i, k-i-1)) 当i-k-1有人坐下，k+1-j有人坐下，此时来的人坐在k的方案数累积<br>C(j-i, k-i-1)表示前面的j-i个人有k-i-1个人选择坐在了左边的方案数</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int CN = 111;</div><div class="line">const int mod = 1000000007;</div><div class="line">ll c[CN][CN]= &#123;&#125;;</div><div class="line">void cinit() &#123;</div><div class="line">    for(int i = 0; i &lt;= 100; i++) &#123;</div><div class="line">        c[i][0] = c[i][i] = 1;</div><div class="line">        for(int j = 1; j &lt; i; j++) &#123;</div><div class="line">            c[i][j] = c[i - 1][j] + c[i - 1][j - 1];</div><div class="line">            if (c[i][j] &gt; mod) c[i][j] -= mod;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ll dp[CN][CN];</div><div class="line">int n, a[CN];</div><div class="line">int main () &#123;</div><div class="line">    cinit();</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;n)) &#123;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            scanf(&quot;%d&quot;, a + i);</div><div class="line">            dp[i][i] = 1;</div><div class="line">            dp[i][i + 1] = 2;</div><div class="line">        &#125;</div><div class="line">        for (int l = 3; l &lt;= n; l++) &#123;</div><div class="line">            for (int i = 0; i + l &lt;= n; i++) &#123;</div><div class="line">                int j = i + l - 1;</div><div class="line">                dp[i][j] = 0;</div><div class="line">                //head</div><div class="line">                dp[i][j] += dp[i + 1][j];</div><div class="line">                //mid</div><div class="line">                for (int k = i + 1; k &lt;= j - 1; k++) if (a[k - 1] == a[k + 1]) &#123;</div><div class="line">                    dp[i][j] += c[l - 1][k - i] * dp[i][k - 1] % mod * dp[k + 1][j] % mod;</div><div class="line">                    dp[i][j] %= mod;</div><div class="line">                &#125;</div><div class="line">                //tail</div><div class="line">                dp[i][j] += dp[i][j - 1];</div><div class="line">                dp[i][j] %= mod;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%I64d\n&quot;, dp[0][n - 1]);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5151&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5151&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;有n个人陆续坐到n个椅子上，每张椅子为两种颜色中的一种。每个人每次可以选择一个空位置，如果该空位置两边都有人，且两边的椅子颜色不同，那么他便不能坐下，需要离开。现在问n个人全部坐下的方案数&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;dp[i][j]表示编号i-j的位置上都有人坐下的方案数。dp[i][i] = 1, dp[i][i+1] = 2&lt;br&gt;dp[i][j] =sum(dp[i][k-1] &lt;em&gt; dp[k+1][j] &lt;/em&gt; C(j-i, k-i-1)) 当i-k-1有人坐下，k+1-j有人坐下，此时来的人坐在k的方案数累积&lt;br&gt;C(j-i, k-i-1)表示前面的j-i个人有k-i-1个人选择坐在了左边的方案数&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="区间dp" scheme="http://yoursite.com/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5085 Counting problem（暴力+HashTable）</title>
    <link href="http://yoursite.com/2015/10/11/hdu5085/"/>
    <id>http://yoursite.com/2015/10/11/hdu5085/</id>
    <published>2015-10-10T17:16:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5085" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5085</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>定义f(n,k) = 各位数字的k次方和。例如f(305, 2) = 5^2 + 0^2 + 3^2 = 34<br>给定a,b,k,s。求[a,b]区间内满足f(n,k)=s的数字个数<br>1≤a≤b≤999999999;    1≤k≤15;    1≤S≤10^16</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>把n分为按照长度分为两半部分，前半部分暴力枚举，后半部分加入hash表中，这样将复杂度降到sqrt(n)hash表中记录每种和的情况数。要注意一些细节：</p><ol><li>不妨设一个B=10000，如果a,b都小于B。直接枚举即可</li><li>当b大于B时，ahead = (a-1) / B, atail = a % B   bhead = b / B, btail = b % B<br>将0~B-1的数字加入hash表时，记录一下以ahead开头符合条件的个数resa，再记录一下以bhead开头的符合条件的resb<br>之后枚举[ahead, bhead), 符合条件的累加到resb中，最后答案即为resb-resa</li></ol><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">//Hash Table</div><div class="line">#define pii pair&lt;ll, ll&gt;</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define MAXN 10010</div><div class="line">#define mod  40007</div><div class="line">struct HashKey &#123;</div><div class="line">    ll key;</div><div class="line">    int nxt, cnt;</div><div class="line">&#125; e[MAXN];</div><div class="line">int link1[MAXN * 4], p, k;</div><div class="line">ll s;</div><div class="line">void init() &#123;</div><div class="line">    memset(link1, -1, sizeof(link1));</div><div class="line">    p = 0;</div><div class="line">&#125;</div><div class="line">void add(ll key) &#123;</div><div class="line">    e[p].key = key;</div><div class="line">    e[p].cnt = 1;</div><div class="line">    int modKey = key % mod;</div><div class="line">    if (modKey &lt; 0) modKey += mod;</div><div class="line">    e[p].nxt = link1[modKey];</div><div class="line">    link1[modKey] = p++;</div><div class="line">&#125;</div><div class="line">int Find(ll key) &#123;</div><div class="line">    int modKey = key % mod;</div><div class="line">    if (modKey &lt; 0) modKey += mod;</div><div class="line">    for (int i = link1[modKey]; i != -1; i = e[i].nxt) &#123;</div><div class="line">        if (e[i].key == key) &#123;</div><div class="line">            return i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div><div class="line">ll calc(int x) &#123;</div><div class="line">    ll ans = 0, tmp = 1;</div><div class="line">    while(x) &#123;</div><div class="line">        int t = x % 10;</div><div class="line">        x /= 10;</div><div class="line">        tmp = 1;</div><div class="line">        for (int i = 0; i &lt; k; i++) tmp *= t;</div><div class="line">        ans += tmp;</div><div class="line">    &#125;</div><div class="line">    if (ans &gt; s) return -1;</div><div class="line">    return ans;</div><div class="line">&#125;</div><div class="line">void solve(int x)  &#123;</div><div class="line">    ll ans = calc(x);</div><div class="line">    if (ans &gt; s || ans == -1) return ;</div><div class="line">    int k = Find(ans);</div><div class="line">    if (k == -1) add(ans);</div><div class="line">    else e[k].cnt++;</div><div class="line">&#125;</div><div class="line">int work(int ahead) &#123;</div><div class="line">    ll ans = calc(ahead);</div><div class="line">    if (ans == -1) return 0;</div><div class="line">    if (ans &lt;= s) &#123;</div><div class="line">        int x = Find(s - ans);</div><div class="line">        if (x != -1) return e[x].cnt;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    ll a, b;</div><div class="line">    int B = 10000;</div><div class="line">    while(~scanf(&quot;%I64d%I64d%d%I64d&quot;, &amp;a, &amp;b, &amp;k, &amp;s)) &#123;</div><div class="line">        if (b &lt; B) &#123;</div><div class="line">            int res = 0;</div><div class="line">            for (int i = a; i &lt;= b; i++) &#123;</div><div class="line">                if (calc(i) == s) res++;</div><div class="line">            &#125;</div><div class="line">            printf(&quot;%d\n&quot;, res);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        init();</div><div class="line">        int bhead = b / B, btail = b % B;</div><div class="line">        int ahead = (a - 1) / B, atail = (a - 1) % B;</div><div class="line">        ll resa = 0, resb = 0;</div><div class="line">        if (atail &lt; btail) &#123;</div><div class="line">            for (int i = 0; i &lt;= atail; i++) solve(i);</div><div class="line">            resa = work(ahead);</div><div class="line">            for (int i = atail + 1; i &lt;= btail; i++) solve(i);</div><div class="line">            resb = work(bhead);</div><div class="line">            for (int i = btail + 1; i &lt; B; i++) solve(i);</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int i = 0; i &lt;= btail; i++) solve(i);</div><div class="line">            resb = work(bhead);</div><div class="line">            for (int i = btail + 1; i &lt;= atail; i++) solve(i);</div><div class="line">            resa = work(ahead);</div><div class="line">            for (int i = atail + 1; i &lt; B; i++) solve(i);</div><div class="line">        &#125;</div><div class="line">        for (int i = ahead; i &lt; bhead; i++) resb += work(i);</div><div class="line">        printf(&quot;%I64d\n&quot;, resb - resa);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5085&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5085&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;定义f(n,k) = 各位数字的k次方和。例如f(305, 2) = 5^2 + 0^2 + 3^2 = 34&lt;br&gt;给定a,b,k,s。求[a,b]区间内满足f(n,k)=s的数字个数&lt;br&gt;1≤a≤b≤999999999;    1≤k≤15;    1≤S≤10^16&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;把n分为按照长度分为两半部分，前半部分暴力枚举，后半部分加入hash表中，这样将复杂度降到sqrt(n)hash表中记录每种和的情况数。要注意一些细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不妨设一个B=10000，如果a,b都小于B。直接枚举即可&lt;/li&gt;
&lt;li&gt;当b大于B时，ahead = (a-1) / B, atail = a % B   bhead = b / B, btail = b % B&lt;br&gt;将0~B-1的数字加入hash表时，记录一下以ahead开头符合条件的个数resa，再记录一下以bhead开头的符合条件的resb&lt;br&gt;之后枚举[ahead, bhead), 符合条件的累加到resb中，最后答案即为resb-resa&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5148 Cities（树dp）</title>
    <link href="http://yoursite.com/2015/10/10/hdu5148/"/>
    <id>http://yoursite.com/2015/10/10/hdu5148/</id>
    <published>2015-10-10T12:38:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5148" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5148</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一棵树，数的节点数为n。问从中选出K个点，使得这些点之间的距离和最小</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>考虑每条边的贡献，一条边会把树分成两部分，若在其中一部分里选择了x个点，则这条边被统计的次数为x<em>(K-x)</em>2. 那么考虑dp[u][i]表示在u的子树中选择了i个点的最小代价，有转移dp[u][i] = min(dp[u][i-j]+ dp[v][j] + j<em>(K-j)</em>2*c)​​<br><a id="more"></a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">#define pii pair&lt;int, int&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 2100;</div><div class="line">int K, n;</div><div class="line">vector&lt; pii &gt; g[N];</div><div class="line">ll dp[N][55];</div><div class="line">void change(ll &amp;x, ll v) &#123;</div><div class="line">    if (x == -1 || x &gt; v) x = v;</div><div class="line">&#125;</div><div class="line">void dfs(int u, int fa) &#123;</div><div class="line">    dp[u][1] = 0;</div><div class="line">    for (int i = 0; i &lt; g[u].size(); i++) &#123;</div><div class="line">        int v = g[u][i].fi, c = g[u][i].se;</div><div class="line">        if (v == fa) continue;</div><div class="line">        dfs(v, u);</div><div class="line">        for (int j = K - 1; j &gt;= 1; j--) &#123;</div><div class="line">            if (dp[u][j] == -1) continue;</div><div class="line">            for (int k = 1; j + k &lt;= K; k++) &#123;</div><div class="line">                if (dp[v][k] == -1) continue;</div><div class="line">                change(dp[u][j + k], dp[u][j] + dp[v][k] + (ll)2 * k * (K - k) * c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int t, u, v, c;</div><div class="line">    scanf(&quot;%d&quot;, &amp;t);</div><div class="line">    while(t--) &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;K);</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            g[i].clear();</div><div class="line">            for (int j = 0; j &lt;= K; j++) dp[i][j] = -1;</div><div class="line">        &#125;</div><div class="line">        for (int i = 1; i &lt; n; i++) &#123;</div><div class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c);</div><div class="line">            g[u].pb(&#123;v, c&#125;);</div><div class="line">            g[v].pb(&#123;u, c&#125;);</div><div class="line">        &#125;</div><div class="line">        dfs(1, -1);</div><div class="line">        ll ans = dp[1][K];</div><div class="line">        for (int i = 2; i &lt;= n; i++) if (dp[i][K] != -1) ans = min(ans, dp[i][K]);</div><div class="line">        printf(&quot;%I64d\n&quot;, ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5148&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5148&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一棵树，数的节点数为n。问从中选出K个点，使得这些点之间的距离和最小&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;考虑每条边的贡献，一条边会把树分成两部分，若在其中一部分里选择了x个点，则这条边被统计的次数为x&lt;em&gt;(K-x)&lt;/em&gt;2. 那么考虑dp[u][i]表示在u的子树中选择了i个点的最小代价，有转移dp[u][i] = min(dp[u][i-j]+ dp[v][j] + j&lt;em&gt;(K-j)&lt;/em&gt;2*c)​​&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="树dp" scheme="http://yoursite.com/tags/%E6%A0%91dp/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5183 Negative and Positive (NP)（HashTable）</title>
    <link href="http://yoursite.com/2015/10/09/hdu5183/"/>
    <id>http://yoursite.com/2015/10/09/hdu5183/</id>
    <published>2015-10-09T12:16:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5183" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5183</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定n个数的序列（A0,A1,A2…,An-1) 规定NP-sum(i,j) = Ai - Ai+1 + Ai+2 + (-1)^(j-i)Aj<br>现在给定一个K，问是否有一个NP-sum(i,j)=K<br>1≤n≤1000000,−1000000000≤ai≤1000000000,−1000000000≤K≤1000000000</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>sum[i]=a1−a2+a3…。手写一个哈希表来保存所有出现过的sum值,然后根据奇偶性分类判断在哈系表中是否存在对应的子序列满足题意</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">//Hash Table</div><div class="line">#define MAXN 1001000</div><div class="line">#define mod  4000007</div><div class="line">struct HashKey &#123;</div><div class="line">    ll key;</div><div class="line">    int nxt, pos;</div><div class="line">&#125;e[MAXN];</div><div class="line">int link1[MAXN * 4], p;</div><div class="line">void init() &#123;</div><div class="line">    memset(link1, -1, sizeof(link1));</div><div class="line">    p = 0;</div><div class="line">&#125;</div><div class="line">void add(ll key, int pos) &#123;</div><div class="line">    e[p].key = key;</div><div class="line">    e[p].pos = pos &amp; 1;</div><div class="line">    int modKey = key % mod;</div><div class="line">    if (modKey &lt; 0) modKey += mod;</div><div class="line">    e[p].nxt = link1[modKey];</div><div class="line">    link1[modKey] = p++;</div><div class="line">&#125;</div><div class="line">bool Find(ll key, int odd) &#123;</div><div class="line">    int modKey = key % mod;</div><div class="line">    if (modKey &lt; 0) modKey += mod;</div><div class="line">    for (int i = link1[modKey]; i != -1; i = e[i].nxt) &#123;</div><div class="line">        if (e[i].key == key &amp;&amp; e[i].pos == odd) return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int T, n, k, x;</div><div class="line">    scanf(&quot;%d&quot;, &amp;T);</div><div class="line">    for (int cas = 1; cas &lt;= T; cas++) &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</div><div class="line">        ll s = 0;</div><div class="line">        init();</div><div class="line">        add(s, 0);</div><div class="line">        bool ok = false;</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            scanf(&quot;%d&quot;, &amp;x);</div><div class="line">            if (i &amp; 1) s += x;</div><div class="line">            else s -= x;</div><div class="line">            if (!ok) &#123;</div><div class="line">                if (Find(s - k, 0)) ok = true;</div><div class="line">                if (Find(s + k, 1)) ok = true;</div><div class="line">                add(s, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;Case #%d: %s.\n&quot;, cas, ok ? &quot;Yes&quot; : &quot;No&quot;);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5183&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5183&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定n个数的序列（A0,A1,A2…,An-1) 规定NP-sum(i,j) = Ai - Ai+1 + Ai+2 + (-1)^(j-i)Aj&lt;br&gt;现在给定一个K，问是否有一个NP-sum(i,j)=K&lt;br&gt;1≤n≤1000000,−1000000000≤ai≤1000000000,−1000000000≤K≤1000000000&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;sum[i]=a1−a2+a3…。手写一个哈希表来保存所有出现过的sum值,然后根据奇偶性分类判断在哈系表中是否存在对应的子序列满足题意&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5084 HeHe（矩阵+强行找规律）</title>
    <link href="http://yoursite.com/2015/10/09/hdu5084/"/>
    <id>http://yoursite.com/2015/10/09/hdu5084/</id>
    <published>2015-10-09T12:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5084" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5084</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个矩阵，矩阵的形式如下：<br>M = |tn,   tn+1, …, t2<em>n-1|<br>    |tn-1, tn,   …, t2</em>n-2|<br>    |.                      |<br>    |t1,   t2,   …, tn    |<br>有Q组询问，每次询问A(x,y) 其中A = M * M</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于n是1000级别的，所以常规的矩阵乘无法满足条件。<br>观察发现ans[x][y]就是 a[y]<em>a[2</em>n-x] + …. + a[y+n-1]<em>a[n-x+1] 乘的这部分 a[i]</em>a[j] i+j是定值 所以 对于i+j等于某个数的，求个前缀和 最后每个值就O(1)得到了</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">typedef long long ll;</div><div class="line">using namespace std;</div><div class="line">const int N = 1010;</div><div class="line">ll t[2 * N], f[3 * N][2 * N];</div><div class="line">int n;</div><div class="line">void init() &#123;</div><div class="line">    for (int i = n + 1; i &lt;= 3 * n - 1; i++) &#123;</div><div class="line">        f[i][0] = 0;</div><div class="line">        for (int j = 1; j &lt; 2 * n; j++) &#123;</div><div class="line">            if (i &gt; j &amp;&amp; (i - j) &lt;= 2 * n - 1) f[i][j] = t[j] * t[i - j] + f[i][j - 1];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;n)) &#123;</div><div class="line">        for (int i = 1; i &lt; 2 * n; i++) scanf(&quot;%d&quot;, t + i);</div><div class="line">        init();</div><div class="line">        ll ans = 0, ret = 0;</div><div class="line">        int r, c, m;</div><div class="line">        scanf(&quot;%d&quot;, &amp;m);</div><div class="line">        while(m--) &#123;</div><div class="line">            scanf(&quot;%d%d&quot;, &amp;r, &amp;c);</div><div class="line">            r = (r + ret) % n + 1;</div><div class="line">            c = (c + ret) % n + 1;</div><div class="line">            ret = f[2 * n - r + c][2 * n - r] - f[2 * n - r + c][n - r];</div><div class="line">            ans += ret;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%I64d\n&quot;, ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5084&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5084&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一个矩阵，矩阵的形式如下：&lt;br&gt;M = |tn,   tn+1, …, t2&lt;em&gt;n-1|&lt;br&gt;    |tn-1, tn,   …, t2&lt;/em&gt;n-2|&lt;br&gt;    |.                      |&lt;br&gt;    |t1,   t2,   …, tn    |&lt;br&gt;有Q组询问，每次询问A(x,y) 其中A = M * M&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;由于n是1000级别的，所以常规的矩阵乘无法满足条件。&lt;br&gt;观察发现ans[x][y]就是 a[y]&lt;em&gt;a[2&lt;/em&gt;n-x] + …. + a[y+n-1]&lt;em&gt;a[n-x+1] 乘的这部分 a[i]&lt;/em&gt;a[j] i+j是定值 所以 对于i+j等于某个数的，求个前缀和 最后每个值就O(1)得到了&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="想法" scheme="http://yoursite.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5021 Revenge of kNN II（二分+树状数组）</title>
    <link href="http://yoursite.com/2015/10/09/hdu5021/"/>
    <id>http://yoursite.com/2015/10/09/hdu5021/</id>
    <published>2015-10-09T11:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5021" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5021</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定n个点，每个点有一个值。现在有一些询问，每次用离某点距离最小的K个点的平均值来更新该点的值，如果有两个点距离相同，去index小的点。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>可以用二分来求每次离该点最近的K个点，二分离该点的距离值即可。注意一些细节问题</li><li>用树状数组来维护距离和</li></ol><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 100000 + 100;</div><div class="line">int n, q;</div><div class="line">int x[N], v[N], rk[N], p[N];</div><div class="line">pair&lt;int, int&gt; d[N];</div><div class="line">double c[N], b[N];</div><div class="line">int main () &#123;</div><div class="line">    int T;</div><div class="line">    scanf(&quot;%d&quot;, &amp;T);</div><div class="line">    while(T--) &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;q);</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            scanf(&quot;%d%d&quot;, x + i, v + i);</div><div class="line">            d[i] = make_pair(x[i], i);</div><div class="line">            c[i] = 0;</div><div class="line">        &#125;</div><div class="line">        sort(d + 1, d + n + 1);</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            rk[d[i].second] = i;</div><div class="line">            b[i] = v[d[i].second];</div><div class="line">            p[i] = d[i].first;</div><div class="line">            for (int j = i; j &lt;= n; j += j &amp; -j) c[j] += b[i];</div><div class="line">        &#125;</div><div class="line">        double ans = 0;</div><div class="line">        while(q--) &#123;</div><div class="line">            int i, k, dis;</div><div class="line">            scanf(&quot;%d%d&quot;, &amp;i, &amp;k);</div><div class="line">            dis = x[i];</div><div class="line">            i = rk[i];</div><div class="line">            int l = 1, r = 1e9, mid;</div><div class="line">            while(l &lt; r) &#123;</div><div class="line">                mid = (l + r) &gt;&gt; 1;</div><div class="line">                int sum = upper_bound(p + 1, p + n + 1, dis + mid) - lower_bound(p + 1, p + n + 1, dis - mid);</div><div class="line">                if (sum &gt;= k + 1) r = mid;</div><div class="line">                else l = mid + 1;</div><div class="line">            &#125;</div><div class="line">            int L = lower_bound(p + 1, p + n + 1, dis - r) - p;</div><div class="line">            int R = upper_bound(p + 1, p + n + 1, dis + r) - p - 1;</div><div class="line">            if (L + k != R) &#123;</div><div class="line">                if (d[L].second &lt; d[R].second) --R;</div><div class="line">                else ++L;</div><div class="line">            &#125;</div><div class="line">            double sum = 0;</div><div class="line">            for (int j = R; j &gt; 0; j -= j &amp; -j) sum += c[j];</div><div class="line">            for (int j = L - 1; j &gt; 0; j -= j &amp; -j) sum -= c[j];</div><div class="line">            sum -= b[i];</div><div class="line">            sum /= k;</div><div class="line">            ans += sum;</div><div class="line">            for (int j = i; j &lt;= n; j += j &amp; -j) c[j] += sum - b[i];</div><div class="line">            b[i] = sum;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%.3lf\n&quot;, ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5021&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5021&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定n个点，每个点有一个值。现在有一些询问，每次用离某点距离最小的K个点的平均值来更新该点的值，如果有两个点距离相同，去index小的点。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;可以用二分来求每次离该点最近的K个点，二分离该点的距离值即可。注意一些细节问题&lt;/li&gt;
&lt;li&gt;用树状数组来维护距离和&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5064 Find Sequence（LIS+dp）</title>
    <link href="http://yoursite.com/2015/10/07/hdu5064/"/>
    <id>http://yoursite.com/2015/10/07/hdu5064/</id>
    <published>2015-10-07T11:00:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5064" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5064</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定n个正整数，这n个数相加为M（0&lt;M≤2^22）。问从这n个数选出一些数，从小到大排序，使得b2-b1≤b3-b2……≤bt-bt-1。求t的最大值</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先考虑解的结构一定是C1,C1……C2,C3……Cm。其中C1&lt;C2&lt;……&lt;Cm。所以可以对ai去重后排序。可以知道此时的ai的个数为sqrt(M)级别的。<br>然后用dp[i][j]表示以aj结尾，ai为倒数第二个数的最优解。dp[i][j] = max(dp[k][i]) + 1, 其中ai-ak≤aj-ai<br>这样的复杂度是O(n^3),其中n为1000级别的，会TLE。<br>发现有一个优化：dp[i][j+1] = max(dp[k][i]) + 1, 其中ai-ak≤aj-ai&lt;aj+1-ai。所以重复的部分只需要计算一次即可。这样复杂度降到O(n^2)</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 3000;</div><div class="line">int n, m;</div><div class="line">int a[N * N], cnt[N], dp[N][N];</div><div class="line">void change(int &amp;a, int b) &#123;</div><div class="line">    if (a &lt; b) a = b;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    int T;</div><div class="line">    scanf(&quot;%d&quot;, &amp;T);</div><div class="line">    while(T--) &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</div><div class="line">        for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i);</div><div class="line">        sort(a + 1, a + n + 1);</div><div class="line">        int cur;</div><div class="line">        cnt[cur = 1] = 1;</div><div class="line">        for (int i = 2; i &lt;= n; i++) &#123;</div><div class="line">            if (a[i] == a[cur]) cnt[cur]++;</div><div class="line">            else &#123;</div><div class="line">                a[++cur] = a[i];</div><div class="line">                cnt[cur] = 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        n = cur;</div><div class="line">        for (int i = 1; i &lt;= n; i++) dp[i][i] = cnt[i];</div><div class="line">        int k, res, ans = 0;</div><div class="line">        for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">            k = i;</div><div class="line">            res = dp[i][i];</div><div class="line">            change(ans, res);</div><div class="line">            for (int j = i + 1; j &lt;= n; j++) &#123;</div><div class="line">                for (; k &gt; 0 &amp;&amp; a[i] - a[k] &lt;= a[j] - a[i]; k--) change(res, dp[k][i] + 1);</div><div class="line">                dp[i][j] = res;</div><div class="line">                change(ans, res);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%d\n&quot;, ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5064&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5064&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定n个正整数，这n个数相加为M（0&amp;lt;M≤2^22）。问从这n个数选出一些数，从小到大排序，使得b2-b1≤b3-b2……≤bt-bt-1。求t的最大值&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;首先考虑解的结构一定是C1,C1……C2,C3……Cm。其中C1&amp;lt;C2&amp;lt;……&amp;lt;Cm。所以可以对ai去重后排序。可以知道此时的ai的个数为sqrt(M)级别的。&lt;br&gt;然后用dp[i][j]表示以aj结尾，ai为倒数第二个数的最优解。dp[i][j] = max(dp[k][i]) + 1, 其中ai-ak≤aj-ai&lt;br&gt;这样的复杂度是O(n^3),其中n为1000级别的，会TLE。&lt;br&gt;发现有一个优化：dp[i][j+1] = max(dp[k][i]) + 1, 其中ai-ak≤aj-ai&amp;lt;aj+1-ai。所以重复的部分只需要计算一次即可。这样复杂度降到O(n^2)&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
      <category term="LIS" scheme="http://yoursite.com/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>HDU 5020 Revenge of Collinearity（n个点三点共线）</title>
    <link href="http://yoursite.com/2015/09/29/hdu5020/"/>
    <id>http://yoursite.com/2015/09/29/hdu5020/</id>
    <published>2015-09-29T07:50:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5020" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5020</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定n个点，问有多少个三点共线的三元组。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>以每个点为基点进行极角排序，统计三点共线的个数。<br><a id="more"></a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 1111;</div><div class="line">int x[N], y[N];</div><div class="line">pair&lt;int, int&gt; v[N];</div><div class="line">int main () &#123;</div><div class="line">    int t, n, tot;</div><div class="line">    scanf(&quot;%d&quot;, &amp;t);</div><div class="line">    while(t--) &#123;</div><div class="line">        scanf(&quot;%d&quot;, &amp;n);</div><div class="line">        for (int i = 0; i &lt; n; i++) scanf(&quot;%d%d&quot;, x + i, y + i);</div><div class="line">        ll ans = 0;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            tot = 0;</div><div class="line">            for (int j = 0; j &lt; n; j++) if (i != j) &#123;</div><div class="line">                int dx = x[i] - x[j], dy = y[i] - y[j];</div><div class="line">                int d = __gcd(dx, dy);</div><div class="line">                dx /= d, dy /= d;</div><div class="line">                if (dx != 0 &amp;&amp; dy != 0) &#123;</div><div class="line">                    if (dx &lt; 0) dx *= -1, dy *= -1;</div><div class="line">                &#125; else dx = max(dx, -dx), dy = max(dy, -dy);</div><div class="line">                v[tot++] = make_pair(dx, dy);</div><div class="line">            &#125;</div><div class="line">            sort(v, v + tot);</div><div class="line">            int now = 0;</div><div class="line">            for (int j = 0; j &lt; tot; j++) &#123;</div><div class="line">                if (j == 0 || v[j] != v[j - 1]) now = j;</div><div class="line">                ans += j - now;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%I64d\n&quot;, ans / 3);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5020&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=5020&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定n个点，问有多少个三点共线的三元组。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;以每个点为基点进行极角排序，统计三点共线的个数。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="计算几何" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="三点共线" scheme="http://yoursite.com/tags/%E4%B8%89%E7%82%B9%E5%85%B1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4992 Primitive Roots（求一个数的所有原根）</title>
    <link href="http://yoursite.com/2015/09/25/hdu4992/"/>
    <id>http://yoursite.com/2015/09/25/hdu4992/</id>
    <published>2015-09-25T12:50:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4992" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=4992</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个数n，求n的所有原根，按照从小到大输出，如果没有原根输出-1</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>原根的定义：g^d % p = 1 其中d最小为phi(p)，则g便为一个原根</p><ol><li><p>一个数是否有原根<br> 判断数是否有原根：模n有原根的充要条件是n = 1,2,4,p,2p,p^q，其中p是奇质数，q是任意正整数。</p></li><li><p>若有，找其最小原根<br>然后用欧拉公式求出n的m=φ(n)，从2~n-1遍历找出n的最小原根a：判断a^m % n==1 是否成立<br>计算出所有m的因子（1和m除外）y，若a^y % n==1，则a不可能是n的原根。因为存在性质：如果正整数gcd(a,m) = 1，正整数 d 满足a^d≡1(mod m)，则 d 整除 φ(m)。</p></li><li><p>已知一个原根，得到所有原根<br> 得到所有a^x % n {2&lt;=x&lt;m，gcd(x,m)==1}的值为n的原根<br> 证明：<a href="http://blog.csdn.net/solotzg/article/details/39205337" target="_blank" rel="external">http://blog.csdn.net/solotzg/article/details/39205337</a></p></li></ol><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">#define maxn 1000000</div><div class="line">int ans[maxn + 10], valid[maxn + 10], tot = 0;</div><div class="line">void getPrime(int n, int &amp;tot, int ans[]) &#123;</div><div class="line">    for (int i = 2; i &lt;= n; i++) &#123;</div><div class="line">        if (!valid[i]) ans[tot++] = i;</div><div class="line">        for (int j = 0; j &lt; tot &amp;&amp; i * ans[j] &lt;= n; j++) &#123;</div><div class="line">            valid[i * ans[j]] = 1;</div><div class="line">            if (i % ans[j] == 0) break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">///判断是否有原根</div><div class="line">///判断数是否有原根：模n有原根的充要条件是n = 1,2,4,p,2p,p^q，其中p是奇质数，q是任意正整数。</div><div class="line">bool has_primitive_root(int n) &#123;</div><div class="line">    if (n % 2 == 0) n /= 2;</div><div class="line">    if (n % 2 == 0) return false;</div><div class="line">    for (int i = 1; ans[i] * ans[i] &lt;= n; i++) if (n % ans[i] == 0)&#123;</div><div class="line">        while(n % ans[i] == 0) n /= ans[i];</div><div class="line">        if (n != 1) return false;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">///得到最小的原根</div><div class="line">ll pow_mod(ll a, ll x, ll p) &#123;</div><div class="line">    ll res = 1;</div><div class="line">    while(x) &#123;</div><div class="line">        if (x &amp; 1) res = res * a % p;</div><div class="line">        x &gt;&gt;= 1;</div><div class="line">        a = a * a % p;</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">ll euler(ll x) &#123;</div><div class="line">    ll res = x;</div><div class="line">    for (ll i = 0; ans[i] * ans[i] &lt;= x; i++) if (x % ans[i] == 0) &#123;</div><div class="line">        res = res / ans[i] * (ans[i] - 1);</div><div class="line">        while(x % ans[i] == 0) x /= ans[i];</div><div class="line">    &#125;</div><div class="line">    if (x &gt; 1) res = res / x * (x - 1);</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">vector&lt;ll&gt; a;</div><div class="line">bool g_test(ll g, ll p, ll fhi_n) &#123;</div><div class="line">    for (ll i = 0; i &lt; a.size(); i++)</div><div class="line">        if (pow_mod(g, fhi_n / a[i], p) == 1) return 0;</div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">ll primitive_root(ll p, ll fhi_n) &#123;</div><div class="line">    a.clear();</div><div class="line">    ll tmp = fhi_n;</div><div class="line">    for (ll i = 0; ans[i] * ans[i] &lt;= tmp; i++) if (tmp % ans[i] == 0) &#123; //这里还可以用筛素数优化</div><div class="line">        a.push_back(ans[i]);</div><div class="line">        while(tmp % ans[i] == 0) tmp /= ans[i];</div><div class="line">    &#125;</div><div class="line">    if (tmp != 1) a.push_back(tmp);</div><div class="line">    ll g = 1;</div><div class="line">    while(true) &#123;</div><div class="line">        if (pow_mod(g, fhi_n, p) != 1) &#123; ///要先判断g^fhi_n % p == 1</div><div class="line">            g++;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (g_test(g, p, fhi_n)) return g;</div><div class="line">        g++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">///根据最小原根得到所有原根</div><div class="line">vector&lt;int&gt; Getall_primitive_root(int g, int n, int fhi_n) &#123;</div><div class="line">    vector&lt;int&gt; res;</div><div class="line">    res.pb(g);</div><div class="line">    for (int i = 2; i &lt; fhi_n; i++) &#123;</div><div class="line">        if (__gcd(i, fhi_n) != 1) continue;</div><div class="line">        res.pb(pow_mod(g, i, n));</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    getPrime(maxn, tot, ans);</div><div class="line">    int n;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;n)) &#123;</div><div class="line">        if (n == 2) &#123;</div><div class="line">            puts(&quot;1&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (n == 4) &#123;</div><div class="line">            puts(&quot;3&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (!has_primitive_root(n)) &#123;</div><div class="line">            puts(&quot;-1&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        ll fhi_n = euler(n);</div><div class="line">        ll g = primitive_root(n, fhi_n);</div><div class="line">        vector&lt;int&gt; res = Getall_primitive_root(g, n, fhi_n);</div><div class="line">        sort(res.begin(), res.end());</div><div class="line">        for (int i = 0; i &lt; res.size(); i++) &#123;</div><div class="line">            printf(&quot;%d%c&quot;, res[i], i == res.size() - 1 ? &apos;\n&apos; : &apos; &apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4992&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=4992&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一个数n，求n的所有原根，按照从小到大输出，如果没有原根输出-1&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;原根的定义：g^d % p = 1 其中d最小为phi(p)，则g便为一个原根&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个数是否有原根&lt;br&gt; 判断数是否有原根：模n有原根的充要条件是n = 1,2,4,p,2p,p^q，其中p是奇质数，q是任意正整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若有，找其最小原根&lt;br&gt;然后用欧拉公式求出n的m=φ(n)，从2~n-1遍历找出n的最小原根a：判断a^m % n==1 是否成立&lt;br&gt;计算出所有m的因子（1和m除外）y，若a^y % n==1，则a不可能是n的原根。因为存在性质：如果正整数gcd(a,m) = 1，正整数 d 满足a^d≡1(mod m)，则 d 整除 φ(m)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;已知一个原根，得到所有原根&lt;br&gt; 得到所有a^x % n {2&amp;lt;=x&amp;lt;m，gcd(x,m)==1}的值为n的原根&lt;br&gt; 证明：&lt;a href=&quot;http://blog.csdn.net/solotzg/article/details/39205337&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/solotzg/article/details/39205337&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="原根" scheme="http://yoursite.com/tags/%E5%8E%9F%E6%A0%B9/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4991 Ordered Subsequence（LIS+树状数组）</title>
    <link href="http://yoursite.com/2015/09/25/hdu4991/"/>
    <id>http://yoursite.com/2015/09/25/hdu4991/</id>
    <published>2015-09-25T04:50:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4991" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=4991</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个长度为N的序列，问所有长度为M的上升子序列的个数</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>另dp[i][j]表示以a[i]为结尾，长度为j的上升子序列的个数，有如下转移方程<br>dp[i][j] = sum(dp[k][j - 1]) 其中k小于i，且a[k]&lt;a[i]<br>朴素的转移是n2<em>m，可以通过树状数组来维护和，复杂度降到n</em>m*log(n)</p><p>取模真心慢。。2s左右的代码，把取模改成减直接300+ms就过了<br><a id="more"></a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#define pb push_back</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int N = 10005;</div><div class="line">int n, m, a[N], b[N];</div><div class="line">int s[105][N];</div><div class="line">int mod = 123456789;</div><div class="line">int lowbit(int x) &#123;</div><div class="line">    return x &amp; (-x);</div><div class="line">&#125;</div><div class="line">void add(int x, int v, int id) &#123;</div><div class="line">    while(x &lt;= n) &#123;</div><div class="line">        s[id][x] += v;</div><div class="line">        if (s[id][x] &gt;= mod) s[id][x] -= mod;</div><div class="line">        x += lowbit(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ll sum(int x, int id) &#123;</div><div class="line">    ll res = 0;</div><div class="line">    while(x) &#123;</div><div class="line">        res += s[id][x];</div><div class="line">        if (res &gt;= mod) res -= mod;</div><div class="line">        x -= lowbit(x);</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123;</div><div class="line">        for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, a + i), b[i] = a[i];</div><div class="line">        sort(b, b + n);</div><div class="line">        int t = unique(b, b + n) - b;</div><div class="line">        for (int i = 1; i &lt;= n; i++)</div><div class="line">            for (int j = 0; j &lt;= m; j++) s[j][i] = 0;</div><div class="line">        ll ans = 0;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            int pos = lower_bound(b, b + t, a[i]) - b + 1;</div><div class="line">            add(pos, 1, 1);</div><div class="line">            for (int j = 2; j &lt;= m; j++) &#123;</div><div class="line">                ll tmp = sum(pos - 1, j - 1);</div><div class="line">                if (!tmp) break;</div><div class="line">                add(pos, tmp, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ans = sum(t, m);</div><div class="line">        printf(&quot;%I64d\n&quot;, ans);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4991&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=4991&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一个长度为N的序列，问所有长度为M的上升子序列的个数&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;另dp[i][j]表示以a[i]为结尾，长度为j的上升子序列的个数，有如下转移方程&lt;br&gt;dp[i][j] = sum(dp[k][j - 1]) 其中k小于i，且a[k]&amp;lt;a[i]&lt;br&gt;朴素的转移是n2&lt;em&gt;m，可以通过树状数组来维护和，复杂度降到n&lt;/em&gt;m*log(n)&lt;/p&gt;
&lt;p&gt;取模真心慢。。2s左右的代码，把取模改成减直接300+ms就过了&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="dp" scheme="http://yoursite.com/tags/dp/"/>
    
      <category term="树状数组" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="LIS" scheme="http://yoursite.com/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4990 Reading comprehension（分奇偶讨论+矩阵快速幂）</title>
    <link href="http://yoursite.com/2015/09/25/hdu4990/"/>
    <id>http://yoursite.com/2015/09/25/hdu4990/</id>
    <published>2015-09-25T04:50:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4990" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=4990</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定n，按照以下程序算出ans。（n为int）<br>    ans=0;<br>    for(i=1;i&lt;=n;i++)<br>    {<br>      if(i&amp;1)ans=(ans<em>2+1)%m;<br>      else ans=ans</em>2%m;<br>    }<br>    printf(“%d\n”,ans);</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分奇偶讨论<br>当n为奇数时：fn=4<em>fn-1 + 1，首项为1<br>当n为偶数时：fn=4</em>fn-1 + 2，首项为2<br>之后就矩阵快速幂加速运算即可。</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cmath&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">#include&lt;set&gt;</div><div class="line">#define pb push_back</div><div class="line">#define INF 1 &lt;&lt; 30</div><div class="line">#define fi first</div><div class="line">#define se second</div><div class="line">#define debug puts(&quot;=====================&quot;);</div><div class="line">using namespace std;</div><div class="line">typedef long long ll;</div><div class="line">const int maxn = 2;</div><div class="line">const int maxm = 2;</div><div class="line">ll mod;</div><div class="line">struct Matrix &#123;</div><div class="line">    int n, m;</div><div class="line">    ll a[maxn][maxm];</div><div class="line">    void clear() &#123;</div><div class="line">        n = m = 0;</div><div class="line">        memset(a, 0, sizeof(a));</div><div class="line">    &#125;</div><div class="line">    Matrix operator * (const Matrix &amp;b) const &#123; //实现矩阵乘法</div><div class="line">        Matrix tmp;</div><div class="line">        tmp.n = n;</div><div class="line">        tmp.m = b.m;</div><div class="line">        for (int i = 0; i &lt; n; i++)</div><div class="line">            for (int j = 0; j &lt; b.m; j++) tmp.a[i][j] = 0;</div><div class="line">        for (int i = 0; i &lt; n; i++)</div><div class="line">            for (int j = 0; j &lt; m; j++) &#123;</div><div class="line">                if (!a[i][j]) continue;</div><div class="line">                for (int k = 0; k &lt; b.m; k++)</div><div class="line">                    tmp.a[i][k] += a[i][j] * b.a[j][k], tmp.a[i][k] %= mod;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        return tmp;</div><div class="line">    &#125;</div><div class="line">    void Copy(const Matrix &amp;b) &#123;</div><div class="line">        n = b.n, m = b.m;</div><div class="line">        for (int i = 0; i &lt; n; i++)</div><div class="line">            for(int j = 0; j &lt; m; j++) a[i][j] = b.a[i][j];</div><div class="line">    &#125;</div><div class="line">    void unit(int sz) &#123;</div><div class="line">        n = m = sz;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; n; j++) a[i][j] = 0;</div><div class="line">            a[i][i] = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Matrix A, B;</div><div class="line">void init() &#123;</div><div class="line">    A.n = A.m = 2;</div><div class="line">    A.a[0][0] = 4;</div><div class="line">    A.a[0][1] = 1;</div><div class="line">    A.a[1][0] = 0;</div><div class="line">    A.a[1][1] = 1;</div><div class="line">&#125;</div><div class="line">Matrix Matrix_pow(Matrix A, ll k, ll mod) &#123; //矩阵快速幂</div><div class="line">    Matrix res;</div><div class="line">    res.clear();</div><div class="line">    res.n = res.m = 2;</div><div class="line">    for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1;</div><div class="line">    while(k) &#123;</div><div class="line">        if (k &amp; 1) res.Copy(A * res);</div><div class="line">        k &gt;&gt;= 1;</div><div class="line">        A.Copy(A * A);</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    init();</div><div class="line">    int n, m;</div><div class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123;</div><div class="line">        mod = m;</div><div class="line">        Matrix ans = Matrix_pow(A, n / 2, mod);</div><div class="line">        ll res;</div><div class="line">        if (n &amp; 1) res = ans.a[0][0] * 1 + ans.a[0][1] * 1;</div><div class="line">        else res = ans.a[0][1] * 2;</div><div class="line">        res = (res + mod) % mod;</div><div class="line">        printf(&quot;%I64d\n&quot;, res);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=4990&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定n，按照以下程序算出ans。（n为int）&lt;br&gt;    ans=0;&lt;br&gt;    for(i=1;i&amp;lt;=n;i++)&lt;br&gt;    {&lt;br&gt;      if(i&amp;amp;1)ans=(ans&lt;em&gt;2+1)%m;&lt;br&gt;      else ans=ans&lt;/em&gt;2%m;&lt;br&gt;    }&lt;br&gt;    printf(“%d\n”,ans);&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;分奇偶讨论&lt;br&gt;当n为奇数时：fn=4&lt;em&gt;fn-1 + 1，首项为1&lt;br&gt;当n为偶数时：fn=4&lt;/em&gt;fn-1 + 2，首项为2&lt;br&gt;之后就矩阵快速幂加速运算即可。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="矩阵" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3481 Double Queue（SBT平衡二叉树）</title>
    <link href="http://yoursite.com/2015/09/24/poj3481/"/>
    <id>http://yoursite.com/2015/09/24/poj3481/</id>
    <published>2015-09-24T15:50:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://poj.org/problem?id=3481" target="_blank" rel="external">http://poj.org/problem?id=3481</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个队伍，一开始为空，有四种操作<br>0表示结束<br>1 K P 有一个编号为K的，优先级为P的人加入队伍（队伍中没有相同的K与P）<br>2 优先级最高的人出队<br>3 优先级最低的人出队</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="http://blog.csdn.net/acm_cxlove/article/details/7790305" target="_blank" rel="external">http://blog.csdn.net/acm_cxlove/article/details/7790305</a></p><p>平衡二叉树，能够得到第K大的数，也能够求出一个数的rank。<br>这里是找最大值与最小值</p><a id="more"></a><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cstring&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">#include&lt;algorithm&gt;</div><div class="line">#define N 1000005</div><div class="line">using namespace std;</div><div class="line">struct SBT &#123;</div><div class="line">    //左子树指针，右子树指针，大小，键值</div><div class="line">    int left, right, size, key, value;</div><div class="line">    void Init() &#123;</div><div class="line">        left = right = key = value = 0;</div><div class="line">        size = 1;</div><div class="line">    &#125;</div><div class="line">&#125; T[N];</div><div class="line">int root, tot; //根的位置以及节点个数</div><div class="line">//左旋转处理</div><div class="line">void Left_rot(int &amp;x) &#123;</div><div class="line">    int k = T[x].right;</div><div class="line">    T[x].right = T[k].left;</div><div class="line">    T[k].left = x;</div><div class="line">    T[k].size = T[x].size;</div><div class="line">    T[x].size = T[T[x].left].size + T[T[x].right].size + 1;</div><div class="line">    x = k;</div><div class="line">&#125;</div><div class="line">//右旋转处理</div><div class="line">void Right_rot(int &amp;x) &#123;</div><div class="line">    int k = T[x].left;</div><div class="line">    T[x].left = T[k].right;</div><div class="line">    T[k].right = x;</div><div class="line">    T[k].size = T[x].size;</div><div class="line">    T[x].size = T[T[x].left].size + T[T[x].right].size + 1;</div><div class="line">    x = k;</div><div class="line">&#125;</div><div class="line">//调整处理</div><div class="line">void Maintain(int &amp;r, bool flag) &#123;</div><div class="line">    if(flag) &#123; //更新右子树</div><div class="line">        if(T[T[T[r].right].right].size &gt; T[T[r].left].size)</div><div class="line">            Left_rot(r);</div><div class="line">        else if(T[T[T[r].right].left].size &gt; T[T[r].left].size) &#123;</div><div class="line">            Right_rot(T[r].right);</div><div class="line">            Left_rot(r);</div><div class="line">        &#125; else</div><div class="line">            return;</div><div class="line">    &#125; else &#123; //更新在左子树</div><div class="line">        if(T[T[T[r].left].left].size &gt; T[T[r].right].size)</div><div class="line">            Right_rot(r);</div><div class="line">        else if(T[T[T[r].left].right].size &gt; T[T[r].right].size) &#123;</div><div class="line">            Left_rot(T[r].left);</div><div class="line">            Right_rot(r);</div><div class="line">        &#125; else</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line">    //更新子树，然后再更新根，直到平衡为止</div><div class="line">    Maintain(T[r].left, false);</div><div class="line">    Maintain(T[r].right, true);</div><div class="line">    Maintain(r, false);</div><div class="line">    Maintain(r, true);</div><div class="line">&#125;</div><div class="line">//插入新节点</div><div class="line">void Insert(int &amp;r, int k, int v) &#123;</div><div class="line">    if(r == 0) &#123;</div><div class="line">        r = ++tot;</div><div class="line">        T[r].Init();</div><div class="line">        T[r].key = k;</div><div class="line">        T[r].value = v;</div><div class="line">    &#125; else &#123;</div><div class="line">        T[r].size++;</div><div class="line">        if(k &lt; T[r].key)</div><div class="line">            Insert(T[r].left, k, v);</div><div class="line">        else</div><div class="line">            Insert(T[r].right, k, v);</div><div class="line">        //插入后要调整，保证平衡</div><div class="line">        Maintain(r, k &gt;= T[r].key);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//删除结点，利用的是前驱替换</div><div class="line">int Remove(int &amp;r, int k) &#123;</div><div class="line">    int d_key;</div><div class="line">    if(!r)</div><div class="line">        return 0;</div><div class="line">    T[r].size--;</div><div class="line">    //前者说明就是要删的节点，后两者说明不存在此节点</div><div class="line">    if(T[r].key == k || (T[r].left == 0 &amp;&amp; k &lt; T[r].key) || (T[r].right == 0 &amp;&amp; k &gt; T[r].key)) &#123;</div><div class="line">        d_key = T[r].key;</div><div class="line">        if(T[r].left &amp;&amp; T[r].right)</div><div class="line">            T[r].key = Remove(T[r].left, k + 1);</div><div class="line">        else</div><div class="line">            r = T[r].left + T[r].right;</div><div class="line">    &#125; else Remove(k &lt; T[r].key ? T[r].left : T[r].right, k);</div><div class="line">&#125;</div><div class="line">//取得最大值，即一直遍历到最右的结点</div><div class="line">int Get_Max(int r) &#123;</div><div class="line">    while(T[r].right)</div><div class="line">        r = T[r].right;</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line">//取得最小值，即一直遍历到最左的结点</div><div class="line">int Get_Min(int r) &#123;</div><div class="line">    while(T[r].left)</div><div class="line">        r = T[r].left;</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line">//获得前驱</div><div class="line">int Get_Pre(int &amp;r, int y, int k) &#123;</div><div class="line">    if(r == 0) return y;</div><div class="line">    if(k &gt; T[r].key)</div><div class="line">        Get_Pre(T[r].right, r, k);</div><div class="line">    else</div><div class="line">        Get_Pre(T[r].left, y, k);</div><div class="line">&#125;</div><div class="line">//获得后继</div><div class="line">int Get_Next(int &amp;r, int y, int k) &#123;</div><div class="line">    if(r == 0) return y;</div><div class="line">    if(k &lt; T[r].key)</div><div class="line">        Get_Next(T[r].left, r, k);</div><div class="line">    else</div><div class="line">        Get_Next(T[r].right, y, k);</div><div class="line">&#125;</div><div class="line">//取得第K小的数，注：暂不能解决有重复数的</div><div class="line">int Get_Kth(int &amp;r, int k) &#123;</div><div class="line">    int t = T[T[r].left].size + 1;</div><div class="line">    if(t == k) return T[r].key;</div><div class="line">    if(t &lt; k)  return Get_Kth(T[r].right, k - r);</div><div class="line">    else return Get_Kth(T[r].left, k);</div><div class="line">&#125;</div><div class="line">//获得结点的名次</div><div class="line">int Get_Rank(int &amp;r, int k) &#123;</div><div class="line">    if(k &lt; T[r].key)</div><div class="line">        return Get_Rank(T[r].left, k);</div><div class="line">    else if(k &gt; T[r].key)</div><div class="line">        return Get_Rank(T[r].right, k) + T[T[r].left].size + 1;</div><div class="line">    else</div><div class="line">        return T[T[r].left].size + 1;</div><div class="line">&#125;</div><div class="line">//排序</div><div class="line">void Inorder(int &amp;r) &#123;</div><div class="line">    if(r == 0) return;</div><div class="line">    Inorder(T[r].left);</div><div class="line">    printf(&quot;%d\n&quot;, T[r].key);</div><div class="line">    Inorder(T[r].right);</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    root = tot = 0;</div><div class="line">    int x, k, p;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;x)) &#123;</div><div class="line">        if (!x) break;</div><div class="line">        if (x == 1) &#123;</div><div class="line">            scanf(&quot;%d%d&quot;, &amp;k, &amp;p);</div><div class="line">            Insert(root, p, k);</div><div class="line">        &#125;</div><div class="line">        if (x == 2) &#123;</div><div class="line">            int tmp = Get_Max(root);</div><div class="line">            printf(&quot;%d\n&quot;, T[tmp].value);</div><div class="line">            if (T[tmp].value) Remove(root, T[tmp].key);</div><div class="line">        &#125;</div><div class="line">        if (x == 3) &#123;</div><div class="line">            int tmp = Get_Min(root);</div><div class="line">            printf(&quot;%d\n&quot;, T[tmp].value);</div><div class="line">            if (T[tmp].value) Remove(root, T[tmp].key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://poj.org/problem?id=3481&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://poj.org/problem?id=3481&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;有一个队伍，一开始为空，有四种操作&lt;br&gt;0表示结束&lt;br&gt;1 K P 有一个编号为K的，优先级为P的人加入队伍（队伍中没有相同的K与P）&lt;br&gt;2 优先级最高的人出队&lt;br&gt;3 优先级最低的人出队&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/acm_cxlove/article/details/7790305&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/acm_cxlove/article/details/7790305&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;平衡二叉树，能够得到第K大的数，也能够求出一个数的rank。&lt;br&gt;这里是找最大值与最小值&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="SBT" scheme="http://yoursite.com/tags/SBT/"/>
    
  </entry>
  
  <entry>
    <title>HDU 4988 Little Pony and Boast Busters（动态逆序对 树状数组+treap）</title>
    <link href="http://yoursite.com/2015/09/24/hdu4988/"/>
    <id>http://yoursite.com/2015/09/24/hdu4988/</id>
    <published>2015-09-24T15:50:00.000Z</published>
    <updated>2017-10-01T02:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>源地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4988" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=4988</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定上下两个排列 A[], B[]，要求询问相同项之间两两连线的交叉数，并支持交换操作</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题解： <a href="http://www.shuizilong.com/house/archives/bestcoder-round-7-solution/" target="_blank" rel="external">http://www.shuizilong.com/house/archives/bestcoder-round-7-solution/</a><br>静态问题就是求排列 P[] 的逆序对<br>其中 P[i] = pA[B[i]]（这里 pA[] 是 A[] 中某个元素的位置 类似的 pB[] 是 B[] 中某个元素的位置）<br>考察交换操作，无论是交换下排还是上排，都可以看成交换 P[] 中的两项<br>于是转化成动态逆序对问题，支持修改排列中的任意一项。<br>动态逆序对问题等价于区间 kth 大值（区间 Rank）问题。。可以用经典的树套树方法<br>复杂度 O(nlog2n)。</p><p><a href="http://blog.csdn.net/u013654696/article/details/38964519" target="_blank" rel="external">http://blog.csdn.net/u013654696/article/details/38964519</a><br><a href="http://blog.csdn.net/cq_phqg/article/details/39070857" target="_blank" rel="external">http://blog.csdn.net/cq_phqg/article/details/39070857</a></p><p>这里其实就是每一个树状数组的结点都是一颗SBT。<br><a id="more"></a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div></pre></td><td class="code"><pre><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line">#include &lt;iomanip&gt;</div><div class="line">#include &lt;numeric&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;climits&gt;</div><div class="line">#include &lt;cassert&gt;</div><div class="line">#include &lt;complex&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;bitset&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">using namespace std;</div><div class="line">typedef long long LL;</div><div class="line">const int N = 100005;</div><div class="line">struct SBT&#123;</div><div class="line">    //左子树指针，右子树指针，大小，键值</div><div class="line">    int left,right,size,key;</div><div class="line">    inline void Init()&#123;</div><div class="line">        left=right=key=0;</div><div class="line">        size=1;</div><div class="line">    &#125;</div><div class="line">&#125;T[N * 50];</div><div class="line">int tot; //根的位置以及节点个数</div><div class="line">//左旋转处理</div><div class="line">inline void Left_rot(int &amp;x)&#123;</div><div class="line">    int k=T[x].right;</div><div class="line">    T[x].right=T[k].left;</div><div class="line">    T[k].left=x;</div><div class="line">    T[k].size=T[x].size;</div><div class="line">    T[x].size=T[T[x].left].size+T[T[x].right].size+1;</div><div class="line">    x=k;</div><div class="line">&#125;</div><div class="line">//右旋转处理</div><div class="line">inline void Right_rot(int &amp;x)&#123;</div><div class="line">    int k=T[x].left;</div><div class="line">    T[x].left=T[k].right;</div><div class="line">    T[k].right=x;</div><div class="line">    T[k].size=T[x].size;</div><div class="line">    T[x].size=T[T[x].left].size+T[T[x].right].size+1;</div><div class="line">    x=k;</div><div class="line">&#125;</div><div class="line">//调整处理</div><div class="line">void Maintain(int &amp;r,bool flag)&#123;</div><div class="line">    if(flag)&#123;  //更新右子树</div><div class="line">        if(T[T[T[r].right].right].size&gt;T[T[r].left].size)</div><div class="line">            Left_rot(r);</div><div class="line">        else if(T[T[T[r].right].left].size&gt;T[T[r].left].size)&#123;</div><div class="line">            Right_rot(T[r].right);</div><div class="line">            Left_rot(r);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line">    else&#123;   //更新在左子树</div><div class="line">        if(T[T[T[r].left].left].size&gt;T[T[r].right].size)</div><div class="line">            Right_rot(r);</div><div class="line">        else if(T[T[T[r].left].right].size&gt;T[T[r].right].size)&#123;</div><div class="line">            Left_rot(T[r].left);</div><div class="line">            Right_rot(r);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line">    //更新子树，然后再更新根，直到平衡为止</div><div class="line">    Maintain(T[r].left,false);</div><div class="line">    Maintain(T[r].right,true);</div><div class="line">    Maintain(r,false);</div><div class="line">    Maintain(r,true);</div><div class="line">&#125;</div><div class="line">//插入新节点</div><div class="line">void Insert(int &amp;r,int k)&#123;</div><div class="line">    if(r==0)&#123;</div><div class="line">        r=++tot;</div><div class="line">        T[r].Init();</div><div class="line">        T[r].key=k;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        T[r].size++;</div><div class="line">        if(k&lt;=T[r].key)</div><div class="line">            Insert(T[r].left,k);</div><div class="line">        else</div><div class="line">            Insert(T[r].right,k);</div><div class="line">        //插入后要调整，保证平衡</div><div class="line">        Maintain(r,k&gt;=T[r].key);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//删除结点，利用的是前驱替换</div><div class="line">int d_key;</div><div class="line">void Remove(int &amp;r,int k)&#123;</div><div class="line">    if(!r)</div><div class="line">        return ;</div><div class="line">    T[r].size--;</div><div class="line">    //前者说明就是要删的节点，后两者说明不存在此节点</div><div class="line">    if(T[r].key==k||(T[r].left==0&amp;&amp;k&lt;T[r].key)||(T[r].right==0&amp;&amp;k&gt;T[r].key))&#123;</div><div class="line">        if(T[r].left&amp;&amp;T[r].right) &#123;</div><div class="line">            Remove(T[r].left,k+1);</div><div class="line">            T[r].key = d_key;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            d_key = T[r].key;</div><div class="line">            r=T[r].left+T[r].right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else Remove(k&lt;=T[r].key?T[r].left:T[r].right,k);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//取得最大值，即一直遍历到最右的结点</div><div class="line">int Get_Max(int r)&#123;</div><div class="line">    while(T[r].right)</div><div class="line">        r=T[r].right;</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line">//取得最小值，即一直遍历到最左的结点</div><div class="line">int Get_Min(int r)&#123;</div><div class="line">    while(T[r].left)</div><div class="line">        r=T[r].left;</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line">//获得前驱</div><div class="line">int Get_Pre(int &amp;r,int y,int k)&#123;</div><div class="line">    if(r==0) return y;</div><div class="line">    if(k&gt;T[r].key)</div><div class="line">        Get_Pre(T[r].right,r,k);</div><div class="line">    else</div><div class="line">        Get_Pre(T[r].left,y,k);</div><div class="line">&#125;</div><div class="line">//获得后继</div><div class="line">int Get_Next(int &amp;r,int y,int k)&#123;</div><div class="line">    if(r==0) return y;</div><div class="line">    if(k&lt;T[r].key)</div><div class="line">        Get_Next(T[r].left,r,k);</div><div class="line">    else</div><div class="line">        Get_Next(T[r].right,y,k);</div><div class="line">&#125;</div><div class="line">//取得第K小的数，注：暂不能解决有重复数的</div><div class="line">int Get_Kth(int &amp;r,int k)&#123;</div><div class="line">    int t=T[T[r].left].size+1;</div><div class="line">    if(t==k) return T[r].key;</div><div class="line">    if(t&lt;k)  return Get_Kth(T[r].right,k-r);</div><div class="line">    else return Get_Kth(T[r].left,k);</div><div class="line">&#125;</div><div class="line">//获得结点的名次</div><div class="line">int Get_Rank(int r,int k)&#123;</div><div class="line">    int ans = 0;</div><div class="line">    while (r) &#123;</div><div class="line">        if (T[r].key &lt; k) &#123;</div><div class="line">            ans += T[T[r].left].size + 1;</div><div class="line">            r = T[r].right;</div><div class="line">        &#125;</div><div class="line">        else r = T[r].left;</div><div class="line">    &#125;</div><div class="line">    return ans;</div><div class="line">&#125;</div><div class="line">//排序</div><div class="line">void Inorder(int &amp;r)&#123;</div><div class="line">    if(r==0) return;</div><div class="line">    Inorder(T[r].left);</div><div class="line">    printf(&quot;%d\n&quot;,T[r].key);</div><div class="line">    Inorder(T[r].right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int n, pa[N], pb[N], root[N], a[N], b[N], p[N];</div><div class="line">LL ans;</div><div class="line">inline int lowbit(int x) &#123;</div><div class="line">    return x &amp; (-x);</div><div class="line">&#125;</div><div class="line">inline int Rank(int x, int v) &#123;</div><div class="line">    int ret = 0;</div><div class="line">    for (int i = x; i; i -= lowbit(i))</div><div class="line">        ret += Get_Rank(root[i], v);</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">inline void Add(int x, int v) &#123;</div><div class="line">    for (int i = x; i &lt;= n; i += lowbit(i))</div><div class="line">        Insert(root[i], v);</div><div class="line">&#125;</div><div class="line">inline void Del(int x, int v) &#123;</div><div class="line">    for (int i = x; i &lt;= n; i += lowbit(i))</div><div class="line">        Remove(root[i], v);</div><div class="line">&#125;</div><div class="line">inline void init() &#123;</div><div class="line">    tot = 0; ans = 0;</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        root[i] = 0;</div><div class="line">        pa[a[i]] = i;</div><div class="line">        pb[b[i]] = i;</div><div class="line">    &#125;</div><div class="line">    for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">        int num = pa[b[i]];</div><div class="line">        ans += Rank(i, num);</div><div class="line">        Add(i, num); p[i] = num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">inline void update (int x , int v) &#123;</div><div class="line">    // postion x , from p[x] to v</div><div class="line">    int pre = p[x];</div><div class="line">    Del (x , pre);</div><div class="line">    ans = ans - (Rank (x - 1 , pre) + (n - x - (Rank (n , pre + 1) - Rank (x , pre + 1))));</div><div class="line">    p[x] = v;</div><div class="line">    ans = ans + (Rank (x - 1 , v) + (n - x - (Rank (n , v + 1) - Rank (x , v + 1))));</div><div class="line">    Add (x , v);</div><div class="line">&#125;</div><div class="line">inline void update (int k , int A , int B) &#123;</div><div class="line">    if (k == 0) &#123;</div><div class="line">        swap (a[A] , a[B]);</div><div class="line">        pa[a[A]] = A;pa[a[B]] = B;</div><div class="line">        update (pb[a[A]] , A);</div><div class="line">        update (pb[a[B]] , B);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        swap (b[A] , b[B]);</div><div class="line">        pb[b[A]] = A;pb[b[B]] = B;</div><div class="line">        update (A , pa[b[A]]);</div><div class="line">        update (B , pa[b[B]]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main () &#123;</div><div class="line">    while(~scanf(&quot;%d&quot;, &amp;n)) &#123;</div><div class="line">        for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, a + i), a[i]++;</div><div class="line">        for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, b + i), b[i]++;</div><div class="line">        init();</div><div class="line">        int q, k, A, B;</div><div class="line">        char op[10];</div><div class="line">        scanf(&quot;%d&quot;, &amp;q);</div><div class="line">        LL ret = (LL)n * (n - 1) / 2;</div><div class="line">        while(q--) &#123;</div><div class="line">            scanf(&quot;%s&quot;, op);</div><div class="line">            if (op[0] == &apos;Q&apos;) printf(&quot;%I64d\n&quot;, ret - ans);</div><div class="line">            else &#123;</div><div class="line">                scanf(&quot;%d%d%d&quot;, &amp;k, &amp;A, &amp;B);</div><div class="line">                A++, B++;</div><div class="line">                update(k, A, B);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;源地址：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4988&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=4988&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定上下两个排列 A[], B[]，要求询问相同项之间两两连线的交叉数，并支持交换操作&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;题解： &lt;a href=&quot;http://www.shuizilong.com/house/archives/bestcoder-round-7-solution/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.shuizilong.com/house/archives/bestcoder-round-7-solution/&lt;/a&gt;&lt;br&gt;静态问题就是求排列 P[] 的逆序对&lt;br&gt;其中 P[i] = pA[B[i]]（这里 pA[] 是 A[] 中某个元素的位置 类似的 pB[] 是 B[] 中某个元素的位置）&lt;br&gt;考察交换操作，无论是交换下排还是上排，都可以看成交换 P[] 中的两项&lt;br&gt;于是转化成动态逆序对问题，支持修改排列中的任意一项。&lt;br&gt;动态逆序对问题等价于区间 kth 大值（区间 Rank）问题。。可以用经典的树套树方法&lt;br&gt;复杂度 O(nlog2n)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u013654696/article/details/38964519&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/u013654696/article/details/38964519&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/cq_phqg/article/details/39070857&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/cq_phqg/article/details/39070857&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里其实就是每一个树状数组的结点都是一颗SBT。&lt;br&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="动态逆序对" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="树状数组+treap" scheme="http://yoursite.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-treap/"/>
    
  </entry>
  
</feed>
